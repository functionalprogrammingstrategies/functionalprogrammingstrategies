

@Book{sicp:96,
  author       = {Abelson, Harold and Sussman, Gerald Jay},
  title        = {Structure and Interpretation of Computer Programs},
  note         = {With Julie Sussman},
  year         = 1996,
  edition      = {Second Edition},
  publisher    = {The MIT Press},
  location     = {Cambridge, MA}
}

@inproceedings{lewis00:implicit,
author = {Lewis, Jeffrey R. and Launchbury, John and Meijer, Erik and Shields, Mark B.},
title = {Implicit parameters: dynamic scoping with static types},
year = {2000},
isbn = {1581131259},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/325694.325708},
doi = {10.1145/325694.325708},
abstract = {This paper introduces a language feature, called implicit parameters, that provides dynamically scoped variables within a statically-typed Hindley-Milner framework. Implicit parameters are lexically distinct from regular identifiers, and are bound by a special with construct whose scope is dynamic, rather than static as with let. Implicit parameters are treated by the type system as parameters that are not explicitly declared, but are inferred from their use.We present implicit parameters within a small call-by-name λ-calculus. We give a type system, a type inference algorithm, and several semantics. We also explore implicit parameters in the wider settings of call-by-need languages with overloading, and call-by-value languages with effects. As a witness to the former, we have implemented implicit parameters as an extension of Haskell within the Hugs interpreter, which we use to present several motivating examples.},
booktitle = {Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {108–118},
numpages = {11},
location = {Boston, MA, USA},
series = {POPL '00}
}

@inproceedings{wadler89:adhoc,
author = {Wadler, P. and Blott, S.},
title = {How to make ad-hoc polymorphism less ad hoc},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75283},
doi = {10.1145/75277.75283},
abstract = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {60–76},
numpages = {17},
location = {Austin, Texas, USA},
series = {POPL '89}
}

@InProceedings{stefan88:overloading,
author="Kaes, Stefan",
editor="Ganzinger, H.",
title="Parametric overloading in polymorphic programming languages",
booktitle="ESOP '88",
year="1988",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="131--144",
abstract="The introduction of unrestricted overloading in languages with type systems based on implicit parametric polymorphism generally destroys the principal type property: namely that the type of every expression can uniformly be represented by a single type expression over some set of type variables. As a consequence, type inference in the presence of unrestricted overloading can become a NP-complete problem. In this paper we define the concept of parametric overloading as a restricted form of overloading which is easily combined with parametric polymorphism. Parametric overloading preserves the principal type property, thereby allowing the design of efficient type inference algorithms. We present sound type deduction systems, both for predefined and programmer defined overloading. Finally we state that parametric overloading can be resolved either statically, at compile time, or dynamically, during program execution.",
isbn="978-3-540-38941-5"
}

@inproceedings{oliveira10:type-classes,
author = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
title = {Type classes as objects and implicits},
year = {2010},
isbn = {9781450302036},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1869459.1869489},
doi = {10.1145/1869459.1869489},
abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {341–360},
numpages = {20},
keywords = {abstract datatypes, c++ concepts, scala, type classes},
location = {Reno/Tahoe, Nevada, USA},
series = {OOPSLA '10}
}

@inproceedings{wadler89:free,
author = {Wadler, Philip},
title = {Theorems for free!},
year = {1989},
isbn = {0897913280},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/99370.99404},
doi = {10.1145/99370.99404},
booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
pages = {347–359},
numpages = {13},
location = {Imperial College, London, United Kingdom},
series = {FPCA '89}
}

@article{krikava19:implicits,
author = {K\v{r}ikava, Filip and Miller, Heather and Vitek, Jan},
title = {Scala implicits are everywhere: a large-scale study of the use of Scala implicits in the wild},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360589},
doi = {10.1145/3360589},
abstract = {The Scala programming language offers two distinctive language features implicit parameters and implicit conversions, often referred together as implicits. Announced without fanfare in 2004, implicits have quickly grown to become a widely and pervasively used feature of the language. They provide a way to reduce the boilerplate code in Scala programs. They are also used to implement certain language features without having to modify the compiler. We report on a large-scale study of the use of implicits in the wild. For this, we analyzed 7,280 Scala projects hosted on GitHub, spanning over 8.1M call sites involving implicits and 370.7K implicit declarations across 18.7M lines of Scala code.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {163},
numpages = {28},
keywords = {Implicit parameters, Scala, corpora analysis, implicit conversions}
}

@article{oliveira10:generic,
  title={Scala for generic programmers: Comparing Haskell and Scala support for generic programming}
, volume={20}
, DOI={10.1017/S0956796810000171}
, url={https://www.cambridge.org/core/journals/journal-of-functional-programming/article/scala-for-generic-programmers/223EB37E77EA36B27AE33A644DA70926}
, number={3–4}
, journal={Journal of Functional Programming}
, author={Oliveira, Bruno C. D. S. and Gibbons, Jeremy}
, year={2010}
, pages={303–352}
}

@article{odersky17:implicit,
author = {Odersky, Martin and Blanvillain, Olivier and Liu, Fengyun and Biboudis, Aggelos and Miller, Heather and Stucki, Sandro},
title = {Simplicitly: foundations and applications of implicit function types},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158130},
doi = {10.1145/3158130},
abstract = {Understanding a program entails understanding its context; dependencies, configurations and even implementations are all forms of contexts. Modern programming languages and theorem provers offer an array of constructs to define contexts, implicitly. Scala offers implicit parameters which are used pervasively, but which cannot be abstracted over. This paper describes a generalization of implicit parameters to implicit function types, a powerful way to abstract over the context in which some piece of code is run. We provide a formalization based on bidirectional type-checking that closely follows the semantics implemented by the Scala compiler. To demonstrate their range of abstraction capabilities, we present several applications that make use of implicit function types. We show how to encode the builder pattern, tagless interpreters, reader and free monads and we assess the performance of the monadic structures presented.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {42},
numpages = {29},
keywords = {implicit parameters, Scala, Dotty}
}


@Book{felleisen18:htdp,
  author          = {Matthias Felleisen and Robert Bruce Findler and Matthew Flatt and Shriram Krishnamurthi},
  title           = {How to Design Programs, Second Edition},
  year            = {2018},
  subtitle     = {An Introductino to Programming and Computing},
  publisher    = {The MIT Press},
  location     = {Cambridge, MA},
  isbn         = 9780262534802,
  url          = {https://htdp.org/}}


@Book{beck99:xp,
  author = {Beck, Kent},
  title = {Extreme Programming Explained: Embrace Change},
  year = 1999,
  publisher = {Addison-Wesley},
  isb = 0201616416
}

@Book{gamma94:design-patterns,
  author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  year = 1994,
  publisher = {Addison-Wesley},
  isbn = 0201633612
}

@TechReport{conley14:strategies,
  author          = {Conley, David},
  title           = {Learning Strategies as Metacognitive Factors: A Critical Review},
  institution     = {Educational Policy Improvement Center},
  date            = 2014,
  location     = {Eugene, OR}}

@Article{macintyre14:metacognition,
  author          = {Tadhg E. MacIntyre and Eric R. Igou and Mark J. Campbell and Aidan P. Moran and James Matthews},
  title           = {Metacognition and action: a new pathway to understanding social and cognitive aspects of expertise in sport},
  journaltitle    = {Frontiers in Psychology},
  year            = 2014,
  volume       = 5,
  number       = 1155,
  month        = {October},
  doi          = {10.3389/fpsyg.2014.01155}}

@Article{pintrich02:metacognitive,
  author = {Paul R. Pintrich},
  title = {The Role of Metacognitive Knowledge in Learning, Teaching, and Assessing},
  journaltitle = {Theory into Practice},
  volume = 41,
  number = 4,
  edition = {Autumn},
  year = 2002
}

@PhdThesis{uesbeck19:human,
  author  = {Uesbeck, Phillip Merlin},
  title   = {On the human factors impact of polyglot programming on programmer productivity},
  school  = {University of Nevada, Las Vegas},
  year    = 2019,
  month   = {November},
  pages   = {16--19},
  url     = {https://web.cs.unlv.edu/stefika/documents/MerlinDissertation.pdf}
}

@InProceedings{meijer91:bananas,
author="Meijer, Erik
and Fokkinga, Maarten
and Paterson, Ross",
editor="Hughes, John",
title="Functional programming with bananas, lenses, envelopes and barbed wire",
booktitle="Functional Programming Languages and Computer Architecture",
year="1991",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="124--144",
abstract="We develop a calculus for lazy functional programming based on recursion operators associated with data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's ``Introduction to Functional Programming'' can be expressed using these operators.",
isbn="978-3-540-47599-6",
url={https://ris.utwente.nl/ws/portalfiles/portal/6142049/meijer91functional.pdf}
}

@article{burstall69:proving,
    author = {Burstall, R. M.},
    title = "{Proving Properties of Programs by Structural Induction}",
    journal = {The Computer Journal},
    volume = {12},
    number = {1},
    pages = {41-48},
    year = {1969},
    month = {02},
    abstract = "{This paper discusses the technique of structural induction for proving theorems about programs. This technique is closely related to recursion induction but makes use of the inductive definition of the data structures handled by the programs. It treats programs with recursion but without assignments or jumps. Some syntactic extensions to Landin's functional programming language ISWIM are suggested which make it easier to program the manipulation of data structures and to develop proofs about such programs. Two sample proofs are given to demonstrate the technique, one for a tree sorting algorithm and one for a simple compiler for expressions.}",
    issn = {0010-4620},
    doi = {10.1093/comjnl/12.1.41},
    url = {https://doi.org/10.1093/comjnl/12.1.41},
    eprint = {https://academic.oup.com/comjnl/article-pdf/12/1/41/885019/12-1-41.pdf},
}

@article{gibbons21:htdcp,
 title={How to design co-programs},
 volume={31},
 DOI={10.1017/S0956796821000113},
 journal={Journal of Functional Programming},
 author={Gibbons, Jeremy},
 year={2021},
 pages={e15}
}

@inproceedings{gibbons98:unfold,
author = {Gibbons, Jeremy and Jones, Geraint},
title = {The under-appreciated unfold},
year = {1998},
isbn = {1581130244},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/289423.289455},
doi = {10.1145/289423.289455},
abstract = {Folds are appreciated by functional programmers. Their dual, unfolds, are not new, but they are not nearly as well appreciated. We believe they deserve better. To illustrate, we present (indeed, we calculate) a number of algorithms for computing the breadth-first traversal of a tree. We specify breadth-first traversal in terms of level-order traversal, which we characterize first as a fold. The presentation as a fold is simple, but it is inefficient, and removing the inefficiency makes it no longer a fold. We calculate a characterization as an unfold from the characterization as a fold; this unfold is equally clear, but more efficient. We also calculate a characterization of breadth-first traversal directly as an unfold; this turns out to be the 'standard' queue-based algorithm.},
booktitle = {Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming},
pages = {273–279},
numpages = {7},
keywords = {anamorphism, breadth-first, co-induction, fold, functional programing, level-order, program calculation, traversal, unfold},
location = {Baltimore, Maryland, USA},
series = {ICFP '98}
}

@Unpublished{mcbride01:deriv,
  author          = {Conor McBride},
  title           = {The Derivative of a Regular Type is its Type of One-Hole Contexts},
  year            = 2001,
  url          = {http://strictlypositive.org/diff.pdf}}


@article{hagino89:codatatypes,
title = {Codatatypes in ML},
journal = {Journal of Symbolic Computation},
volume = {8},
number = {6},
pages = {629-650},
year = {1989},
issn = {0747-7171},
doi = {https://doi.org/10.1016/S0747-7171(89)80065-3},
url = {https://www.sciencedirect.com/science/article/pii/S0747717189800653},
author = {Tatsuya Hagino},
abstract = {A new data type declaration mechanism of defining codatatypes is introduced to a functional programming language ML. Codatatypes are dual to datatypes for which ML already has a mechanism of defining. Sums and finite lists are defined as datatypes, but their duals, products and infinite lists, could not be defined in ML. This new facility gives ML the missing half of data types and makes ML symmetric. Categorical and domain-theoretic characterization of codatatypes are also given.}
}

@inproceedings{downen19:codata,
  title={Codata in action},
  author={Downen, Paul and Sullivan, Zachary and Ariola, Zena M and Peyton Jones, Simon},
  booktitle={European Symposium on Programming},
  pages={119--146},
  year={2019},
  organization={Springer International Publishing Cham},
  url={https://www.microsoft.com/en-us/research/uploads/prod/2020/01/CoDataInAction.pdf}
}

@techreport {sullivan19:exploring-codata,
   type = {Directed Research Project},
   author = {Zachary Sullivan},
   title = {Exploring Codata: The Relation to Object-Orientation},
   institution = {University of Oregon, Computer and Information Sciences Department},
   number = {DRP-201905-Sullivan},
   month = 5,
   year = 2019,
   url={https://www.cs.uoregon.edu/Reports/DRP-201905-Sullivan.pdf}
}

@inproceedings{wadler98:odd,
  title={How to add laziness to a strict language without even being odd},
  author={Wadler, Philiip and Taha, Walid and MacQueen, David},
  booktitle={SML'98, The SML workshop},
  year={1998},
  url={https://www.diva-portal.org/smash/get/diva2:413532/FULLTEXT01.pdf}
}

@article{downen21:classical,
  author       = {Paul Downen and Zena M. Ariola},
  title        = {Classical (Co)Recursion: Programming},
  journal      = {CoRR},
  volume       = {abs/2103.06913},
  year         = {2021},
  url          = {https://arxiv.org/abs/2103.06913},
  eprinttype    = {arXiv},
  eprint       = {2103.06913},
  timestamp    = {Thu, 14 Oct 2021 09:14:34 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2103-06913.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@unpublished{kiselyov05:beyond,
  author       = {Oleg Kiselyov},
  title           = {Beyond Church encoding: Boehm-Berarducci isomorphism of algebraic data types and polymorphic lambda-terms},
  year            = 2005,
  url          = {https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html}}

@inproceedings{reynolds72:definitional,
author = {Reynolds, John C.},
title = {Definitional interpreters for higher-order programming languages},
year = {1972},
isbn = {9781450374927},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800194.805852},
doi = {10.1145/800194.805852},
abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
booktitle = {Proceedings of the ACM Annual Conference - Volume 2},
pages = {717–740},
numpages = {24},
keywords = {Applicative language, Closure, Continuation, GEDANKEN, Higher-order function, Interpreter, J-operator, LISP, Lambda calculus, Language definition, Order of application, PAL, Programming language, Reference, SECD machine},
location = {Boston, Massachusetts, USA},
series = {ACM '72}
}

@inproceedings{danvy01:defunctionalization,
author = {Danvy, Olivier and Nielsen, Lasse R.},
title = {Defunctionalization at work},
year = {2001},
isbn = {158113388X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/773184.773202},
doi = {10.1145/773184.773202},
abstract = {Reynolds's defunctionalization technique is a whole-program transformation from higher-order to first-order functional programs. We study practical applications of this transformation and uncover new connections between seemingly unrelated higher-order and first-order specifications and between their correctness proofs. Defunctionalization therefore appearsboth as a springboard for rev ealing new connections and as a bridge for transferring existing results between the first-order world and the higher-order world.},
booktitle = {Proceedings of the 3rd ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
pages = {162–174},
numpages = {13},
keywords = {syntactic theories, supercombinator conversion, regular expressions, lambda-lifting, higher-order programs, first-order programs, direct-style transformation, defunctionalization, continuations, continuation-passing style (CPS), closure conversion, church encoding, Scheme, ML, CPS transformation},
location = {Florence, Italy},
series = {PPDP '01}
}

@Article{gibbons22:cps,
  author          = {Jeremy Gibbons},
  title           = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  journaltitle    = {The Art, Science, and Engineering of Programming},
  year            = 2022,
  volume       = 6,
  number       = 7,
  issue        = 2,
  doi          = {https://doi.org/10.22152/programming-journal.org/2022/6/7}}



@Article{boden09:generative,
  author          = {Boden, Margaret A. and Edmonds, Ernest A.},
  title           = {What is generative art?},
  journaltitle    = {Digital Creativity},
  year            = 2009,
  series       = 20,
  volume       = {1-2},
  pages        = {21-46},
  doi = {10.1080/14626260902867915}
}

@Article{dorin12:generative,
  author          = {Alan Dorin and Jonathan McCabe and Jon McCormack and Gordon Monro and Mitchell Whitelaw},
  title           = {A framework for understanding generative art},
  journaltitle    = {Digital Creativity},
  year            = 2012,
  series       = 23,
  volume       = {3-4},
  pages        = {239-259},
  doi = {10.1080/14626268.2012.709940}
}

@inproceedings{leijen00:dsec,
author = {Leijen, Daan and Meijer, Erik},
title = {Domain specific embedded compilers},
year = {2000},
isbn = {1581132557},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/331960.331977},
doi = {10.1145/331960.331977},
abstract = {Domain-specific embedded languages (DSELs) expressed in higher-order, typed (HOT) languages provide a composable framework for domain-specific abstractions. Such a framework is of greater utility than a collection of stand-alone domain-specific languages. Usually, embedded domain specific languages are build on top of a set of domain specific primitive functions that are ultimately implemented using some form of foreign function call. We sketch a general design pattern/or embedding client-server style services into Haskell using a domain specific embedded compiler for the server's source language. In particular we apply this idea to implement Haskell/DB, a domain specific embdedded compiler that dynamically generates of SQL queries from monad comprehensions, which are then executed on an arbitrary ODBC database server.},
booktitle = {Proceedings of the 2nd Conference on Domain-Specific Languages},
pages = {109–122},
numpages = {14},
location = {Austin, Texas, USA},
series = {DSL '99}
}

@TechReport{cheney03:first-class,
  author          = {Cheney, James and Hinze, Ralf},
  title           = {First-class Phantom Types},
  institution     = {Cornell University},
  date            = 2003,
  url          = {https://ecommons.cornell.edu/server/api/core/bitstreams/6cf38000-1bc3-4572-b71f-9ddb06f3565c/content}}

@inproceedings{hongwei03:grdc,
author = {Xi, Hongwei and Chen, Chiyan and Chen, Gang},
title = {Guarded recursive datatype constructors},
year = {2003},
isbn = {1581136285},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/604131.604150},
doi = {10.1145/604131.604150},
booktitle = {Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {224–235},
numpages = {12},
keywords = {guarded recursive datatype constructors},
location = {New Orleans, Louisiana, USA},
series = {POPL '03}
}

@article{sheard08:type-equality,
  title = {Meta-programming With Built-in Type Equality},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {199},
  pages = {49-65},
  year = {2008},
  note = {Proceedings of the Fourth International Workshop on Logical Frameworks and Meta-Languages (LFM 2004)},
  issn = {1571-0661},
  doi = {https://doi.org/10.1016/j.entcs.2007.11.012},
  url = {https://www.sciencedirect.com/science/article/pii/S1571066108000789},
  author = {Tim Sheard and Emir Pasalic},
}
@article{peyton-jones06:gadts,
  author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},
  title = {Simple unification-based type inference for GADTs},
  year = 2006,
  issue_date = {September 2006},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = 41,
  number = 9,
  issn = {0362-1340},
  url = {https://doi.org/10.1145/1160074.1159811},
  doi = {10.1145/1160074.1159811},
  journal = {SIGPLAN Not.},
  month = sep,
  pages = {50–61},
  numpages = 12
}

@inproceedings{lin10:pointwise,
  author = {Lin, Chuan-kai and Sheard, Tim},
  title = {Pointwise generalized algebraic data types},
  year = {2010},
  isbn = {9781605588919},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1708016.1708024},
  doi = {10.1145/1708016.1708024},
  abstract = {In the GADT (Generalized Algebraic Data Types) type system, a pattern-matching branch can draw type information from both the scrutinee type and the data constructor type. Even though the type system can handle complex interactions between the two types, most programs require only simple interactions in the form of parametric instantiation and type indexing.To explore the tradeoffs related to GADT patterns, we define the Pointwise GADT type system, which restricts GADTs to the common case of parametric instantiation and type indexing. The Pointwise GADT type system still accepts a wide range of GADT programs, while rejecting a pathological function whose pattern-matching branches can make arbitrarily different assumptions about the type environment. We also state and prove several properties of the type system, which we speculate might be useful in helping researchers design better type inference algorithms.},
  booktitle = {Proceedings of the 5th ACM SIGPLAN Workshop on Types in Language Design and Implementation},
  pages = {51–62},
  numpages = {12},
  keywords = {gadts, pointwise baseline, pointwise unification, pointwise unifier},
  location = {Madrid, Spain},
  series = {TLDI '10}
}

@article{roth23:fluent,
   title={Fluent APIs in Functional Languages},
   volume={7},
   ISSN={2475-1421},
   url={http://dx.doi.org/10.1145/3586057},
   DOI={10.1145/3586057},
   number={OOPSLA1},
   journal={Proceedings of the ACM on Programming Languages},
   publisher={Association for Computing Machinery (ACM)},
   author={Roth, Ori and Gil, Yossi},
   year={2023},
   month=apr, pages={876–901} }

@inproceedings{thibodeau16:indexed-codata,
author = {Thibodeau, David and Cave, Andrew and Pientka, Brigitte},
title = {Indexed codata types},
year = {2016},
isbn = {9781450342193},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2951913.2951929},
doi = {10.1145/2951913.2951929},
abstract = {Indexed data types allow us to specify and verify many interesting invariants about finite data in a general purpose programming language. In this paper we investigate the dual idea: indexed codata types, which allow us to describe data-dependencies about infinite data structures. Unlike finite data which is defined by constructors, we define infinite data by observations. Dual to pattern matching on indexed data which may refine the type indices, we define copattern matching on indexed codata where type indices guard observations we can make.  Our key technical contributions are three-fold: first, we extend Levy's call-by-push value language with support for indexed (co)data and deep (co)pattern matching; second, we provide a clean foundation for dependent (co)pattern matching using equality constraints; third, we describe a small-step semantics using a continuation-based abstract machine, define coverage for indexed (co)patterns, and prove type safety. This is an important step towards building a foundation where (co)data type definitions and dependent types can coexist.},
booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
pages = {351–363},
numpages = {13},
keywords = {Logical frameworks, Functional programming, Dependent types, Coinduction},
location = {Nara, Japan},
series = {ICFP 2016}
}

@article{10.1145/3022670.2951929,
author = {Thibodeau, David and Cave, Andrew and Pientka, Brigitte},
title = {Indexed codata types},
year = {2016},
issue_date = {September 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/3022670.2951929},
doi = {10.1145/3022670.2951929},
abstract = {Indexed data types allow us to specify and verify many interesting invariants about finite data in a general purpose programming language. In this paper we investigate the dual idea: indexed codata types, which allow us to describe data-dependencies about infinite data structures. Unlike finite data which is defined by constructors, we define infinite data by observations. Dual to pattern matching on indexed data which may refine the type indices, we define copattern matching on indexed codata where type indices guard observations we can make.  Our key technical contributions are three-fold: first, we extend Levy's call-by-push value language with support for indexed (co)data and deep (co)pattern matching; second, we provide a clean foundation for dependent (co)pattern matching using equality constraints; third, we describe a small-step semantics using a continuation-based abstract machine, define coverage for indexed (co)patterns, and prove type safety. This is an important step towards building a foundation where (co)data type definitions and dependent types can coexist.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {351–363},
numpages = {13},
keywords = {Logical frameworks, Functional programming, Dependent types, Coinduction}
}

@InProceedings{ostermann18:matrix,
  author="Ostermann, Klaus and Jabs, Julian",
  editor="Ahmed, Amal",
  title="Dualizing Generalized Algebraic Data Types by Matrix Transposition",
  booktitle="Programming Languages and Systems",
  year="2018",
  publisher="Springer International Publishing",
  address="Cham",
  pages="60--85",
  isbn="978-3-319-89884-1"
}

@Unpublished{zhang22:decomposition,
  author          = {Weixin Zhang and Cristina David and Meng Wang},
  title           = {Decomposition without regret},
  year            = 2022,
  url          = {https://arxiv.org/abs/2204.10411}}

@Misc{wadler98:ep,
  author       = {Phil Wadler},
  title           = {The Expression Problem},
  date            = 1998,
  month           = {November},
  howpublished = {Email to the Java Genericity mailing list},
  url          = {https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt}}

@inproceedings{cook90:oo-adt,
  author          = {William Cook},
  title           = {Object-Oriented Programming Versus Abstract Data Types},
  date            = 1990,
  booktitle       = {Proceedings of the REX Workshop/School on the Foundations of Object-Oriented Languages (FOOL)},
  series       = {LNCS},
  volume       = 489,
  publisher    = {Springer-Verlag},
  pages        = {151--178},
  url          = {https://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf}}


@Article{jacques09:finally-tagless,
  author          = {Jacques Carette and Oleg Kiselyov and Chung-chieh Shan},
  title           = {Finally Tagless, Partially Evaluated: Tagless Staged Interpreters for Simpler Typed Languages},
  journaltitle    = {Journal of Functional Programming},
  year            = 2009,
  series       = 19,
  volume       = 5,
  pages        = {509--543},
  url          = {https://okmij.org/ftp/tagless-final/JFP.pdf}}


@InBook{kiselyov12:tagless-final,
  author          = {Oleg Kiselyov},
  title           = {Typed Tagless Final Interpreters},
  editor="Gibbons, Jeremy",
  bookTitle="Generic and Indexed Programming: International Spring School, SSGIP 2010, Oxford, UK, March 22-26, 2010, Revised Lectures",
  year=2012,
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="130--174",
  isbn="978-3-642-32202-0",
  doi="10.1007/978-3-642-32202-0_3",
  url          = {https://okmij.org/ftp/tagless-final/course/lecture.pdf}}

@inproceedings{oliveira12:object-algebras,
  author = {Oliveira, Bruno C. d. S. and Cook, William R.},
  title = {Extensibility for the masses: practical extensibility with object algebras},
  year = {2012},
  isbn = {9783642310560},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  url = {https://doi.org/10.1007/978-3-642-31057-7_2},
  doi = {10.1007/978-3-642-31057-7_2},
  abstract = {This paper presents a new solution to the expression problem (EP) that works in OO languages with simple generics (including Java or C#). A key novelty of this solution is that advanced typing features, including F-bounded quantification, wildcards and variance annotations, are not needed. The solution is based on object algebras, which are an abstraction closely related to algebraic datatypes and Church encodings. Object algebras also have much in common with the traditional forms of the Visitor pattern, but without many of its drawbacks: they are extensible, remove the need for accept methods, and do not compromise encapsulation. We show applications of object algebras that go beyond toy examples usually presented in solutions for the expression problem. In the paper we develop an increasingly more complex set of features for a mini-imperative language, and we discuss a real-world application of object algebras in an implementation of remote batches. We believe that object algebras bring extensibility to the masses: object algebras work in mainstream OO languages, and they significantly reduce the conceptual overhead by using only features that are used by everyday programmers.},
  booktitle = {Proceedings of the 26th European Conference on Object-Oriented Programming},
  pages = {2–27},
  numpages = {26},
  location = {Beijing, China},
  series = {ECOOP'12}
}

@article{swierstra08:data-types,
  title={Data types à la carte},
  volume={18},
  DOI={10.1017/S0956796808006758},
  number={4},
  journal={Journal of Functional Programming},
  author={Swierstra, Wouter},
  year={2008},
  pages={423–436},
  url={https://www.cambridge.org/core/journals/journal-of-functional-programming/article/data-types-a-la-carte/14416CB20C4637164EA9F77097909409}
}
@inproceedings{10.1145/2628136.2628138,
author = {Gibbons, Jeremy and Wu, Nicolas},
title = {Folding domain-specific languages: deep and shallow embeddings (functional Pearl)},
year = {2014},
isbn = {9781450328739},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2628136.2628138},
doi = {10.1145/2628136.2628138},
abstract = {A domain-specific language can be implemented by embedding within a general-purpose host language. This embedding may be deep or shallow, depending on whether terms in the language construct syntactic or semantic representations. The deep and shallow styles are closely related, and intimately connected to folds; in this paper, we explore that connection.},
booktitle = {Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming},
pages = {339–347},
numpages = {9},
keywords = {folds, domain-specific languages, deep and shallow embedding},
location = {Gothenburg, Sweden},
series = {ICFP '14}
}

@article{gibbons14:folding,
  author = {Gibbons, Jeremy and Wu, Nicolas},
  title = {Folding domain-specific languages: deep and shallow embeddings (functional Pearl)},
  year = {2014},
  issue_date = {September 2014},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {49},
  number = {9},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/2692915.2628138},
  doi = {10.1145/2692915.2628138},
  abstract = {A domain-specific language can be implemented by embedding within a general-purpose host language. This embedding may be deep or shallow, depending on whether terms in the language construct syntactic or semantic representations. The deep and shallow styles are closely related, and intimately connected to folds; in this paper, we explore that connection.},
  journal = {SIGPLAN Not.},
  month = aug,
  pages = {339–347},
  numpages = {9},
  keywords = {folds, domain-specific languages, deep and shallow embedding}
}


@inproceedings{scibior15:monads,
author = {Scibior, Adam and Ghahramani, Zoubin and Gordon, Andrew D.},
title = {Practical probabilistic programming with monads},
year = {2015},
isbn = {9781450338080},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2804302.2804317},
doi = {10.1145/2804302.2804317},
booktitle = {Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell},
pages = {165–176},
numpages = {12},
keywords = {probabilistic programming, monads, Monte Carlo, Haskell, Bayesian statistics},
location = {Vancouver, BC, Canada},
series = {Haskell '15}
}


@Unpublished{kidd07:prob,
  author          = {Kidd, Eric},
  title           = {Build your own probability monads},
  date            = 2007,
  url          = {https://www.randomhacks.net/files/build-your-own-probability-monads.pdf}
}

@article{erwig06:pfp,
 title={FUNCTIONAL PEARLS: Probabilistic functional programming in Haskell},
 volume={16},
 DOI={10.1017/S0956796805005721},
 number={1},
 journal={Journal of Functional Programming},
 author={Erwig, Martin and Kollmansberger, Steve},
 year={2006},
 pages={21–34}
}

@article{scibor18:modular,
author = {Scibior, Adam and Kammar, Ohad and Ghahramani, Zoubin},
title = {Functional programming for modular Bayesian inference},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236778},
doi = {10.1145/3236778},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {83},
numpages = {29},
}

@inproceedings{claessen00:quickcheck,
  author = {Claessen, Koen and Hughes, John},
  title = {QuickCheck: a lightweight tool for random testing of Haskell programs},
  year = {2000},
  isbn = {1581132026},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/351240.351266},
  doi = {10.1145/351240.351266},
  booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
  pages = {268–279},
  numpages = {12},
  series = {ICFP '00}
}

@inproceedings{runciman09:smallcheck,
  author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
  title = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small values},
  year = {2008},
  isbn = {9781605580647},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1411286.1411292},
  doi = {10.1145/1411286.1411292},
  booktitle = {Proceedings of the First ACM SIGPLAN Symposium on Haskell},
  pages = {37–48},
  numpages = {12},
  location = {Victoria, BC, Canada},
  series = {Haskell '08}
}

@article{duregard12:feat,
author = {Dureg\r{a}rd, Jonas and Jansson, Patrik and Wang, Meng},
title = {Feat: functional enumeration of algebraic types},
year = {2012},
issue_date = {December 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/2430532.2364515},
doi = {10.1145/2430532.2364515},
abstract = {In mathematics, an enumeration of a set S is a bijective function from (an initial segment of) the natural numbers to S. We define "functional enumerations" as efficiently computable such bijections. This paper describes a theory of functional enumeration and provides an algebra of enumerations closed under sums, products, guarded recursion and bijections. We partition each enumerated set into numbered, finite subsets.We provide a generic enumeration such that the number of each part corresponds to the size of its values (measured in the number of constructors). We implement our ideas in a Haskell library called testing-feat, and make the source code freely available. Feat provides efficient "random access" to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck). We claim that functional enumeration is the best option for automatically generating test cases from large groups of mutually recursive syntax tree types. As a case study we use Feat to test the pretty-printer of the Template Haskell library (uncovering several bugs).},
journal = {SIGPLAN Not.},
month = sep,
pages = {61–72},
numpages = {12},
keywords = {enumeration, memoisation, property-based testing}
}

@inproceedings{goldstein24:practice,
  author = {Goldstein, Harrison and Cutler, Joseph W. and Dickstein, Daniel and Pierce, Benjamin C. and Head, Andrew},
  title = {Property-Based Testing in Practice},
  year = {2024},
  isbn = {9798400702174},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3597503.3639581},
  doi = {10.1145/3597503.3639581},
  booktitle = {Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
  articleno = {187},
  numpages = {13},
  location = {Lisbon, Portugal},
  series = {ICSE '24}
}

@inproceedings{reddy20:rlcheck,
  author={Reddy, Sameer and Lemieux, Caroline and Padhye, Rohan and Sen, Koushik},
  booktitle={2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)},
  title={Quickly Generating Diverse Valid Test Inputs with Reinforcement Learning},
  year={2020},
  volume={},
  number={},
  pages={1410-1421},
  url={https://ieeexplore.ieee.org/document/9284117}
}

@inproceedings{lemieux23:codamosa,
  author={Lemieux, Caroline and Inala, Jeevana Priya and Lahiri, Shuvendu K. and Sen, Siddhartha},
  booktitle={2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE)},
  title={CodaMosa: Escaping Coverage Plateaus in Test Generation with Pre-trained Large Language Models},
  year={2023},
  volume={},
  number={},
  pages={919-931},
  keywords={Software testing;Codes;Benchmark testing;Software;Space exploration;Test pattern generators;Software engineering;search based software testing;codex;test suite generation;python;large language model;automated testing},
  doi={10.1109/ICSE48619.2023.00085},
  url={https://www.carolemieux.com/codamosa_icse23.pdf}
}

@inproceedings{freeman06:jmock,
  author = {Freeman, Steve and Pryce, Nat},
  title = {Evolving an embedded domain-specific language in Java},
  year = {2006},
  isbn = {159593491X},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1176617.1176735},
  doi = {10.1145/1176617.1176735},
  booktitle = {Companion to the 21st ACM SIGPLAN Symposium on Object-Oriented Programming Systems, Languages, and Applications},
  pages = {855–865},
  numpages = {11},
  keywords = {mock objects, embedded domain-specific language, Java},
  location = {Portland, Oregon, USA},
  series = {OOPSLA '06}
}

@Misc{fowler05:fluent,
  author       = {Martin Fowler},
  title        = {Fluent Interface},
  date         = {2005-12-20},
  url          = {https://www.martinfowler.com/bliki/FluentInterface.html},
  urldate      = {2025-05-12}
  }

@inproceedings{dethlefs17:define,
  author = {Dethlefs, Nina and Hawick, Ken},
  title = {DEFIne: A Fluent Interface DSL for Deep Learning Applications},
  year = {2017},
  isbn = {9781450348454},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3039895.3039898},
  doi = {10.1145/3039895.3039898},
  abstract = {Recent years have seen a surge of interest in deep learning models that outperform other machine learning algorithms on benchmarks across many disciplines. Most existing deep learning libraries facilitate the development of neural nets by providing a mathematical framework that helps users implement their models more efficiently. This still represents a substantial investment of time and effort, however, when the intention is to compare a range of competing models quickly for a specific task. We present DEFIne, a fluent interface DSL for the specification, optimisation and evaluation of deep learning models. The fluent interface is implemented through method chaining. DEFIne is embedded in Python and is build on top of its most popular deep learning libraries, Keras and Theano. It extends these with common operations for data pre-processing and representation as well as visualisation of datasets and results. We test our framework on three benchmark tasks from different domains: heart disease diagnosis, hand-written digit recognition and weather forecast generation. Results in terms of accuracy, runtime and lines of code show that our DSL achieves equivalent accuracy and runtime to state-of-the-art models, while requiring only about 10 lines of code per application.},
  booktitle = {Proceedings of the 2nd International Workshop on Real World Domain Specific Languages},
  articleno = {3},
  numpages = {10},
  keywords = {deep learning, Domain-specific languages},
  location = {Austin, TX, USA},
  series = {RWDSL17}
}

@inproceedings{shrestha21:unravel,
  author = {Shrestha, Nischal and Barik, Titus and Parnin, Chris},
  title = {Unravel: A Fluent Code Explorer for Data Wrangling},
  year = {2021},
  isbn = {9781450386357},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3472749.3474744},
  doi = {10.1145/3472749.3474744},
  abstract = {Data scientists have adopted a popular design pattern in programming called the fluent interface for composing data wrangling code. The fluent interface works by combining multiple transformations on a data table—or dataframes—with a single chain of expressions, which produces an output. Although fluent code promotes legibility, the intermediate dataframes are lost, forcing data scientists to unravel the chain through tedious code edits and re-execution. Existing tools for data scientists do not allow easy exploration or support understanding of fluent code. To address this gap, we designed a tool called Unravel that enables structural edits via drag-and-drop and toggle switch interactions to help data scientists explore and understand fluent code. Data scientists can apply simple structural edits via drag-and-drop and toggle switch interactions to reorder and (un)comment lines. To help data scientists understand fluent code, Unravel provides function summaries and always-on visualizations highlighting important changes to a dataframe. We discuss the design motivations behind Unravel and how it helps understand and explore fluent code. In a first-use study with 14 data scientists, we found that Unravel facilitated diverse activities such as validating assumptions about the code or data, exploring alternatives, and revealing function behavior.},
  booktitle = {The 34th Annual ACM Symposium on User Interface Software and Technology},
  pages = {198–207},
  numpages = {10},
  keywords = {data science, data wrangling, programming},
  location = {Virtual Event, USA},
  series = {UIST '21}
}

@inproceedings{hawick13:fluent,
  author = {K. A. Hawick},
  title = {Fluent Interfaces and Domain-Specific Languages for Graph Generation
  and Network Analysis Calculations},
  booktitle = {Proc. Int. Conf. on Software Engineering (SE’13)},
  year = {2013},
  pages = {752-759},
  address = {Innsbruck, Austria},
  month = {11-13 February},
  publisher = {IASTED},
  institution = {Computer Science, Massey University},
  timestamp = {2012.12.01}
}

@InProceedings{gil19:fling,
  author =  {Gil, Yossi and Roth, Ori},
  title =   {{Fling - A Fluent API Generator}},
  booktitle =   {33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
  pages =   {13:1--13:25},
  series =  {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =  {978-3-95977-111-5},
  ISSN =  {1868-8969},
  year =  2019,
  volume =  134,
  editor =  {Donaldson, Alastair F.},
  publisher =   {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =   {Dagstuhl, Germany},
  URL =     {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2019.13},
  URN =     {urn:nbn:de:0030-drops-108053},
  doi =     {10.4230/LIPIcs.ECOOP.2019.13},
  annote =  {Keywords: fluent API, type system, compilation, code generation}
}


@inproceedings{10.1145/3136040.3136041,
author = {Nakamaru, Tomoki and Ichikawa, Kazuhiro and Yamazaki, Tetsuro and Chiba, Shigeru},
title = {Silverchain: a fluent API generator},
year = {2017},
isbn = {9781450355247},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3136040.3136041},
doi = {10.1145/3136040.3136041},
abstract = {This paper presents a tool named Silverchain, which generates class definitions for a fluent API from the grammar of the API. A fluent API is an API that is used by method chaining and its grammar is a BNF-like set of rules that defines method chains accepted in type checking. Fluent APIs generated by Silverchain provide two styles of APIs: One is for building a chain by concatenating all method calls in series. The other is for building a chain from partial chains by passing child chains to method calls in the parent chain as their arguments. To generate such a fluent API, Silverchain first translates given grammar into a set of deterministic pushdown automata without ϵ-transitions, then encodes these automata into class definitions. Each constructed automata corresponds to a nonterminal in given grammar and recognizes symbol sequences produced from its corresponding nonterminal.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences},
pages = {199–211},
numpages = {13},
keywords = {Fluent API, Embedded DSL},
location = {Vancouver, BC, Canada},
series = {GPCE 2017}
}

@article{nakamaru17:silverchain,
  author = {Nakamaru, Tomoki and Ichikawa, Kazuhiro and Yamazaki, Tetsuro and Chiba, Shigeru},
  title = {Silverchain: a fluent API generator},
  year = {2017},
  issue_date = {December 2017},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {52},
  number = {12},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/3170492.3136041},
  doi = {10.1145/3170492.3136041},
  abstract = {This paper presents a tool named Silverchain, which generates class definitions for a fluent API from the grammar of the API. A fluent API is an API that is used by method chaining and its grammar is a BNF-like set of rules that defines method chains accepted in type checking. Fluent APIs generated by Silverchain provide two styles of APIs: One is for building a chain by concatenating all method calls in series. The other is for building a chain from partial chains by passing child chains to method calls in the parent chain as their arguments. To generate such a fluent API, Silverchain first translates given grammar into a set of deterministic pushdown automata without ϵ-transitions, then encodes these automata into class definitions. Each constructed automata corresponds to a nonterminal in given grammar and recognizes symbol sequences produced from its corresponding nonterminal.},
  journal = {SIGPLAN Not.},
  month = oct,
  pages = {199–211},
  numpages = {13},
  keywords = {Fluent API, Embedded DSL}
}

@MastersThesis{levy16:fluent,
  author          = {Tomer Levy},
  title           = {A Fluent API for Automatic Generation of FLuent APIs in Java},
  institution     = {Technion},
  year            = 2016
}

@inproceedings{vukovic23:dsl,
  author={Vuković, Milica and Vujović, Vladimir and Štaka, Zorana and Milinković, Snježana},
  booktitle={2023 15th International Conference on Electronics, Computers and Artificial Intelligence (ECAI)},
  title={Domain-Specific Language for Modeling Fluent API},
  year={2023},
  volume={},
  number={},
  pages={1-6},
  keywords={Computers;Visualization;Codes;Computational modeling;Manuals;Skeleton;Encoding;Fluent API;Domain Specific Language;DSL Tools;Model-Driven Engineering;code generation},
  doi={10.1109/ECAI58194.2023.10194083}}

@inproceedings{nakamaru20:empirical,
author = {Nakamaru, Tomoki and Matsunaga, Tomomasa and Yamazaki, Tetsuro and Akiyama, Soramichi and Chiba, Shigeru},
title = {An Empirical Study of Method Chaining in Java},
year = {2020},
isbn = {9781450375177},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3379597.3387441},
doi = {10.1145/3379597.3387441},
abstract = {While some promote method chaining as a good practice for improving code readability, others refer to it as a bad practice that worsens code quality. In this paper, we first investigate whether method chaining is a programming style accepted by real-world programmers. To answer this question, we collected 2,814 Java repositories on GitHub and analyzed historical trends in the frequency of method chaining. The results of our analysis revealed the increasing use of method chaining; 23.1\% of method invocations were part of method chains in 2018, whereas only 16.0\% were such invocations in 2010. We then explore language features that are helpful to the method-chaining style but have not been supported yet in Java. For this aim, we conducted manual inspections of method chains that are randomly sampled from the collected repositories. We also estimated how effective they are to encourage the method-chaining style if they are adopted in Java.},
booktitle = {Proceedings of the 17th International Conference on Mining Software Repositories},
pages = {93–102},
numpages = {10},
keywords = {Method chaining, Quantitative analysis, Repository mining},
location = {Seoul, Republic of Korea},
series = {MSR '20}
}

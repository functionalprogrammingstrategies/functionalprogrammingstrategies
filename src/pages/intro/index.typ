#import "../stdlib.typ": chapter, narrative-cite
#chapter[Functional Programming Strategies] <sec:fps>


This is a book on strategies for creating code in a functional programming (FP) style, seen through a Scala lens. 
If you understand most of the mechanics of Scala, but feel there is something missing in your understanding of how to use the language effectively, this book is for you.
If you want to learn about functional programming, and are prepared to learn some Scala, this book is also for you.
It covers the usual functional programming abstractions like monads and monoids, but more than that it tries to teach you how to think like a functional programmer.
It's a book as much about process as it is about the code that results from process, and in particular it focuses on what I call metacognitive programming strategies.

Functional programmers love fancy words for simple ideas, so it's no surprise I'm drawn to metacognitive programming strategies. Let's unpack that phrase. Metacognition means thinking about thinking. A lot of research has shown the benefits of metacognition in learning and its importance in developing expertise (see, for example, @conley14:strategies @macintyre14:metacognition @pintrich02:metacognitive). Metacognition is not just one thing---it's not sufficient to just tell someone to think about their thinking. Rather, metacognition is a collection of different strategies, some of which are general and some of which are domain specific. From this we get the idea of metacognitive programming strategies---explicitly naming and describing different thinking strategies that proficient programmers use.

Let's think a little about metacognitive strategies you might already use when coding.
My experience is that most developers struggle to answer this.
Software teams usually have many well-defined processes _around_ coding, such as daily stand-ups and kanban boards.
Developers have a huge amount of language specific knowledge.
However, the part inbetween deciding what should be done and working code is often very fuzzy.
When developers can answer this question they often mention test driven development and pair programming, and design patterns such as the builder pattern.
These date from the nineties, the former from _Extreme Programming_ @beck99:xp and the latter from the _Design Patterns_ book @gamma94:design-patterns.
In my experience they are used quite informally, if at all.

The question then becomes: what metacognitive strategies can programmers use? I believe that functional programming is particularly well suited to answer this question. One major theme in functional programming research is finding and naming useful code structures. Once we have discovered a useful abstraction we can get the programmer to ask themselves "would this abstraction solve this problem?" This is essentially what the design patterns community did but there is an important difference. The academic FP community strongly values formal models, which means that the building blocks of FP have a precision that design patterns lack. However there is more to strategies than categorizing their output. There is also the actual process of how the code comes to be. Code doesn't usually spring fully formed from our keyboard, and in the iterative refinement of code we also find structure. Here the academic FP community has explored various algorithms for deriving code. As working programmers we must usually execute these algorithms by hand, but the benefit still remains.

I believe metacognitive programming strategies are useful for both beginners and experts. For beginners we can make programming a more systematic and repeatable process. Producing code no longer requires magic in the majority of cases, but rather the application of well defined steps. For experts, the benefit is exactly the same. At least that is my experience (and I believe I've been programming long enough to call myself an expert.) By having an explicit process I can run it exactly the same way every day, which makes my code simpler to write and read, and saves my brain cycles for more important problems. In some ways this is an attempt to bring to programming the benefit that process and standardization has brought to manufacturing, particularly the "Toyota Way". In Toyota's process individuals are expected to think about how their work is done and how it can be improved. This is, in effect, metacognition for assembly lines. This is only possible if the actual work itself does not require their full attention. The dramatic improvements in productivity and quality in car manufacturing that Toyota pioneered speak to the effectiveness of this approach. Software development is more varied than car manufacturing but we should still expect some benefit, particularly given the primitive state of our current industry.

Over the last ten or so years of programming and teaching programming I've collected a wide range of strategies. Some come from others (for example, #narrative-cite(<felleisen18:htdp>) and its many offshoots remain very influential for me) and some I've found myself. Ultimately I don't think anything here is new; rather my contribution is in collecting and presenting these strategies as one coherent whole, in a way that I hope is accessible to the working programmer.

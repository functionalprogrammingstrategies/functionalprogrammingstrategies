<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Functional Programming Strategies</title>
    <meta name="authors" content="Noel Welsh">
  </head>
  <body>
    <p>This book is dedicated to those who laid the path that I have followed, to those who will take up where I have left off, and to those who have joined me along the way.</p>
    <nav role="doc-toc">
      <h2>Contents</h2>
      <ol style="list-style-type: none">
        <li>
          <div><a href="#loc-1"><div>Preface<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-3"><div>Preface from Scala with Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
            <li>
              <div><a href="#loc-5"><div>Versions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-7"><div>Template Projects<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-8"><div>Conventions Used in This Book<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-9"><div>Typographical Conventions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
                <li><a href="#loc-12"><div>Source Code<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
                <li><a href="#loc-14"><div>Callout Boxes<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
              </ol>
            </li>
            <li><a href="#loc-15"><div>License<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-18"><div><p></p><p>Functional Programming Strategies<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-23"><div><p></p><p>Three Levels for Thinking About Code<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-24"><div><p></p><p>Functional Programming<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-25"><div><p></p><p>What Functional Programming Is<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-27"><div><p></p><p>What Functional Programming Isn’t<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-30"><div><p></p><p>Why It Matters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-31"><div><p></p><p>The Evidence for Functional Programming<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-34"><div><p></p><p>Final Words<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#loc-35">Part I: Foundations<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> 1</a></li>
        <li>
          <div><a href="#loc-36"><div><p></p><p>Types as Constraints<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-37"><div><p></p><p>Sets and Constraints<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-38"><div><p></p><p>Building Constraints<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-40"><div><p></p><p>Opaque Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-42"><div><p></p><p>Best Practices<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-43"><div><p></p><p>Beyond Opaque Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-45"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-51"><div><p></p><p>Algebraic Data Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-52"><div><p></p><p>Building Algebraic Data Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-53"><div><p></p><p>Sums and Products<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-54"><div><p></p><p>Closed Worlds<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-55"><div><p></p><p>Algebraic Data Types in Scala<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-56"><div><p></p><p>Algebraic Data Types in Scala 3<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-57"><div><p></p><p>Algebraic Data Types in Scala 2<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-58"><div><p></p><p>Examples<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-59"><div><p></p><p>Representing ADTs in Scala 3<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-60"><div><p></p><p>Structural Recursion<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-61"><div><p></p><p>Pattern Matching<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-62"><div><p></p><p>The Recursion in Structural Recursion<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-63"><div><p></p><p>Exhaustivity Checking<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-64"><div><p></p><p>Dynamic Dispatch<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-65"><div><p></p><p>Folds as Structural Recursions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-66"><div><p></p><p>Structural Corecursion<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-67"><div><p></p><p>Unfolds as Structural Corecursion<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-68"><div><p></p><p>The Algebra of Algebraic Data Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-69"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-77"><div><p></p><p>Objects as Codata<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-78"><div><p></p><p>Data and Codata<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-80"><div><p></p><p>Codata in Scala<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-81"><div><p></p><p>Structural Recursion and Corecursion for Codata<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-83"><div><p></p><p>Efficiency and Effects<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-84"><div><p></p><p>Relating Data and Codata<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-85"><div><p></p><p>Data and Codata Extensibility<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-86"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-93"><div><p></p><p>Contextual Abstraction<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-95"><div><p></p><p>The Mechanics of Contextual Abstraction<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-96"><div><p></p><p>Using Clauses<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-97"><div><p></p><p>Given Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-98"><div><p></p><p>Given Scope and Imports<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-99"><div><p></p><p>Anatomy of a Type Class<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-100"><div><p></p><p>The Type Class<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-101"><div><p></p><p>Type Class Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-102"><div><p></p><p>Type Class Use<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-104"><div><p></p><p>Type Class Composition<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-105"><div><p></p><p>Type Class Composition in Scala 2<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-106"><div><p></p><p>What Type Classes Are<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-108"><div><p></p><p>Exercise: Display Library<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-109"><div><p></p><p>Using the Library<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-110"><div><p></p><p>Better Syntax<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-111"><div><p></p><p>Type Classes and Variance<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-112"><div><p></p><p>Variance<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-113"><div><p></p><p>Covariance<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-114"><div><p></p><p>Contravariance<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-115"><div><p></p><p>Invariance<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-116"><div><p></p><p>Variance and Instance Selection<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-117"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-126"><div><p></p><p>Reified Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-128"><div><p></p><p>Regular Expressions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-130"><div><p></p><p>Interpreters and Reification<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-131"><div><p></p><p>The Structure of Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-132"><div><p></p><p>Implementing Interpreters with Reification<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-133"><div><p></p><p>Tail Recursive Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-134"><div><p></p><p>The Problem of Stack Safety<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-135"><div><p></p><p>Tail Calls and Tail Position<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-137"><div><p></p><p>Continuation-Passing Style<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-138"><div><p></p><p>Trampolining<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-139"><div><p></p><p>When Tail Recursion is Easy<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-140"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li><a href="#loc-145">Part II: Type Classes<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> 1</a></li>
        <li>
          <div><a href="#loc-147"><div><p></p><p>Using Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-149"><div><p></p><p>Quick Start<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-150"><div><p></p><p>Using Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-152"><div><p></p><p>Defining Custom Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-153"><div><p></p><p>Example: Eq<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-156"><div><p></p><p>Equality, Liberty, and Fraternity<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-158"><div><p></p><p>Comparing Ints<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-159"><div><p></p><p>Comparing Options<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-161"><div><p></p><p>Comparing Custom Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-162"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-163"><div><p></p><p>Monoids and Semigroups<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-164"><div><p></p><p>Definition of a Monoid<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-165"><div><p></p><p>Definition of a Semigroup<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-168"><div><p></p><p>Monoids in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-169"><div><p></p><p>The Monoid Type Class<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-179"><div><p></p><p>Monoid Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-180"><div><p></p><p>Monoid Syntax<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-182"><div><p></p><p>Applications of Monoids<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-183"><div><p></p><p>Big Data<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-184"><div><p></p><p>Distributed Systems<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-185"><div><p></p><p>Monoids in the Small<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-186"><div><p></p><p>Summary<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-187"><div><p></p><p>Functors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-188"><div><p></p><p>Examples of Functors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-190"><div><p></p><p>More Examples of Functors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-191"><div><p></p><p>Futures<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-194"><div><p></p><p>Functions (?!)<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-196"><div><p></p><p>Definition of a Functor<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-199"><div><p></p><p>Higher Kinds and Type Constructors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-200"><div><p></p><p>Functors in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-201"><div><p></p><p>The Functor Type Class and Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-203"><div><p></p><p>Functor Syntax<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-204"><div><p></p><p>Instances for Custom Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-206"><div><p></p><p>Contravariant and Invariant Functors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-207"><div><p></p><p>Contravariant Functors and the <strong>contramap</strong> Method<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-209"><div><p></p><p>Invariant functors and the <strong>imap</strong> method<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-214"><div><p></p><p>Contravariant and Invariant in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-217"><div><p></p><p>Contravariant in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-219"><div><p></p><p>Invariant in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-221"><div><p></p><p>Aside: Partial Unification<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-223"><div><p></p><p>Limitations of Partial Unification<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-226"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-228"><div><p></p><p>Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-229"><div><p></p><p>What is a Monad?<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-230"><div><p></p><p>Options as Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-232"><div><p></p><p>Lists as Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-235"><div><p></p><p>Futures as Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-237"><div><p></p><p>Definition of a Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-239"><div><p></p><p>Exercise: Getting Func-y<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-240"><div><p></p><p>Monads in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#monad-type-class"><div><p></p><p>The Monad Type Class<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-243"><div><p></p><p>Default Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-244"><div><p></p><p>Monad Syntax<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-248"><div><p></p><p>The Identity Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-249"><div><p></p><p>Exercise: Monadic Secret Identities<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-250"><div><p></p><p>Either<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-251"><div><p></p><p>Cats Utilities<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-252"><div><p></p><p>Aside: Error Handling and MonadError<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-253"><div><p></p><p>The MonadError Type Class<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-254"><div><p></p><p>Raising and Handling Errors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-259"><div><p></p><p>Instances of MonadError<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-260"><div><p></p><p>Exercise: Abstracting<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-261"><div><p></p><p>The Eval Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-262"><div><p></p><p>Eager, Lazy, Memoized, Oh My!<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-263"><div><p></p><p>Eval’s Models of Evaluation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-264"><div><p></p><p>Eval as a Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-265"><div><p></p><p>Trampolining and <strong>Eval.defer</strong><span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#writer-monad"><div><p></p><p>The Writer Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-266"><div><p></p><p>Creating and Unpacking Writers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-267"><div><p></p><p>Composing and Transforming Writers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-268"><div><p></p><p>The Reader Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-269"><div><p></p><p>Creating and Unpacking Readers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-270"><div><p></p><p>Composing Readers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-271"><div><p></p><p>When to Use Readers?<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-272"><div><p></p><p>The State Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-273"><div><p></p><p>Creating and Unpacking State<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-274"><div><p></p><p>Composing and Transforming State<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-275"><div><p></p><p>Defining Custom Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-277"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-279"><div><p></p><p>Monad Transformers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-281"><div><p></p><p>Composing Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-282"><div><p></p><p>A Transformative Example<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-283"><div><p></p><p>Monad Transformers in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-285"><div><p></p><p>The Monad Transformer Classes<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-286"><div><p></p><p>Building Monad Stacks<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-288"><div><p></p><p>Constructing and Unpacking Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-290"><div><p></p><p>Default Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-291"><div><p></p><p>Usage Patterns<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-294"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-295"><div><p></p><p>Semigroupal and Applicative<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-296"><div><p></p><p>Semigroupal<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-297"><div><p></p><p>Joining Two Contexts<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-298"><div><p></p><p>Joining Three or More Contexts<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-299"><div><p></p><p>Semigroupal Laws<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-300"><div><p></p><p>Semigroupal Syntax<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-302"><div><p></p><p>Fancy Functors and Apply Syntax<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-303"><div><p></p><p>Semigroupal Applied to Different Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-304"><div><p></p><p>Semigroupal Applied to List<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-305"><div><p></p><p>Semigroupal Applied to Either<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-306"><div><p></p><p>Semigroupal Applied to Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-307"><div><p></p><p>Parallel<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-308"><div><p></p><p>Apply and Applicative<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-309"><div><p></p><p>The Hierarchy of Sequencing Type Classes<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-311"><div><p></p><p>Summary<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-314"><div><p></p><p>Foldable and Traverse<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-315"><div><p></p><p>Foldable<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-316"><div><p></p><p>Folds and Folding<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-318"><div><p></p><p>Foldable in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-319"><div><p></p><p>Traverse<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-320"><div><p></p><p>Traversing with Futures<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-321"><div><p></p><p>Traversing with Applicatives<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-322"><div><p></p><p>Traverse in Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-323"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li><a href="#loc-325">Part III: Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> 1</a></li>
        <li>
          <div><a href="#loc-326"><div><p></p><p>Indexed Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-327"><div><p></p><p>Phantom Types<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-328"><div><p></p><p>Indexed Codata<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-329"><div><p></p><p>API Protocols<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-332"><div><p></p><p>Beyond Equality Constraints<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-333"><div><p></p><p>Indexed Data<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-334"><div><p></p><p>The Probability Monad<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-335"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-367"><div><p></p><p>Tagless Final Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-368"><div><p></p><p>Codata Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-369"><div><p></p><p>The Terminal<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-370"><div><p></p><p>Color Codes<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-371"><div><p></p><p>The Trouble with Escape Codes<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-372"><div><p></p><p>Programs and Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-373"><div><p></p><p>Composition and Reasoning<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-374"><div><p></p><p>Codata and Extensibility<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-375"><div><p></p><p>Tagless Final Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-376"><div><p></p><p>Algebraic User Interfaces<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-377"><div><p></p><p>A Better Encoding<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-378"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-386"><div><p></p><p>Optimizing Interpreters and Compilers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-387"><div><p></p><p>Algebraic Manipulation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-388"><div><p></p><p>From Continuations to Stacks<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-389"><div><p></p><p>Compilers and Virtual Machines<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-390"><div><p></p><p>Virtual and Abstract Machines<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-391"><div><p></p><p>Compilation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-392"><div><p></p><p>From Interpreter to Stack Machine<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-393"><div><p></p><p>Effectful Interpreters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-394"><div><p></p><p>Further Optimization<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-395"><div><p></p><p>Conclusions<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li><a href="#loc-412">Part IV: Case Studies<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> 1</a></li>
        <li><a href="#loc-413"><div><p></p><p>Creating Usable Code<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
        <li>
          <div><a href="#loc-414"><div><p></p><p>Case Study: Testing Asynchronous Code<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-415"><div><p></p><p>Abstracting over Type Constructors<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-416"><div><p></p><p>Abstracting over Monads<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-417"><div><p></p><p>Summary<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li><a href="#loc-418"><div><p></p><p>Error Handling<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
        <li>
          <div><a href="#loc-419"><div><p></p><p>Case Study: Map-Reduce<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-421"><div><p></p><p>Parallelizing <strong>map</strong> and <strong>fold</strong><span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-424"><div><p></p><p>Implementing <strong>foldMap</strong><span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-426"><div><p></p><p>Parallelising <strong>foldMap</strong><span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-429"><div><p></p><p><strong>Futures</strong>, Thread Pools, and ExecutionContexts<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-430"><div><p></p><p>Dividing Work<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-431"><div><p></p><p>Implementing <strong>parallelFoldMap</strong><span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-432"><div><p></p><p><strong>parallelFoldMap</strong> with more Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-433"><div><p></p><p>Summary<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-434"><div><p></p><p>Case Study: Data Validation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-435"><div><p></p><p>Sketching the Library Structure<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-441"><div><p></p><p>The Check Datatype<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-442"><div><p></p><p>Basic Combinators<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-444"><div><p></p><p>Transforming Data<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-445"><div><p></p><p>Predicates<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-446"><div><p></p><p>Checks<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-449"><div><p></p><p>Recap<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-450"><div><p></p><p>Kleislis<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-452"><div><p></p><p>Summary<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-453"><div><p></p><p>Case Study: CRDTs<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li><a href="#loc-454"><div><p></p><p>Eventual Consistency<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li>
              <div><a href="#loc-455"><div><p></p><p>The GCounter<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-456"><div><p></p><p>Simple Counters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-460"><div><p></p><p>GCounters<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-465"><div><p></p><p>Exercise: GCounter Implementation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li>
              <div><a href="#loc-466"><div><p></p><p>Generalisation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-467"><div><p></p><p>Implementation<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-468"><div><p></p><p>Exercise: BoundedSemiLattice Instances<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
                <li><a href="#loc-469"><div><p></p><p>Exercise: Generic GCounter<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
            <li><a href="#loc-470"><div><p></p><p>Abstracting GCounter to a Type Class<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-471"><div><p></p><p>Abstracting a Key Value Store<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
            <li><a href="#loc-472"><div><p></p><p>Summary<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
          </ol>
        </li>
        <li>
          <div><a href="#loc-473"><div><p></p><p>Acknowledgements<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
          <ol style="list-style-type: none">
            <li>
              <div><a href="#loc-474"><div><p></p><p>Acknowledgements from Scala with Cats<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></div>
              <ol style="list-style-type: none">
                <li><a href="#loc-475"><div><p></p><p>Backers<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</p></div></a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#loc-476"><div>Bibliography<span style="white-space: pre-wrap">&#x20;</span><span style="display: inline-block"></span> ⁠1</div></a></li>
      </ol>
    </nav>
    <h2 id="loc-1">Preface</h2>
    <p>Some twenty years ago I started my first job in the UK. This job involved a commute by train, giving me about an hour a day to read without distraction. Around about the same time I first heard about <a id="loc-2" href="#loc-477" role="doc-biblioref"><em>Structure and Interpretation of Computer Programs</em> [1</a>], referred to as the “wizard book” and spoken of in reverential terms. It sounded like the just the thing for a recent graduate looking to become a better developer. I purchased a copy and spent the journey reading it, doing most of the exercises in my head. <em>Structure and Interpretation of Computer Programs</em> was already an old book at this time, and it’s programming style was archaic. However it’s core concepts were timeless and it’s fair to say it absolutely blew my mind, putting me on a path I’m still on today.</p>
    <p>Another notable stop on this path occured some ten years ago when Dave and I started writing <em>Scala with Cats</em>. In <em>Scala with Cats</em> we attempted to explain the core type classes found in the Cats library, and their use in building software. I’m proud of the book we wrote together, but time and experience showed that type classes are only a small piece of the puzzle of building software in a functional programming style. We needed a much wider scope if we were to show people how to effectively build software with all the tools that functional programming provides. Still, writing a book is a lot of work, and we were busy with other projects, so <em>Scala with Cats</em> remained largely untouched for many years.</p>
    <p>Around 2020 I got the itch to return to <em>Scala with Cats</em>. My initial plan was simply to update the book for Scala 3. Dave was busy with other projects so I decided to go alone. As the writing got underway I realized I really wanted to cover the additional topics I thought were missing. If <em>Scala with Cats</em> was a good book, I wanted to aim to write a great book; one that would contain almost everything I had learned about building software. The title <em>Scala with Cats</em> no longer fit the content, and hence I adopted a new name for what is largely a new book. The result, <em>Functional Programming Strategies in Scala with Cats</em>, is what you are reading now. I hope you find it useful, and I hope that just maybe some young developer will find this book inspiring the same way I found <em>Structure and Interpretation of Computer Programs</em> inspiring all those years ago.</p>
    <h3 id="loc-3">Preface from Scala with Cats</h3>
    <p>The aims of this book are two-fold: to introduce monads, functors, and other functional programming patterns as a way to structure program design, and to explain how these concepts are implemented in <a href="https://typelevel.org/cats">Cats<a id="loc-4" href="#loc-571" role="doc-noteref"><sup>1</sup></a></a>.</p>
    <p>Monads, and related concepts, are the functional programming equivalent of object-oriented design patterns—architectural building blocks that turn up over and over again in code. They differ from object-oriented patterns in two main ways:</p>
    <ul>
      <li>they are formally, and thus precisely, defined; and</li>
      <li>they are extremely (extremely) general.</li>
    </ul>
    <p>This generality means they can be difficult to understand. <em>Everyone</em> finds abstraction difficult. However, it is generality that allows concepts like monads to be applied in such a wide variety of situations.</p>
    <p>In this book we aim to show the concepts in a number of different ways, to help you build a mental model of how they work and where they are appropriate. We have extended case studies, a simple graphical notation, many smaller examples, and of course the mathematical definitions. Between them we hope you’ll find something that works for you.</p>
    <p>Ok, let’s get started!</p>
    <h3 id="loc-5">Versions</h3>
    <p>This book is written for Scala 3.7.3 and Cats 2.13.0. Here is a minimal <code>build.sbt</code> containing the relevant dependencies and settings<a id="loc-6" href="#loc-572" role="doc-noteref"><sup>2</sup></a>:</p>
    <pre><code data-lang="scala">scalaVersion := <span style="color: #198810">"</span><span style="color: #198810">3.7.3</span><span style="color: #198810">"</span><br><br>libraryDependencies +=<br>  <span style="color: #198810">"</span><span style="color: #198810">org.typelevel</span><span style="color: #198810">"</span> %% <span style="color: #198810">"</span><span style="color: #198810">cats-core</span><span style="color: #198810">"</span> % <span style="color: #198810">"</span><span style="color: #198810">2.13.0</span><span style="color: #198810">"</span><br><br>scalacOptions ++= <span style="color: #4b69c6">Seq</span>(<br>  <span style="color: #198810">"</span><span style="color: #198810">-Xfatal-warnings</span><span style="color: #198810">"</span><br>)</code></pre>
    <h4 id="loc-7">Template Projects</h4>
    <p>For convenience, we have created a Giter8 template to get you started. To clone the template type the following:</p>
    <pre><code data-lang="bash"><span style="color: #4b69c6">$</span> sbt new scalawithcats/cats-seed.g8</code></pre>
    <p>This will generate a sandbox project with Cats as a dependency. See the generated <code>README.md</code> for instructions on how to run the sample code and/or start an interactive Scala console.</p>
    <h3 id="loc-8">Conventions Used in This Book</h3>
    <p>This book contains a lot of technical information and program code. We use the following typographical conventions to reduce ambiguity and highlight important concepts:</p>
    <h4 id="loc-9">Typographical Conventions</h4>
    <p>New terms and phrases are introduced in <em>italics</em>. After their initial introduction they are written in normal roman font.</p>
    <p>Terms from program code, filenames, and file contents, are written in <code>monospace font</code>. Note that we do not distinguish between singular and plural forms. For example, we might write <code>String</code> or <code>Strings</code> to refer to <code>java.lang.String</code>.</p>
    <p>References to external resources are written as <a href="https://scalawithcats.com">hyperlinks<a id="loc-10" href="#loc-573" role="doc-noteref"><sup>3</sup></a></a>, which also render as footnotes for situations when you cannot conveniently follow links. References to API documentation are written using a combination of hyperlinks and monospace font, for example: <a href="http://www.scala-lang.org/api/current/scala/Option.html"><code>scala.Option</code><a id="loc-11" href="#loc-574" role="doc-noteref"><sup>4</sup></a></a>.</p>
    <h4 id="loc-12">Source Code</h4>
    <p>Source code blocks are written as follows. Syntax is highlighted appropriately where applicable:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> MyApp</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">App</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Print a fine message to the user!</span><br>  println(<span style="color: #198810">"</span><span style="color: #198810">Hello world!</span><span style="color: #198810">"</span>)<br>}</code></pre>
    <p>Most code passes through <a href="https://scalameta.org/mdoc/">mdoc<a id="loc-13" href="#loc-575" role="doc-noteref"><sup>5</sup></a></a> to ensure it compiles. mdoc uses the Scala console behind the scenes, so we sometimes show console-style output as comments:</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">Hello Cats!</span><span style="color: #198810">"</span>.toUpperCase<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: String = "HELLO CATS!"</span></code></pre>
    <h4 id="loc-14">Callout Boxes</h4>
    <p>We use two types of <em>callout box</em> to highlight particular content:</p>
    <div>Tip callouts indicate handy summaries, recipes, or best practices.</div>
    <div>Advanced callouts provide additional information on corner cases or underlying mechanisms. Feel free to skip these on your first read-through—come back to them later for extra information.</div>
    <h3 id="loc-15">License</h3>
    <p>This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0<a id="loc-16" href="#loc-576" role="doc-noteref"><sup>6</sup></a></a>.</p>
    <p>Portions of this work are based on <em>Scala with Cats</em> by Dave Pereira-Gurnell and Noel Welsh, which is licensed under <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0<a id="loc-17" href="#loc-577" role="doc-noteref"><sup>7</sup></a></a>.</p>
    <h2 id="loc-18">1. Functional Programming Strategies</h2>
    <p>This is a book on strategies for creating code in a functional programming (FP) style, seen through a Scala lens. If you understand most of the mechanics of Scala, but feel there is something missing in your understanding of how to use the language effectively, this book is for you. If you want to learn about functional programming, and are prepared to learn some Scala, this book is also for you. It covers the usual functional programming abstractions like monads and monoids, but more than that it tries to teach you how to think like a functional programmer. It’s a book as much about process as it is about the code that results from process, and in particular it focuses on what I call metacognitive programming strategies.</p>
    <p>Functional programmers love fancy words for simple ideas, so it’s no surprise I’m drawn to metacognitive programming strategies. Let’s unpack that phrase. Metacognition means thinking about thinking. A lot of research has shown the benefits of metacognition in learning and its importance in developing expertise (see, for example, <span id="loc-19">[</span><a href="#loc-491" role="doc-biblioref">15</a>,<a href="#loc-529" role="doc-biblioref">53</a>,<a href="#loc-546" role="doc-biblioref">70</a>]). Metacognition is not just one thing—it’s not sufficient to just tell someone to think about their thinking. Rather, metacognition is a collection of different strategies, some of which are general and some of which are domain specific. From this we get the idea of metacognitive programming strategies—explicitly naming and describing different thinking strategies that proficient programmers use.</p>
    <p>Let’s think a little about metacognitive strategies you might already use when coding. My experience is that most developers struggle to answer this. Software teams usually have many well-defined processes <em>around</em> coding, such as daily stand-ups and kanban boards. Developers have a huge amount of language specific knowledge. However, the part inbetween deciding what should be done and working code is often very fuzzy. When developers can answer this question they often mention test driven development and pair programming, and design patterns such as the builder pattern. These date from the nineties, the former from <em>Extreme Programming</em> <span id="loc-20">[</span><a href="#loc-480" role="doc-biblioref">4</a>] and the latter from the <em>Design Patterns</em> book <span id="loc-21">[</span><a href="#loc-507" role="doc-biblioref">31</a>]. In my experience they are used quite informally, if at all.</p>
    <p>The question then becomes: what metacognitive strategies can programmers use? I believe that functional programming is particularly well suited to answer this question. One major theme in functional programming research is finding and naming useful code structures. Once we have discovered a useful abstraction we can get the programmer to ask themselves “would this abstraction solve this problem?” This is essentially what the design patterns community did but there is an important difference. The academic FP community strongly values formal models, which means that the building blocks of FP have a precision that design patterns lack. However there is more to strategies than categorizing their output. There is also the actual process of how the code comes to be. Code doesn’t usually spring fully formed from our keyboard, and in the iterative refinement of code we also find structure. Here the academic FP community has explored various algorithms for deriving code. As working programmers we must usually execute these algorithms by hand, but the benefit still remains.</p>
    <p>I believe metacognitive programming strategies are useful for both beginners and experts. For beginners we can make programming a more systematic and repeatable process. Producing code no longer requires magic in the majority of cases, but rather the application of well defined steps. For experts, the benefit is exactly the same. At least that is my experience (and I believe I’ve been programming long enough to call myself an expert.) By having an explicit process I can run it exactly the same way every day, which makes my code simpler to write and read, and saves my brain cycles for more important problems. In some ways this is an attempt to bring to programming the benefit that process and standardization has brought to manufacturing, particularly the “Toyota Way”. In Toyota’s process individuals are expected to think about how their work is done and how it can be improved. This is, in effect, metacognition for assembly lines. This is only possible if the actual work itself does not require their full attention. The dramatic improvements in productivity and quality in car manufacturing that Toyota pioneered speak to the effectiveness of this approach. Software development is more varied than car manufacturing but we should still expect some benefit, particularly given the primitive state of our current industry.</p>
    <p>Over the last ten or so years of programming and teaching programming I’ve collected a wide range of strategies. Some come from others (for example, <a id="loc-22" href="#loc-503" role="doc-biblioref"><em>How to Design Programs</em> [27</a>] and its many offshoots remain very influential for me) and some I’ve found myself. Ultimately I don’t think anything here is new; rather my contribution is in collecting and presenting these strategies as one coherent whole, in a way that I hope is accessible to the working programmer.</p>
    <h3 id="loc-23">1.1. Three Levels for Thinking About Code</h3>
    <p>Let’s start thinking about thinking about programming, with a model that describes three different levels that we can use to think about code. The levels, from highest to lowest, are paradigm, theory, and craft. Each level provides guidance for the ones below.</p>
    <p>The paradigm level refers to the programming paradigm, such as object-oriented or functional programming. You’re probably familiar with these terms, but what exactly is a programming paradigm? To me, the core of a programming paradigm is a set of principles that define, usually somewhat loosely, the properties of good code. A paradigm is also, implicitly, a claim that code that follows these principles will be better than code that does not. For functional programming I believe these principles are composition and reasoning. I’ll explain these shortly. Object-oriented programmers might point to, say, the SOLID principles as guiding their coding decisions.</p>
    <p>The importance of the paradigm is that it provides criteria for choosing between different implementation strategies. There are many possible solutions for any programming problem, and we can use the principles in the paradigm to decide which approach to take. For example, if we’re a functional programmer we can consider how easily we can reason about a particular implementation, or how composable it is. Without the paradigm we have no basis for making a choice.</p>
    <p>The theory level translates the broad principles of the paradigm to specific well defined techniques that apply to many languages within the paradigm. We are still, however, at a level above the code. Design patterns are an example in the object-oriented world. Algebraic data types are an example in functional programming. Most languages that are in the functional programming paradigm, such as Haskell and O’Caml, support algebraic data types, as do many languages that straddle multiple paradigms, such as Rust, Scala, and Swift.</p>
    <p>The theory level is where we find most of our programming strategies.</p>
    <p>At the craft level we get to actual code, and the language specific nuance that goes into it. An example in Scala is the implementation of algebraic data types in terms of <code>sealed trait</code> and <code>final case class</code> in Scala 2, or <code>enum</code> in Scala 3. There are many concerns at this level that are important for writing idiomatic code, such as placing constructors on companion objects in Scala, that are not relevant at the higher levels.</p>
    <p>In the next section I’ll describe the functional programming paradigm. The remainder of this book is primarily concerned with theory and craft. The theory is language agnostic but the craft is firmly in the world of Scala. Before we move onto the functional programming paradigm are two points I want to emphasize:</p>
    <ol>
      <li>
        <p>Paradigms are social constructs. They change over time. Object-oriented programming as practiced today differs from the style originally used in Simula and Smalltalk, and functional programming today is very different from the original LISP code.</p>
      </li>
      <li>
        <p>The three level organization is just a tool for thought. The real world it is more complicated.</p>
      </li>
    </ol>
    <h3 id="loc-24">1.2. Functional Programming</h3>
    <p>This is a book about the techniques and practices of functional programming (FP). This naturally leads to the question: what is FP and what does it mean to write code in a functional style? It’s common to view functional programming as a collection of language features, such as first class functions, or to define it as a programming style using immutable data and pure functions. (Pure functions always return the same output given the same input.) This was my view when I started down the FP route, but I now believe the true goals of FP are enabling local reasoning and composition. Language features and programming style are in service of these goals. Let me attempt to explain the meaning and value of local reasoning and composition.</p>
    <h4 id="loc-25">1.2.1. What Functional Programming Is</h4>
    <p>I believe that functional programming is a hypothesis about software quality: that it is easier to write and maintain software that can be understood before it is run, and is built of small reusable components. The first property is known as local reasoning, and the second as composition. Let’s address each in turn.</p>
    <p>Local reasoning means we can understand pieces of code in isolation. When we see the expression <code>1 + 1</code> we know what it means regardless of the weather, the database, or the current status of our Kubernetes cluster. None of these external events can change it. This is a trivial and slightly silly example, but it illustrates the point. A goal of functional programming is to extend this ability across our code base.</p>
    <p>It can help to understand local reasoning by looking at what it is not. Shared mutable state is out because relying on shared state means that other code can change what our code does without our knowledge. It means no global mutable configuration, as found in many web frameworks and graphics libraries for example, as any random code can change that configuration. Metaprogramming has to be carefully controlled. No <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patching<a id="loc-26" href="#loc-578" role="doc-noteref"><sup>8</sup></a></a>, for example, as again it allows other code to change our code in non-obvious ways. As we can see, adapting code to enable local reasoning can mean quite some sweeping changes. However if we work in a language that embraces functional programming this style of programming is the default.</p>
    <p>Composition means building big things out of smaller things. Numbers are compositional. We can take any number and add one, giving us a new number. Lego is also compositional. We compose Lego by sticking it together. In the particular sense we’re using composition we also require the original elements we combine don’t change in any way when they are composed. When we create by <code>2</code> by adding <code>1</code> and <code>1</code> we get a new result that doesn’t change what <code>1</code> means.</p>
    <p>We can find compositional ways to model common programming tasks once we start looking for them. React components are one example familiar to many front-end developers: a component can consist of many components. HTTP routes can be modelled in a compositional way. A route is a function from an HTTP request to either a handler function or a value indicating the route did not match. We can combine routes as a logical or: try this route or, if it doesn’t match, try this other route. Processing pipelines are another example that often use sequential composition: perform this pipeline stage and then this other pipeline stage.</p>
    <h5>1.2.1.1. Types</h5>
    <p>Types are not strictly part of functional programming but statically typed FP is the most popular form of FP and sufficiently important to warrant a mention. Types help compilers generate efficient code but types in FP are as much for the programmer as they are the compiler. Types express properties of programs, and the type checker automatically ensures that these properties hold. They can tell us, for example, what a function accepts and what it returns, or that a value is optional. We can also use types to express our beliefs about a program and the type checker will tell us if those beliefs are correct. For example, we can use types to tell the compiler we do not expect an error at a particular point in our code and the type checker will let us know if this is the case. In this way types are another tool for reasoning about code.</p>
    <p>Type systems push programs towards particular designs, as to work effectively with the type checker requires designing code in a way the type checker can understand. As modern type systems come to more languages they naturally tend to shift programmers in those languages towards a FP style of coding.</p>
    <h4 id="loc-27">1.2.2. What Functional Programming Isn’t</h4>
    <p>In my view functional programming is not about immutability, or keeping to “the substitution model of evaluation”, and so on. These are tools in service of the goals of enabling local reasoning and composition, but they are not the goals themselves. Code that is immutable always allows local reasoning, for example, but it is not necessary to avoid mutation to still have local reasoning. Here is an example of summing a collection of numbers.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">sum</span>(numbers: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">var</span> total <span style="color: #d73948">=</span> <span style="color: #b60157">0</span><br>  numbers.foreach(x <span style="color: #d73948">=></span> total <span style="color: #d73948">=</span> total + x)<br>  total<br>}</code></pre>
    <p>In the implementation we mutate <code>total</code>. This is ok though! We cannot tell from the outside that this is done, and therefore all users of <code>sum</code> can still use local reasoning. Inside <code>sum</code> we have to be careful when we reason about <code>total</code> but this block of code is small enough that it shouldn’t cause any problems.</p>
    <p>In this case we can reason about our code despite the mutation, but the Scala compiler can determine that this is ok. Scala allows mutation but it’s up to us to use it appropriately. A more expressive type system, perhaps with features like Rust’s, would be able to tell that <code>sum</code> doesn’t allow mutation to be observed by other parts of the system<a id="loc-28" href="#loc-579" role="doc-noteref"><sup>9</sup></a>. Another approach, which is the one taken by Haskell, is to disallow all mutation and thus guarantee it cannot cause problems.</p>
    <p>Mutation also interferes with composition. For example, if a value relies on internal state then composing it may produce unexpected results. Consider Scala’s <code>Iterator</code>. It maintains internal state that is used to generate the next value. If we have two <code>Iterators</code> we might want to combine them into one <code>Iterator</code> that yields values from the two inputs. The <code>zip</code> method does this.</p>
    <p>This works if we pass two distinct generators to <code>zip</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> it <span style="color: #d73948">=</span> <span style="color: #4b69c6">Iterator</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>)<br><br><span style="color: #d73948">val</span> it2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Iterator</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>)</code></pre>
    <pre><code data-lang="scala">it.zip(it2).next()<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Tuple2[Int, Int] = (1, 1)</span></code></pre>
    <p>However if we pass the same generator twice we get a surprising result.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> it3 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Iterator</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>)</code></pre>
    <pre><code data-lang="scala">it3.zip(it3).next()<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Tuple2[Int, Int] = (1, 2)</span></code></pre>
    <p>The usual functional programming solution is to avoid mutable state but we can envisage other possibilities. For example, an <a href="https://en.wikipedia.org/wiki/Effect_system">effect tracking system<a id="loc-29" href="#loc-584" role="doc-noteref"><sup>12</sup></a></a> would allow us to avoid combining two generators that use the same memory region. These systems are mostly still research projects, however.</p>
    <p>So in my opinion immutability (and purity, referential transparency, and no doubt more fancy words that I have forgotten) have become associated with functional programming because they guarantee local reasoning and composition, and until recently we didn’t have the language tools to automatically distinguish safe uses of mutation from those that cause problems. Restricting ourselves to immutability is the easiest way to ensure the desirable properties of functional programming, but as languages evolve this might come to be regarded as a historical artifact.</p>
    <h4 id="loc-30">1.2.3. Why It Matters</h4>
    <p>I have described local reasoning and composition but have not discussed their benefits. Why are they are desirable? The answer is that they make efficient use of knowledge. Let me expand on this.</p>
    <p>We care about local reasoning because it allows our ability to understand code to scale with the size of the code base. We can understand module A and module B in isolation, and our understanding does not change when we bring them together in the same program. By definition if both A and B allow local reasoning there is no way that B (or any other code) can change our understanding of A, and vice versa. If we don’t have local reasoning every new line of code can force us to revisit the rest of the code base to understand what has changed. This means it becomes exponentially harder to understand code as it grows in size as the number of interactions (and hence possible behaviours) grows exponentially. We can say that local reasoning is compositional. Our understanding of module A calling module B is just our understanding of A, our understanding of B, and whatever calls A makes to B.</p>
    <p>We introduced numbers and Lego as examples of composition. They have an interesting property in common: the operations that we can use to combine them (for example, addition, subtraction, and so on for numbers; for Lego the operation is “sticking bricks together”) give us back the same kind of thing. A number multiplied by a number is a number. Two bits of Lego stuck together is still Lego. This property is called closure: when you combine things you end up with the same kind of thing. Closure means you can apply the combining operations (sometimes called combinators) an arbitrary number of times. No matter how many times you add one to a number you still have a number and can still add or subtract or multiply or…you get the idea. If we understand module A, and the combinators that A provides are closed, we can build very complex structures using A without having to learn new concepts! This is also one reason functional programmers tend to like abstractions such a monads (beyond liking fancy words): they allow us to use one mental model in lots of different contexts.</p>
    <p>In a sense local reasoning and composition are two sides of the same coin. Local reasoning is compositional; composition allows local reasoning. Both make code easier to understand.</p>
    <h4 id="loc-31">1.2.4. The Evidence for Functional Programming</h4>
    <p>I’ve made arguments in favour of functional programming and I admit I am biased—I do believe it is a better way to develop code than imperative programming. However, is there any evidence to back up my claim? There has not been much research on the effectiveness of functional programming, but there has been a reasonable amount done on static typing. I feel static typing, particularly using modern type systems, serves as a good proxy for functional programming so let’s look at the evidence there.</p>
    <p>In the corners of the Internet I frequent the common refrain is that <a href="https://danluu.com/empirical-pl/">static typing has neglible effect on productivity<a id="loc-32" href="#loc-585" role="doc-noteref"><sup>13</sup></a></a>. I decided to look into this and was surprised that the majority of the results I found support the claim that static typing increases productivity. For example, one literature review <span id="loc-33">[</span><a href="#loc-561" role="doc-biblioref">85</a>] finds a majority of results in favour of static typing, and in particular finds support amongst the more recent studies. However the majority of these studies are very small and use relatively inexperienced developers—which is noted in the review by Dan Luu. My belief is that functional programming comes into its own on larger systems. Furthermore, programming languages, like all tools, require proficiency to use effectively. I’m not convinced very junior developers have sufficient skill to demonstrate a significant difference between languages.</p>
    <p>To me the most useful evidence of the effectiveness of functional programming is that industry is adopting functional programming en masse. Consider, say, the widespread and growing adoption of Typescript and React. If we are to argue that FP as embodied by Typescript or React has no value we are also arguing that the thousands of Javascript developers who have switched to using them are deluded. At some point this argument becomes untenable.</p>
    <p>This doesn’t mean we’ll all be using Haskell in five years. More likely we’ll see something like the shift to object-oriented programming of the nineties: Smalltalk was the paradigmatic example of OO, but it was more familiar languages like C++ and Java that brought OO to the mainstream. In the case of FP this probably means languages like Scala, Swift, Kotlin, or Rust, and mainstream languages like Javascript and Java continuing to adopt more FP features.</p>
    <h4 id="loc-34">1.2.5. Final Words</h4>
    <p>I’ve given my opinion on functional programming—that the real goals are local reasoning and composition, and programming practices like immutability are in service of these. Other people may disagree with this definition, and that’s ok. Words are defined by the community that uses them, and meanings change over time.</p>
    <p>Functional programming emphasises formal reasoning, and there are some implications that I want to briefly touch on.</p>
    <p>Firstly, I find that FP is most valuable in the large. For a small system it is possible to keep all the details in our head. It’s when a program becomes too large for anyone to understand all of it that local reasoning really shows its value. This is not to say that FP should not be used for small projects, but rather that if you are, say, switching from an imperative style of programming you shouldn’t expect to see the benefit when working on toy projects.</p>
    <p>The formal models that underlie functional programming allow systematic construction of code. This is in some ways the reverse of reasoning: instead of taking code and deriving properties, we start from some properties and derive code. This sounds very academic but is in fact very practical, and how I develop most of my code.</p>
    <p>Finally, reasoning is not the only way to understand code. It’s valuable to appreciate the limitations of reasoning, other methods for gaining understanding, and using a variety of strategies depending on the situation.</p>
    <span id="loc-35"></span>
    <p>In this first part of the book we’re building the foundational strategies on which the rest of the book will build and elaborate. In <a href="#loc-36">Chapter 2</a> we discuss the role of types as representing constraints, and see how we can separate representation and operations. In <a href="#loc-51">Chapter 3</a> we look at algebraic data types. Algebraic data types are our main way of modelling data, where we are concerned with what things are. We turn to codata in <a href="#loc-77">Chapter 4</a>, which is the opposite, or dual, or algebraic data. Codata gives us a way to model things by what they can do. Abstracting over context, and the particular case of type classes, are the focus of <a href="#loc-93">Chapter 5</a>. Type classes allow us to extend existing types with new functionality, and to abstract over types that are not related by the inheritance hierarchy. The fundamentals of interpreters are discussed in <a href="#loc-126">Chapter 6</a>, and are the final chapter of this part. Interpreters give a clear distinction between description and action, and are a fundamental tool for achieving composition when working with effects.</p>
    <p>These five strategies all describe code artifacts. For example, we can label part of code as an algebraic data type or a type class. We’ll also see strategies that help us write code but don’t necessarily end up directly reflected in it, such as following the types.</p>
    <h2 id="loc-36">2. Types as Constraints</h2>
    <p>Our very first strategy is using <strong>types as constraints</strong>. We’ll start by discussing two different ways we can think of types: by what it is, sometimes known as an <strong>extensional</strong> view; and by what it can do, sometimes known as an <strong>intensional</strong> view. The latter view is not as well known, but is necessary to get the most from an expressive type system and is the core of the strategy. Hence we’ll spend some time elaborating on this idea, and discussing examples.</p>
    <p>Once we understand the concept of types as constraints, we’ll look at a Scala 3 feature, known as <strong>opaque types</strong>. Opaque types allow us to create distinct types that have the same runtime representation as another type. As such, they provide a way to decouple representation from operations, and allow us to work with a purely intensional view.</p>
    <h3 id="loc-37">2.1. Sets and Constraints</h3>
    <p>What is a type? One way of answering this question quickly veers into mathematics and philosophy. There are some references in the conclusions if you want to follow that direction. Here we’ll answer this question from the programmer’s perspective.</p>
    <p>The most common perspective is that types are sets of values. This is the extensional view, as we are defining all the elements that make up the set. For example, an <code>Int</code> in Scala is 32-bits and as such can represent one of 4,294,967,296 possible values. This view is focused on representation, as it ultimately boils down to specifying the in-memory layout of a type, and hence the information needed to enumerate all the possible values of the type.</p>
    <p>When we think of types in terms of how data is represented we are working with the information the compiler needs to allocate memory for values, and to generate instructions that operate on those values. If we are working with a relatively inexpressive type system, such as the C type system, it’s easy to see types as nothing more than busy work to make the compiler happy.</p>
    <p>The extensional view doesn’t provide any <strong>encapsulation</strong> or <strong>information hiding</strong>. Knowing the representation can be a problem when that integer represents, say, an index into an array, or an age, or a timestamp. In these cases we have access to a whole range of operations that aren’t meaningful on the data. For example, neither indices nor ages can be negated, but nonetheless we can negate any index or age that is represented as an <code>Int</code>. Furthermore, as we’ll see in <a href="#loc-326">Chapter 14</a>, it can be useful to have types that have no representation, which the extensional view doesn’t have much to say about.</p>
    <p>This brings us to an alternate view of types, the intensional view. Instead of thinking of a type in terms of its representation, we can think of a type in terms of the conditions, invariants, or constraints that hold for elements of that type. This may in turn imply a set of operations that are valid on our types. So, for example, we can think of age (in years) as a non-negative integer, with an operation to increment an age but no operation to decrement them (we, unfortunately, cannot get younger.) Similarly, indices are non-negative integers within the range of the array they refer to, names might be non-empty strings, and email addresses could be case insensitive strings.</p>
    <p>We might argue that our <code>Int</code> example above <em>is</em> defined by a constraint: namely it’s an integer that fits into 32-bits. This is true! This constraint also implies which operations are available on <code>Int</code>. We cannot, for example, try to convert an <code>Int</code> to upper case; this is meaningless. Remember that we’re taking two different views on the same concept. It’s expected that we can translate between these views in many cases. The problem is the purely extensional view couples operations and representation. We cannot represent, say, a timestamp as an <code>Int</code> and not make meaningless bitwise operations available if we only have the extensional view.</p>
    <p>Decoupling operations and representation sounds a lot like programming to an interface. Indeed this is true, and we’ll look at this in much more detail in <a href="#loc-77">Chapter 4</a>. In this chapter we’ll look at opaque types, which directly decouple type and representation, allowing us to reuse a representation as a different type. However, before doing so I want to spend more time on the mindset shift that the intensional view promotes.</p>
    <h3 id="loc-38">2.2. Building Constraints</h3>
    <p>Most applications work by progressively adding structure to inputs. We might receive data from, say, the network or a database. We perform some checks on that data, and remove instances that are invalid. We then do some more work, which entails further checks, and so on.</p>
    <p>For example, imagine we’re implementing a sign up flow. We start by asking for a user name and email address. Basic checks could be requiring names that are not empty, and email addresses that contain an <code>@</code>. We won’t even let the user submit the form if these checks fail. If this looks ok, we’ll move on to further checks. For example, we might validate email addresses by sending them a verification email.</p>
    <p>How should we represent these multiple levels of validation? For example, how do we distinguish a string representing a name from one that is an email address? How about an unverified email from a verified one? If you’ve worked on enough projects you’ve probably seen many approaches to this. Many code bases use names in an ad hoc do this. For example, we might use the name <code>email</code> and <code>verifiedEmail</code> to distinguish the different kinds of email addresses in method parameters and data structure members, while still representing both as strings.<a id="loc-39" href="#loc-586" role="doc-noteref"><sup>14</sup></a></p>
    <p>Types provide a compelling alternative to naming schemes. It provides all the advantages of naming schemes, while also representing this information in a form the compiler can check for us. For example, if we have <code>EmailAddress</code> and <code>VerifiedEmailAddress</code> types, the compiler will tell us if we try to use an <code>EmailAddress</code> where a <code>VerifiedEmailAddress</code> is required, or a <code>String</code> where an <code>EmailAddress</code> is required. Furthermore, when we see an <code>EmailAddress</code> we know it’s already been through some validation, so we don’t need to repeat this validation (or worse, forget to do it.) This brings us to two principles:</p>
    <ol>
      <li value="1">
        <p>Types should represent what we know about values, or in other words the invariants or constraints on values. A <code>String</code> could be any sequence of characters. A <code>VerifiedEmailAddress</code> is also a sequence of characters, but it’s one that represents an email address that we have verified is active.</p>
      </li>
      <li value="2">
        <p>Whenever we establish an additional invariant or constraint we should change the type to reflect this additional information. So for example, an email address might start out as a <code>String</code>, become an <code>EmailAddress</code> if we have verified it looks like an email, and then become a <code>VerifiedEmailAddress</code> when we’ve successfully sent it a verification email and received a response.</p>
      </li>
    </ol>
    <p>A corollary of this approach is that we push constraints upstream. Let me explain. In a code base where validation is done on an ad-hoc basis, we often end up with methods that can fail. For example, a method to get the domain from an email, where the email is represented as a <code>String</code>, might have the signature</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">domain</span>(email: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">String</span>]</code></pre>
    <p>indicating that the <code>String</code> might not be a valid email. In this case we push the error handling, which reflects the constraint that we only work with valid email addresses, onto the downstream code that deals with the result of calling this method.</p>
    <p>When we work with types as constraints the signature becomes</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">domain</span>(email: <span style="color: #4b69c6">EmailAddress</span>): <span style="color: #4b69c6">String</span></code></pre>
    <p>There is now no possibility of error, as an email address must contain a domain. However, we have pushed the constraint, obtaining an <code>EmailAddress</code>, onto the upstream code that calls this method. At some point we must bottom out and have conversions that could fail, but this approach pushes error handling to the edges of the program. This tends to result in a better user experience, as the user is immediately notified of problems, and also makes the code simpler to work with as less error handling is required.</p>
    <p>Finally, although this strategy is easiest to explain in the context of validation, it’s not restricted to only this use. As an example, let’s think about writing code that presents an API for updates to a database table. Some columns allow nulls and some do not. When updating a nullable column we could accept an <code>Option</code>, with the <code>None</code> case meaning setting the column to null. When updating a non-nullable column we could also accept an <code>Option</code>, with the <code>None</code> case meaning we retain the existing value. These two different meaning of the same type are a sure way to introduce errors, with users nulling out columns they intended to leave unchanged. Here the constraints are not on the values represented by the type, but on the behaviour associated with the type. The same type should not have different behaviours in the same API.</p>
    <h3 id="loc-40">2.3. Opaque Types</h3>
    <p>Let’s now look at opaque types. Opaque types are a Scala 3 feature that decouple the representation of a type from the set of allowed operations on that type. In simpler words, they allow us to create a type (e.g. an <code>EmailAddress</code>) that has the same runtime representation as another type (e.g. a <code>String</code>), but is distinct from that type in all other ways.</p>
    <p>Here’s a definition of <code>EmailAddress</code> as an opaque type.</p>
    <pre><code data-lang="scala">opaque <span style="color: #d73948">type</span> <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">String</span></code></pre>
    <p>This is enough to define the type <code>EmailAddress</code> as represented by a <code>String</code>. However, it’s a useless definition as it lacks any way to construct an <code>EmailAddress</code>. To properly understand how we can define a constructor, we need to understand that opaque types divide our code base into two distinct parts: that where our type is transparent, where we know the underlying representation, and the remainder where it is opaque. The rule is pretty simple: an opaque type is transparent within the scope in which it is defined, so within an enclosing object or class. If there is no enclosing scope, as in the example above, it is transparent only within the file in which it is defined. Everywhere else it is opaque.</p>
    <p>Knowing this we can define a constructor. Following Scala convention we will define it as the <code>apply</code> method on the <code>EmailAddress</code> companion object.</p>
    <pre><code data-lang="scala">opaque <span style="color: #d73948">type</span> <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">String</span><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> EmailAddress</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(address: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">=</span> {<br>    assert(<br>      {<br>        <span style="color: #d73948">val</span> idx <span style="color: #d73948">=</span> address.indexOf(<span style="color: #b60157">'@'</span>)<br>        idx <span style="color: #d73948">!=</span> -<span style="color: #b60157">1</span> &amp;&amp; address.lastIndexOf(<span style="color: #b60157">'@'</span>) <span style="color: #d73948">==</span> idx<br>      },<br>      <span style="color: #198810">"</span><span style="color: #198810">Email address must contain exactly one @ symbol.</span><span style="color: #198810">"</span><br>    )<br>    address.toLowerCase<br>  }<br>}</code></pre>
    <p>The constructor does a basic check on the input (ensuring it contains only one <code>@</code> character) and converts the input to lower case, as email addresses are case insensitive. I used an <code>assert</code> to do the check, but in a real application we’d probably want a result type that indicates something can go wrong. More on this below. Finally, notice that the constructor returns just the <code>address</code>, showing that the representation doesn’t change. Here’s an example, showing the result type <code>EmailAddress</code></p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> email <span style="color: #d73948">=</span> <span style="color: #4b69c6">EmailAddress</span>(<span style="color: #198810">"</span><span style="color: #198810">someone@example.com</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> email: EmailAddress = "someone@example.com"</span></code></pre>
    <p>This shows that an <code>EmailAddress</code> is represented as a <code>String</code>, but as far as the type system is concerned it is not a <code>String</code>. We cannot, for example, call methods defined on <code>String</code> on an instance of <code>EmailAddress</code>.<a id="loc-41" href="#loc-589" role="doc-noteref"><sup>16</sup></a></p>
    <pre><code data-lang="scala">email.toUpperCase<br><span style="color: #74747c">//</span><span style="color: #74747c"> Compiler says NO!</span></code></pre>
    <p>We can view this as an efficiency gain. Our <code>EmailAddress</code> uses exactly the same amount of memory as the underlying <code>String</code> that represents it, yet it is a different type. Alternatively, we can view it as a semantic gain. An <code>EmailAddress</code> <em>is</em> a sequence of characters, the same as a <code>String</code>, but it has additional properties. In this case we verify it contains exactly one <code>@</code> character, and our email addresses are case insensitive.</p>
    <p>We’ve seen how to define opaque types and their constructors. What about other methods? For example, for an <code>EmailAddress</code> we might want to get the username and domain. We can use extension methods to do this. As with the constructor, we just need to define these extension methods in a place where the type is transparent.</p>
    <pre><code data-lang="scala">opaque <span style="color: #d73948">type</span> <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">String</span><br>extension (address: <span style="color: #4b69c6">EmailAddress</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">username</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    address.substring(<span style="color: #b60157">0</span>, address.indexOf(<span style="color: #b60157">'@'</span>))<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">domain</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    address.substring(address.indexOf(<span style="color: #b60157">'@'</span>) + <span style="color: #b60157">1</span>, address.size)<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> EmailAddress</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(address: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">=</span> {<br>    assert(<br>      {<br>        <span style="color: #d73948">val</span> idx <span style="color: #d73948">=</span> address.indexOf(<span style="color: #b60157">'@'</span>)<br>        idx <span style="color: #d73948">!=</span> -<span style="color: #b60157">1</span> &amp;&amp; address.lastIndexOf(<span style="color: #b60157">'@'</span>) <span style="color: #d73948">==</span> idx<br>      },<br>      <span style="color: #198810">"</span><span style="color: #198810">Email address must contain exactly one @ symbol.</span><span style="color: #198810">"</span><br>    )<br>    address.toLowerCase<br>  }<br>}</code></pre>
    <p>With this definition we can use the extension methods as we’d expect.</p>
    <pre><code data-lang="scala">email.username<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "someone"</span><br>email.domain<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: String = "example.com"</span></code></pre>
    <h4 id="loc-42">2.3.1. Best Practices</h4>
    <p>We’ve seen all the important technical details for opaque types, so let’s now discuss some of the best practices—the craft—of using them.</p>
    <p>The first point I want to address is the constructor. “Types as constraints” is the strategy we’re covering in this chapter. There is a constraint on the <code>String</code> input to the constructor: it must contain an <code>@</code> character. We should represent this as a type! We could create another opaque type, called something like <code>StringWithAnAtCharacter</code>, but this approaches leads to infinite regress. We cannot push constraints forward indefinitely. At some point we have to work with primitive types and return a result that indicates the possibility of error. So our constructor would be better if it returned, say, an <code>Option</code> or <code>Either</code> to indicate that construction can fail.</p>
    <p>There are cases where we know the constructor cannot fail, but we don’t have a convenient way of proving this to the compiler. For example, if we’re loading email addresses from a list that is known to be good, it would be nice to avoid having to writing useless error handling code. For this reason I recommend including a constructor that doesn’t do any validation. I usually call this method <code>unsafeApply</code>, to indicate to the reader that certain checks are not being done. These changes are shown below. For simplicity I’ve used <code>Option</code> as the result type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">String</span><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> EmailAddress</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(address: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">EmailAddress</span>] <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> idx <span style="color: #d73948">=</span> address.indexOf(<span style="color: #b60157">'@'</span>)<br>    <span style="color: #d73948">if</span> idx <span style="color: #d73948">!=</span> -<span style="color: #b60157">1</span> &amp;&amp; address.lastIndexOf(<span style="color: #b60157">'@'</span>) <span style="color: #d73948">==</span> idx<br>    then <span style="color: #4b69c6">Some</span>(address.toLowerCase)<br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">None</span><br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unsafeApply</span>(address: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">EmailAddress</span> <span style="color: #d73948">=</span> address<br>}</code></pre>
    <p>At some point we’ll almost certainly need to convert from our opaque type back to its underlying type. I’ve seen a few conventions for naming such a method; <code>value</code> and <code>get</code> are popular. However, I prefer a more descriptive <code>toType</code>, replacing <code>Type</code> with the concreate type name, as this extends to conversions to other types. For <code>EmailAddress</code> this means an extension method <code>toString</code>, as shown below. Notice that the method simply returns the <code>address</code> value, once showing the distinction between the type and it’s representation as a value.</p>
    <pre><code data-lang="scala">extension (address: <span style="color: #4b69c6">EmailAddress</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">toString</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> address<br>}</code></pre>
    <h4 id="loc-43">2.3.2. Beyond Opaque Types</h4>
    <p>Opaque types are a lightweight way to add structure—to use types to represent constraints—to our code. However there are two cases where they aren’t appropriate.</p>
    <p>The first case is when the data requires more structure that we can represent with an opaque type. For example, a (two-dimensional) point requires two coordinates, so there is no single type that we can use<a id="loc-44" href="#loc-590" role="doc-noteref"><sup>17</sup></a>. We also cannot define opaque types with type parameters. In these cases we’re probably looking for an algebraic data type, which is discussed in <a href="#loc-51">Chapter 3</a>.</p>
    <p>The second case is when we need to reimplement one of the methods, most commonly <code>toString</code>, that opaque types cannot override. For example, if we’re creating types that represent personal information such as addresses and passwords, we might want to ensure they cannot be accidentally exposed in logs. Overriding <code>toString</code> helps ensure this, but we cannot do this for opaque types.</p>
    <h3 id="loc-45">2.4. Conclusions</h3>
    <p>The view of types as constraints is perhaps best presented in Alexis King’s blog post <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don’t validate<a id="loc-46" href="#loc-591" role="doc-noteref"><sup>18</sup></a></a>.</p>
    <p>From a programming language perspective, <a id="loc-47" href="#loc-545" role="doc-biblioref"><em>Types and Programming Languages</em> [69</a>] is the standard reference on type systems. They define a type system as “a tractable syntactic method for proving the absence of certain program behaviours by classifying phrases by the kinds of values they compute”. The introduction provides a very nice overview of the role of type systems in programming languages, as well as pointers to the broader study of type systems in mathematics and philosophy.</p>
    <p><a id="loc-48" href="#loc-534" role="doc-biblioref"><em>Types Are Not Sets</em> [58</a>] is a very early paper (typewritten in two column justified text, a truly virtuoso performance on the type writer!) that presents the intensional view of types. I feel it ends a bit abruptly, but has the seed of many ideas that will only be fully developed much later. You can see the suggestion of opaque types as discussed in this chapter, and also module systems and existential types.</p>
    <p>Having said that types are not sets, it feels only fair to mention there are type systems that treat types as sets. <a id="loc-49" href="#loc-488" role="doc-biblioref"><em>The Design Principles of the Elixir Type System</em> [12</a>] describes one such system. These type systems emphasize the extensional view, and have a very different feel to conventional type systems.</p>
    <p>I’m very far from an expert in mathematical type theory. As such, I found <a id="loc-50" href="#loc-522" role="doc-biblioref"><em>A Comparison of Type Theory with Set Theory</em> [46</a>] useful to relate type theory to something I better understand, set theory.</p>
    <h2 id="loc-51">3. Algebraic Data Types</h2>
    <p>This chapter has our first example of a programming strategy: <strong>algebraic data types</strong>. Any data we can describe using logical ands and logical ors is an algebraic data type. Once we recognize an algebraic data type we get three things for free:</p>
    <ul>
      <li>the Scala representation of the data;</li>
      <li>a <strong>structural recursion</strong> skeleton to transform the algebraic data type into any other type; and</li>
      <li>a <strong>structural corecursion</strong> skeleton to construct the algebraic data type from any other type.</li>
    </ul>
    <p>The key point is this: from an implementation independent representation of data we can automatically derive most of the interesting implementation specific parts of working with that data.</p>
    <p>We’ll start with some examples of data, from which we’ll extract the common structure that motivates algebraic data types. We will then look at their representation in Scala 2 and Scala 3. Next we’ll turn to structural recursion for transforming algebraic data types, followed by structural corecursion for constructing them. We’ll finish by looking at the algebra of algebraic data types, which is interesting but not essential.</p>
    <h3 id="loc-52">3.1. Building Algebraic Data Types</h3>
    <p>Let’s start with some examples of data from a few different domains. These are simplified description but they are all representative of real applications.</p>
    <p>A user in a discussion forum will typically have a screen name, an email address, and a password. Users also typically have a specific role: normal user, moderator, or administrator, for example. From this we get the following data:</p>
    <ul>
      <li>a user is a screen name, an email address, a password, and a role; and</li>
      <li>a role is normal, moderator, or administrator.</li>
    </ul>
    <p>A product in an e-commerce store might have a stock keeping unit (a unique identifier for each variant of a product), a name, a description, a price, and a discount.</p>
    <p>In two-dimensional vector graphics it’s typical to represent shapes as a path, which is a sequence of actions of a virtual pen. The possible actions are usually straight lines, Bezier curves, or movement that doesn’t result in visible output. A straight line has an end point (the starting point is implicit), a Bezier curve has two control points and an end point, and a move has an end point.</p>
    <p>What is common between all the examples above is that the individual elements—the atoms, if you like—are connected by either a logical and or a logical or. For example, a user is a screen name <em>and</em> an email address <em>and</em> a password <em>and</em> a role. A 2D action is a straight line <em>or</em> a Bezier curve <em>or</em> a move. This is the core of algebraic data types: an algebraic data type is data that is combined using logical ands or logical ors. Conversely, whenever we can describe data in terms of logical ands and logical ors we have an algebraic data type.</p>
    <h4 id="loc-53">3.1.1. Sums and Products</h4>
    <p>Being functional programmers we can’t let a simple concept go without attaching some fancy jargon:</p>
    <ul>
      <li>a <strong>product type</strong> means a logical and; and</li>
      <li>a <strong>sum type</strong> means a logical or.</li>
    </ul>
    <p>So algebraic data types consist of sum and product types.</p>
    <h4 id="loc-54">3.1.2. Closed Worlds</h4>
    <p>Algebraic data types are closed worlds, which means they cannot be extended after they have been defined. In practical terms this means we have to modify the source code where we define the algebraic data type if we want to add or remove elements.</p>
    <p>The closed world property is important because it gives us guarantees we would not otherwise have. In particular, it allows the compiler to check that we handle all possible cases when we use an algebraic data type. This is known as <strong>exhaustivity checking</strong>. This is an example of how functional programming prioritizes reasoning about code—in this case automated reasoning by the compiler—over other properties such as extensibility. We’ll learn more about exhaustivity checking soon.</p>
    <h3 id="loc-55">3.2. Algebraic Data Types in Scala</h3>
    <p>Now we know what algebraic data types are, we will turn to their representation in Scala. The important point here is that the translation to Scala is entirely determined by the structure of the data; no thinking is required! This means the work is in finding the structure of the data that best represents the problem at hand. Work out the structure of the data and the code directly follows from it.</p>
    <p>As algebraic data types are defined in terms of logical ands and logical ors, to represent algebraic data types in Scala we must know how to represent these two concepts. Scala 3 simplifies the representation of algebraic data types compared to Scala 2, so we’ll look at each language version separately.</p>
    <p>I’m assuming that you’re familiar with the language features we use to represent algebraic data types in Scala, so I won’t be going over them.</p>
    <h4 id="loc-56">3.2.1. Algebraic Data Types in Scala 3</h4>
    <p>In Scala 3 a logical and (a product type) is represented by a <code>final case class</code>. If we define a product type <code>A</code> is <code>B</code> <em>and</em> <code>C</code>, the representation in Scala 3 is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> A</span>(b: <span style="color: #4b69c6">B</span>, c: <span style="color: #4b69c6">C</span>)</code></pre>
    <p>Not everyone makes their case classes <code>final</code>, but they should. A non-<code>final</code> case class can still be extended by a class, which breaks the closed world criteria for algebraic data types.</p>
    <p>A logical or (a sum type) is represented by an <code>enum</code>. For the sum type <code>A</code> is <code>B</code> <em>or</em> <code>C</code>, the Scala 3 representation is</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">A</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">B</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">C</span><br>}</code></pre>
    <p>There are a few wrinkles to be aware of.</p>
    <p>If we have a sum of products, such as:</p>
    <ul>
      <li><code>A</code> is <code>B</code> or <code>C</code>; and</li>
      <li><code>B</code> is <code>D</code> and <code>E</code>; and</li>
      <li><code>C</code> is <code>F</code> and <code>G</code></li>
    </ul>
    <p>the representation is</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">A</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">B</span>(d: <span style="color: #4b69c6">D</span>, e: <span style="color: #4b69c6">E</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">C</span>(f: <span style="color: #4b69c6">F</span>, g: <span style="color: #4b69c6">G</span>)<br>}</code></pre>
    <p>In other words we don’t write <code>final case class</code> inside an <code>enum</code>. You also can’t nest an <code>enum</code> inside an <code>enum</code>. Nested logical ors can be rewritten into a single logical or containing only logical ands (known as disjunctive normal form) so this is not a limitation in practice. However the Scala 2 representation is still available in Scala 3 should you want more expressivity.</p>
    <h4 id="loc-57">3.2.2. Algebraic Data Types in Scala 2</h4>
    <p>A logical and (product type) has the same representation in Scala 2 as in Scala 3. If we define a product type <code>A</code> is <code>B</code> <em>and</em> <code>C</code>, the representation in Scala 2 is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> A</span>(b: <span style="color: #4b69c6">B</span>, c: <span style="color: #4b69c6">C</span>)</code></pre>
    <p>A logical or (a sum type) is represented by a <code>sealed abstract class</code>. For the sum type <code>A</code> is a <code>B</code> <em>or</em> <code>C</code> the Scala 2 representation is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> A</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> B</span>() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">A</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> C</span>() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">A</span></code></pre>
    <p>Scala 2 has several little tricks to defining algebraic data types.</p>
    <p>Firstly, instead of using a <code>sealed abstract class</code> you can use a <code>sealed trait</code>. There isn’t much practical difference between the two. When teaching beginners I’ll often use <code>sealed trait</code> to avoid having to introduce <code>abstract class</code>. I believe <code>sealed abstract class</code> has slightly better performance and Java interoperability, but I haven’t tested this. I also think <code>sealed abstract class</code> is closer, semantically, to the meaning of a sum type.</p>
    <p>For extra style points we can <code>extend Product with Serializable</code> from <code>sealed abstract class</code>. Compare the reported types below with and without this little addition.</p>
    <p>Let’s first see the code without extending <code>Product</code> and <code>Serializable</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> A</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> B</span>() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">A</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> C</span>() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">A</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> list <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">B</span>(), <span style="color: #4b69c6">C</span>())<br><span style="color: #74747c">//</span><span style="color: #74747c"> list: List[A extends Product with Serializable] = List(B(), C())</span></code></pre>
    <p>Notice how the type of <code>list</code> includes <code>Product</code> and <code>Serializable</code>.</p>
    <p>Now we have extending <code>Product</code> and <code>Serializable</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> A</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> B</span>() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">A</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> C</span>() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">A</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> list <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">B</span>(), <span style="color: #4b69c6">C</span>())<br><span style="color: #74747c">//</span><span style="color: #74747c"> list: List[A] = List(B(), C())</span></code></pre>
    <p>Much easier to read!</p>
    <p>You’ll only see this in Scala 2. Scala 3 has the concept of <strong>transparent traits</strong>, which aren’t reported in inferred types, so you’ll see the same output in Scala 3 no matter whether you add <code>Product</code> and <code>Serializable</code> or not.</p>
    <p>Finally, we can use a <code>case object</code> instead of a <code>case class</code> when we’re defining some type that holds no data. For example, reading from a text stream, such as a terminal, can return a character or the end-of-file. We can model this as</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Result</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Character</span>(value: <span style="color: #d73948">Char</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Result</span><br><span style="color: #d73948">case </span><span style="color: #d73948">object</span><span style="color: #4b69c6"> Eof</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Result</span></code></pre>
    <p>As the end-of-file indicator <code>Eof</code> has no associated data we use a <code>case object</code>. There is no need to mark the <code>case object</code> as <code>final</code>, as objects cannot be extended.</p>
    <h4 id="loc-58">3.2.3. Examples</h4>
    <p>Let’s make the discussion above more concrete with some examples.</p>
    <h5>3.2.3.1. Role and User</h5>
    <p>In the discussion forum example, we said a role is normal, moderator, or administrator. This is a logical or, so we can directly translate it to Scala using the appropriate pattern. In Scala 3 we write</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Role</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Normal</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Moderator</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Administrator</span><br>}</code></pre>
    <p>In Scala 2 we write</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Role</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span><br><span style="color: #d73948">case </span><span style="color: #d73948">object</span><span style="color: #4b69c6"> Normal</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Role</span><br><span style="color: #d73948">case </span><span style="color: #d73948">object</span><span style="color: #4b69c6"> Moderator</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Role</span><br><span style="color: #d73948">case </span><span style="color: #d73948">object</span><span style="color: #4b69c6"> Administrator</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Role</span></code></pre>
    <p>The cases within a role don’t hold any data, so we used a <code>case object</code> in the Scala 2 code.</p>
    <p>We defined a user as a screen name, an email address, a password, and a role. In both Scala 3 and Scala 2 this becomes</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> User</span>(<br>  screenName: <span style="color: #4b69c6">String</span>,<br>  emailAddress: <span style="color: #4b69c6">String</span>,<br>  password: <span style="color: #4b69c6">String</span>,<br>  role: <span style="color: #4b69c6">Role</span><br>)</code></pre>
    <p>I’ve used <code>String</code> to represent most of the data within a <code>User</code>, but in real code we might want to define distinct types for each field.</p>
    <h5>3.2.3.2. Paths</h5>
    <p>We defined a path as a sequence of actions of a virtual pen. The possible actions are straight lines, Bezier curves, or movement that doesn’t result in visible output. A straight line has an end point (the starting point is implicit), a Bezier curve has two control points and an end point, and a move has an end point.</p>
    <p>This has a straightforward translation to Scala. We can represent paths as the following in both Scala 3 and Scala 2.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Path</span>(actions: <span style="color: #4b69c6">Seq</span>[<span style="color: #4b69c6">Action</span>])</code></pre>
    <p>An action is a logical or, so we have different representations in Scala 3 and Scala 2. In Scala 3 we’d write</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Action</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Line</span>(end: <span style="color: #4b69c6">Point</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Curve</span>(cp1: <span style="color: #4b69c6">Point</span>, cp2: <span style="color: #4b69c6">Point</span>, end: <span style="color: #4b69c6">Point</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Move</span>(end: <span style="color: #4b69c6">Point</span>)<br>}</code></pre>
    <p>where <code>Point</code> is a suitable representation of a two-dimensional point.</p>
    <p>In Scala 2 we have to go with the more verbose</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Action</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span> <br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Line</span>(end: <span style="color: #4b69c6">Point</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Action</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Curve</span>(cp1: <span style="color: #4b69c6">Point</span>, cp2: <span style="color: #4b69c6">Point</span>, end: <span style="color: #4b69c6">Point</span>)<br>  extends <span style="color: #4b69c6">Action</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Move</span>(end: <span style="color: #4b69c6">Point</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Action</span></code></pre>
    <h4 id="loc-59">3.2.4. Representing ADTs in Scala 3</h4>
    <p>We’ve seen that the Scala 3 representation of algebraic data types, using <code>enum</code>, is more compact than the Scala 2 representation. However the Scala 2 representation is still available. Should you ever use the Scala 2 representation in Scala 3? There are a few cases where you may want to:</p>
    <ul>
      <li>
        <p>Scala 3′s doesn’t currently support nested <code>enums</code> (<code>enums</code> within <code>enums</code>). This may change in the future, but right now it can be more convenient to use the Scala 2 representation to express this without having to convert to disjunctive normal form.</p>
      </li>
      <li>
        <p>Scala 2′s representation can express things that are almost, but not quite, algebraic data types. For example, if you define a method on an <code>enum</code> you must be able to define it for all the members of the <code>enum</code>. Sometimes you want a case of an <code>enum</code> to have methods that are only defined for that case. To implement this you’ll need to use the Scala 2 representation instead.</p>
      </li>
    </ul>
    <h5>Exercise: Tree</h5>
    <p>To gain a bit of practice defining algebraic data types, code the following description in Scala (your choice of version, or do both.)</p>
    <p>A <code>Tree</code> with elements of type <code>A</code> is:</p>
    <ul>
      <li>a <code>Leaf</code> with a value of type <code>A</code>; or</li>
      <li>a <code>Node</code> with a left and right child, which are both <code>Trees</code> with elements of type <code>A</code>.</li>
    </ul>
    <h3 id="loc-60">3.3. Structural Recursion</h3>
    <p>Structural recursion is our second programming strategy. Algebraic data types tell us how to create data given a certain structure. Structural recursion tells us how to transform an algebraic data types into any other type. Given an algebraic data type, the transformation can be implemented using structural recursion.</p>
    <p>As with algebraic data types, there is distinction between the concept of structural recursion and the implementation in Scala. This is more obvious because there are two ways to implement structural recursion in Scala: via pattern matching or via dynamic dispatch. We’ll look at each in turn.</p>
    <h4 id="loc-61">3.3.1. Pattern Matching</h4>
    <p>I’m assuming you’re familiar with pattern matching in Scala, so I’ll only talk about how to implement structural recursion using pattern matching. Remember there are two kinds of algebraic data types: sum types (logical ors) and product types (logical ands). We have corresponding rules for structural recursion implemented using pattern matching:</p>
    <ol>
      <li>For each branch in a sum type we have a distinct <code>case</code> in the pattern match; and</li>
      <li>Each <code>case</code> corresponds to a product type with the pattern written in the usual way.</li>
    </ol>
    <p>Let’s see this in code, using an example ADT that includes both sum and product types:</p>
    <ul>
      <li><code>A</code> is <code>B</code> or <code>C</code>; and</li>
      <li><code>B</code> is <code>D</code> and <code>E</code>; and</li>
      <li><code>C</code> is <code>F</code> and <code>G</code></li>
    </ul>
    <p>which we represent (in Scala 3) as</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">A</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">B</span>(d: <span style="color: #4b69c6">D</span>, e: <span style="color: #4b69c6">E</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">C</span>(f: <span style="color: #4b69c6">F</span>, g: <span style="color: #4b69c6">G</span>)<br>}</code></pre>
    <p>Following the rules above means a structural recursion would look like</p>
    <pre><code data-lang="scala">anA <span style="color: #d73948">match</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">B</span>(d, e) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">C</span>(f, g) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>}</code></pre>
    <p>The <code>???</code> bits are problem specific, and we cannot give a general solution for them. However we’ll soon see strategies to help create them.</p>
    <h4 id="loc-62">3.3.2. The Recursion in Structural Recursion</h4>
    <p>At this point you might be wondering where the recursion in structural recursion comes from. This is an additional rule for recursion: whenever the data is recursive the method is recursive in the same place.</p>
    <p>Let’s see this in action for a real data type.</p>
    <p>We can define a list with elements of type <code>A</code> as:</p>
    <ul>
      <li>the empty list; or</li>
      <li>a pair containing an <code>A</code> and a tail, which is a list of <code>A</code>.</li>
    </ul>
    <p>This is exactly the definition of <code>List</code> in the standard library. Notice it’s an algebraic data type as it consists of sums and products. It is also recursive: in the pair case the tail is itself a list.</p>
    <p>We can directly translate this to code, using the strategy for algebraic data types we saw previously. In Scala 3 we write</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>}</code></pre>
    <p>Let’s implement <code>map</code> for <code>MyList</code>. We start with the method skeleton specifying just the name and types.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>Our first step is to recognize that <code>map</code> can be written using a structural recursion. <code>MyList</code> is an algebraic data type, <code>map</code> is transforming this algebraic data type, and therefore structural recursion is applicable. We now apply the structural recursion strategy, giving us</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>    }<br>}</code></pre>
    <p>I forgot the recursion rule! The data is recursive in the <code>tail</code> of <code>Pair</code>, so <code>map</code> is recursive there as well.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> tail.map(f)<br>    }<br>}</code></pre>
    <p>I left the <code>???</code> to indicate that we haven’t finished with that case.</p>
    <p>Now we can move on to the problem specific parts. Here we have three strategies to help us:</p>
    <ol>
      <li>reasoning independently by case;</li>
      <li>assuming the recursion is correct; and</li>
      <li>following the types</li>
    </ol>
    <p>The first two are specific to structural recursion, while the final one is a general strategy we can use in many situations. Let’s briefly discuss each and then see how they apply to our example.</p>
    <p>The first strategy is relatively simple: when we consider the problem specific code on the right hand side of a pattern matching <code>case</code>, we can ignore the code in any other pattern match cases. So, for example, when considering the case for <code>Empty</code> above we don’t need to worry about the case for <code>Pair</code>, and vice versa.</p>
    <p>The next strategy is a little bit more complicated, and has to do with recursion. Remember that the structural recursion strategy tells us where to place any recursive calls. This means we don’t have to think through the recursion. Instead we assume the recursive call will correctly compute what it claims, and only consider how to further process the result of the recursion. The result is guaranteed to be correct so long as we get the non-recursive parts correct.</p>
    <p>In the example above we have the recursion <code>tail.map(f)</code>. We can assume this correctly computes <code>map</code> on the tail of the list, and we only need to think about what we should do with the remaining data: the <code>head</code> and the result of the recursive call.</p>
    <p>It’s this property that allows us to consider cases independently. Recursive calls are the only thing that connect the different cases, and they are given to us by the structural recursion strategy.</p>
    <p>Our final strategy is <strong>following the types</strong>. It can be used in many situations, not just structural recursion, so I consider it a separate strategy. The core idea is to use the information in the types to restrict the possible implementations. We can look at the types of inputs and outputs to help us.</p>
    <p>Now let’s use these strategies to finish the implementation of <code>map</code>. We start with</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> tail.map(f)<br>    }<br>}</code></pre>
    <p>Our first strategy is to consider the cases independently. Let’s start with the <code>Empty</code> case. There is no recursive call here, so reasoning about recursion doesn’t come into play. Let’s instead use the types. There is no input here other than the <code>Empty</code> case we have already matched, so we cannot use the input types to further restrict the code. Let’s instead consider the output type. We’re trying to create a <code>MyList[B]</code>. There are only two ways to create a <code>MyList[B]</code>: an <code>Empty</code> or a <code>Pair</code>. To create a <code>Pair</code> we need a <code>head</code> of type <code>B</code>, which we don’t have. So we can only use <code>Empty</code>. <em>This is the only possible code we can write</em>. The types are sufficiently restrictive that we cannot write incorrect code for this case.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span>()<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> tail.map(f)<br>    }<br>}</code></pre>
    <p>Now let’s move to the <code>Pair</code> case. We can apply both the structural recursion reasoning strategy and following the types. Let’s use each in turn.</p>
    <p>The case for <code>Pair</code> is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> tail.map(f)</code></pre>
    <p>Remember we can consider this independently of the other case. We assume the recursion is correct. This means we only need to think about what we should do with the <code>head</code>, and how we should combine this result with <code>tail.map(f)</code>. Let’s now follow the types to finish the code. Our goal is to produce a <code>MyList[B]</code>. We already the following available:</p>
    <ul>
      <li><code>tail.map(f)</code>, which has type <code>MyList[B]</code>;</li>
      <li><code>head</code>, with type <code>A</code>;</li>
      <li><code>f</code>, with type <code>A => B</code>; and</li>
      <li>the constructors <code>Empty</code> and <code>Pair</code>.</li>
    </ul>
    <p>We could return just <code>Empty</code>, matching the case we’ve already written. This has the correct type but we might expect it is not the correct answer because it does not use the result of the recursion, <code>head</code>, or <code>f</code> in any way.</p>
    <p>We could return just <code>tail.map(f)</code>. This has the correct type but we might expect it is not correct because we don’t use <code>head</code> or <code>f</code> in any way.</p>
    <p>We can call <code>f</code> on <code>head</code>, producing a value of type <code>B</code>, and then combine this value and the result of the recursive call using <code>Pair</code> to produce a <code>MyList[B]</code>. This is the correct solution.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span>()<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Pair</span>(f(head), tail.map(f))<br>    }<br>}</code></pre>
    <p>If you’ve followed this example you’ve hopefully see how we can use the three strategies to systematically find the correct implementation. Notice how we interleaved the recursion strategy and following the types to guide us to a solution for the <code>Pair</code> case. Also note how following the types alone gave us three possible implementations for the <code>Pair</code> case. In this code, and as is usually the case, the solution was the implementation that used all of the available inputs.</p>
    <h4 id="loc-63">3.3.3. Exhaustivity Checking</h4>
    <p>Remember that algebraic data types are a closed world: they cannot be extended once defined. The Scala compiler can use this to check that we handle all possible cases in a pattern match, so long as we write the pattern match in a way the compiler can work with. This is known as exhaustivity checking.</p>
    <p>Here’s a simple example. We start by defining a straight-forward algebraic data type.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Some of the possible units for lengths in CSS</span><br>enum <span style="color: #4b69c6">CssLength</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Em</span>(value: <span style="color: #d73948">Double</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Rem</span>(value: <span style="color: #d73948">Double</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pt</span>(value: <span style="color: #d73948">Double</span>)<br>}</code></pre>
    <p>If we write a pattern match using the structural recursion strategy, the compiler will complain if we’re missing a case.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> CssLength.*<br><br><span style="color: #4b69c6">CssLength</span>.<span style="color: #4b69c6">Em</span>(<span style="color: #b60157">2</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>) <span style="color: #d73948">match</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Em</span>(value) <span style="color: #d73948">=></span> value<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Rem</span>(value) <span style="color: #d73948">=></span> value<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> -- [E029] Pattern Match Exhaustivity Warning: ----------------------------------</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> 1 |CssLength.Em(2.0) match {</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   |^^^^^^^^^^^^^^^^^</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   |match may not be exhaustive.</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   |</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   |It would fail on pattern case: CssLength.Pt(_)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   |</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   | longer explanation available when compiling with `-explain`</span></code></pre>
    <p>Exhaustivity checking is incredibly useful. For example, if we add or remove a case from an algebraic data type, the compiler will tell us all the pattern matches that need to be updated.</p>
    <h4 id="loc-64">3.3.4. Dynamic Dispatch</h4>
    <p>Using dynamic dispatch to implement structural recursion is an implementation technique that may feel more natural to people with a background in object-oriented programming.</p>
    <p>The dynamic dispatch approach consists of:</p>
    <ol>
      <li>defining an <em>abstract method</em> at the root of the algebraic data types; and</li>
      <li>implementing that abstract method at every leaf of the algebraic data type.</li>
    </ol>
    <p>This implementation technique is only available if we use the Scala 2 encoding of algebraic data types.</p>
    <p>Let’s see it in the <code>MyList</code> example we just looked at. Our first step is to rewrite the definition of <code>MyList</code> to the Scala 2 style.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Empty</span>[<span style="color: #4b69c6">A</span>]() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">MyList</span>[<span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Pair</span>[<span style="color: #4b69c6">A</span>](head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">MyList</span>[<span style="color: #4b69c6">A</span>]</code></pre>
    <p>Next we define an abstract method for <code>map</code> on <code>MyList</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>]<br>}<br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Empty</span>[<span style="color: #4b69c6">A</span>]() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">MyList</span>[<span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Pair</span>[<span style="color: #4b69c6">A</span>](head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">MyList</span>[<span style="color: #4b69c6">A</span>]</code></pre>
    <p>Then we implement <code>map</code> on the concrete subtypes <code>Empty</code> and <code>Pair</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>]<br>}<br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Empty</span>[<span style="color: #4b69c6">A</span>]() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <br>    <span style="color: #4b69c6">Empty</span>()<br>}<br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Pair</span>[<span style="color: #4b69c6">A</span>](head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Pair</span>(f(head), tail.map(f))<br>}</code></pre>
    <p>We can use exactly the same strategies we used in the pattern matching case to create this code. The implementation technique is different but the underlying concept is the same.</p>
    <p>Given we have two implementation strategies, which should we use? If we’re using <code>enum</code> in Scala 3 we don’t have a choice; we must use pattern matching. In other situations we can choose between the two. I prefer to use pattern matching when I can, as it puts the entire method definition in one place. However, Scala 2 in particular has problems inferring types in some pattern matches. In these situations we can use dynamic dispatch instead. We’ll learn more about this when we look at generalized algebraic data types.</p>
    <h5>Exercise: Methods for Tree</h5>
    <p>In a previous exercise we created a <code>Tree</code> algebraic data type:</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Leaf</span>(value: <span style="color: #4b69c6">A</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Node</span>(left: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>])<br>}</code></pre>
    <p>Or, in the Scala 2 encoding:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Tree</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Product</span> <span style="color: #d73948">with</span> <span style="color: #8b41b1">Serializable</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Leaf</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Tree</span>[<span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Node</span>[<span style="color: #4b69c6">A</span>](left: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Tree</span>[<span style="color: #4b69c6">A</span>]</code></pre>
    <p>Let’s get some practice with structural recursion and write some methods for <code>Tree</code>. Implement</p>
    <ul>
      <li><code>size</code>, which returns the number of values (<code>Leafs</code>) stored in the <code>Tree</code>;</li>
      <li><code>contains</code>, which returns <code>true</code> if the <code>Tree</code> contains a given element of type <code>A</code>, and <code>false</code> otherwise; and</li>
      <li><code>map</code>, which creates a <code>Tree[B]</code> given a function <code>A => B</code></li>
    </ul>
    <p>Use whichever you prefer of pattern matching or dynamic dispatch to implement the methods.</p>
    <h4 id="loc-65">3.3.5. Folds as Structural Recursions</h4>
    <p>Let’s finish by looking at the fold method as an abstraction over structural recursion. If you did the <code>Tree</code> exercise above, you will have noticed that we wrote the same kind of code again and again. Here are the methods we wrote. Notice the left-hand sides of the pattern matches are all the same, and the right-hand sides are very similar.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">size</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> { <br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Leaf</span>(value)       <span style="color: #d73948">=></span> <span style="color: #b60157">1</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Node</span>(left, right) <span style="color: #d73948">=></span> left.size + right.size<br>  }<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(element: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> { <br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Leaf</span>(value)       <span style="color: #d73948">=></span> element <span style="color: #d73948">==</span> value<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Node</span>(left, right) <span style="color: #d73948">=></span> left.contains(element) || right.contains(element)<br>  }<br>  <br><span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> { <br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Leaf</span>(value)       <span style="color: #d73948">=></span> <span style="color: #4b69c6">Leaf</span>(f(value))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Node</span>(left, right) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Node</span>(left.map(f), right.map(f))<br>  }</code></pre>
    <p>This is the point of structural recursion: to recognize and formalize this similarity. However, as programmers we might want to abstract over this repetition. Can we write a method that captures everything that doesn’t change in a structural recursion, and allows the caller to pass arguments for everything that does change? It turns out we can. For any algebraic data type we can define at least one method, called a fold, that captures all the parts of structural recursion that don’t change and allows the caller to specify all the problem specific parts.</p>
    <p>Let’s see how this is done using the example of <code>MyList</code>. Recall the definition of <code>MyList</code> is</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>}</code></pre>
    <p>We know the structural recursion skeleton for <code>MyList</code> is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">doSomething</span>[<span style="color: #4b69c6">A</span>](list: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">=</span><br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()          <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> doSomething(tail)<br>  } </code></pre>
    <p>Implementing fold for <code>MyList</code> means defining a method</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">fold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](list: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> fold(tail)<br>  }</code></pre>
    <p>where <code>B</code> is the type the caller wants to create.</p>
    <p>To complete <code>fold</code> we add method parameters for the problem specific (<code>???</code>) parts. In the case for <code>Empty</code>, we need a value of type <code>B</code> (notice that I’m following the types here).</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">fold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](list: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>], empty: <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> empty<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span> fold(tail, empty)<br>  }</code></pre>
    <p>For the <code>Pair</code> case, we have the head of type <code>A</code> and the recursion producing a value of type <code>B</code>. This means we need a function to combine these two values.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](list: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>], empty: <span style="color: #4b69c6">B</span>, f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> empty<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> f(head, foldRight(tail, empty, f))<br>  }</code></pre>
    <p>This is <code>foldRight</code> (and I’ve renamed the method to indicate this). You might have noticed there is another valid solution. Both <code>empty</code> and the recursion produce values of type <code>B</code>. If we follow the types we can come up with</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">foldLeft</span>[<span style="color: #4b69c6">A</span>,<span style="color: #4b69c6">B</span>](list: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>], empty: <span style="color: #4b69c6">B</span>, f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> empty<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> foldLeft(tail, f(head, empty), f)<br>  }</code></pre>
    <p>which is <code>foldLeft</code>, the tail-recursive variant of fold for a list. (We’ll talk about tail-recursion in a later chapter.)</p>
    <p>We can follow the same process for any algebraic data type to create its folds. The rules are:</p>
    <ul>
      <li>a fold is a function from the algebraic data type and additional parameters to some generic type that I’ll call <code>B</code> below for simplicity;</li>
      <li>the fold has one additional parameter for each case in a logical or;</li>
      <li>each parameter is a function, with result of type <code>B</code> and parameters that have the same type as the corresponding constructor arguments <em>except</em> recursive values are replaced with <code>B</code>; and</li>
      <li>if the constructor has no arguments (for example, <code>Empty</code>) we can use a value of type <code>B</code> instead of a function with no arguments.</li>
    </ul>
    <p>Returning to <code>MyList</code>, it has:</p>
    <ul>
      <li>two cases, and hence two parameters to fold (other than the parameter that is the list itself);</li>
      <li><code>Empty</code> is a constructor with no arguments and hence we use a parameter of type <code>B</code>; and</li>
      <li><code>Pair</code> is a constructor with one parameter of type <code>A</code> and one recursive parameter, and hence the corresponding function has type <code>(A, B) => B</code>.</li>
    </ul>
    <h5>Exercise: Tree Fold</h5>
    <p>Implement a fold for <code>Tree</code> defined earlier. There are several different ways to traverse a tree (pre-order, post-order, and in-order). Just choose whichever seems easiest.</p>
    <h5>Exercise: Using Fold</h5>
    <p>Prove to yourself that you can replace structural recursion with calls to fold, by redefining <code>size</code>, <code>contains</code>, and <code>map</code> for <code>Tree</code> using only fold.</p>
    <h3 id="loc-66">3.4. Structural Corecursion</h3>
    <p>Structural corecursion is the opposite—more correctly, the dual—of structural recursion. Whereas structural recursion tells us how to take apart an algebraic data type, structural corecursion tells us how to build up, or construct, an algebraic data type. Whereas we can use structural recursion whenever the input of a method or function is an algebraic data type, we can use structural corecursion whenever the output of a method or function is an algebraic data type.</p>
    <div>
      <h5>Duality in Functional Programming</h5>
      <p>Two concepts or structures are duals if one can be translated in a one-to-one fashion to the other. Duality is one of the main themes of this book. By relating concepts as duals we can transfer knowledge from one domain to another.</p>
      <p>Duality is often indicated by attaching the co- prefix to one of the structures or concepts. For example, corecursion is the dual of recursion, and sum types, also known as coproducts, are the dual of product types.</p>
    </div>
    <p>Structural recursion works by considering all the possible inputs (which we usually represent as patterns), and then working out what we do with each input case. Structural corecursion works by considering all the possible outputs, which are the constructors of the algebraic data type, and then working out the conditions under which we’d call each constructor.</p>
    <p>Let’s return to the list with elements of type <code>A</code>, defined as:</p>
    <ul>
      <li>the empty list; or</li>
      <li>a pair containing an <code>A</code> and a tail, which is a list of <code>A</code>.</li>
    </ul>
    <p>In Scala 3 we write</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>}</code></pre>
    <p>We can use structural corecursion if we’re writing a method that produces a <code>MyList</code>. A good example is <code>map</code>:</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>The output of this method is a <code>MyList</code>, which is an algebraic data type. Since we need to construct a <code>MyList</code> we can use structural corecursion. The structural corecursion strategy says we write down all the constructors and then consider the conditions that will cause us to call each constructor. So our starting point is to just write down the two constructors, and put in dummy conditions.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">if</span> <span style="color: #d73948">???</span> then <span style="color: #4b69c6">Empty</span>()<br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">Pair</span>(<span style="color: #d73948">???</span>, <span style="color: #d73948">???</span>)<br>}</code></pre>
    <p>We can also apply the recursion rule: where the data is recursive so is the method.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">if</span> <span style="color: #d73948">???</span> then <span style="color: #4b69c6">Empty</span>()<br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">Pair</span>(<span style="color: #d73948">???</span>, <span style="color: #d73948">???</span>.map(f))<br>}</code></pre>
    <p>To complete the left-hand side we can use the strategies we’ve already seen:</p>
    <ul>
      <li>we can use structural recursion to tell us there are two possible conditions; and</li>
      <li>we can follow the types to align these conditions with the code we have already written.</li>
    </ul>
    <p>In short order we arrive at the correct solution</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>  <br>  <span style="color: #d73948">def</span> map[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] = <br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span>()<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Pair</span>(f(head), tail.map(f))<br>    }<br>}</code></pre>
    <p>There are a few interesting points here. Firstly, we should acknowledge that <code>map</code> is both a structural recursion and a structural corecursion. This is not always the case. For example, <code>foldLeft</code> and <code>foldRight</code> are not structural corecursions because they are not constrained to only produce an algebraic data type. Secondly, note that when we walked through the process of creating <code>map</code> as a structural recursion we implicitly used the structural corecursion pattern, as part of following the types. We recognised that we were producing a <code>List</code>, that there were two possibilities for producing a <code>List</code>, and then worked out the correct conditions for each case. Formalizing structural corecursion as a separate strategy allows us to be more conscious of where we apply it. Finally, notice how I switched from an <code>if</code> expression to a pattern match expression as we progressed through defining <code>map</code>. This is perfectly fine. Both kinds of expression achieve the same effect. Pattern matching is a little bit safer due to exhaustivity checking. If we wanted to continue using an <code>if</code> we’d have to define a method (for example, <code>isEmpty</code>) that allows us to distinguish an <code>Empty</code> element from a <code>Pair</code>. This method would have to use pattern matching in its implementation, so avoiding pattern matching directly is just pushing it elsewhere.</p>
    <h4 id="loc-67">3.4.1. Unfolds as Structural Corecursion</h4>
    <p>Just as we could abstract structural recursion as a fold, for any given algebraic data type we can abstract structural corecursion as an unfold. Unfolds are much less commonly used than folds, but they are still a nice tool to have.</p>
    <p>Let’s work through the process of deriving unfold, using <code>MyList</code> as our example again.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br>}</code></pre>
    <p>The corecursion skeleton is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">if</span> <span style="color: #d73948">???</span> then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br><span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(<span style="color: #d73948">???</span>, recursion(<span style="color: #d73948">???</span>))</code></pre>
    <p>Our starting point is writing the skeleton for <code>unfold</code>. It’s a little bit unusual in that I’ve added a parameter <code>seed</code>. This is the information we use to create an element. We’ll need this, but we cannot derive it from our strategies, so I’ve added it in here as a starting assumption.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>Now we start using our strategies to fill in the missing pieces. I’m using the corecursion skeleton and I’ve applied the recursion rule immediately in the code below, to save a bit of time in the derivation.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span> <span style="color: #d73948">???</span> then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(<span style="color: #d73948">???</span>, unfold(seed))</code></pre>
    <p>We can abstract the condition using a function from <code>A => Boolean</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>, stop: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span> stop(seed) then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(<span style="color: #d73948">???</span>, unfold(seed, stop))</code></pre>
    <p>Now we need to handle the case for <code>Pair</code>. We have a value of type <code>A</code> (<code>seed</code>), so to create the <code>head</code> element of <code>Pair</code> we can ask for a function <code>A => B</code></p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>, stop: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span> stop(seed) then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(f(seed), unfold(<span style="color: #d73948">???</span>, stop, f))</code></pre>
    <p>Finally we need to update the current value of <code>seed</code> to the next value. That’s a function <code>A => A</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>, stop: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, next: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span> stop(seed) then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(f(seed), unfold(next(seed), stop, f, next))</code></pre>
    <p>At this point we’re done. Let’s see that <code>unfold</code> is useful by declaring some other methods in terms of it. We’re going to declare <code>map</code>, which we’ve already seen is a structural corecursion, using <code>unfold</code>. We will also define <code>fill</code> and <code>iterate</code>, which are methods that construct lists and correspond to the methods with the same names on <code>List</code> in the Scala standard library.</p>
    <p>To make this easier to work with I’m going to declare <code>unfold</code> as a method on the <code>MyList</code> companion object. I have made a slight tweak to the definition to make type inference work a bit better. In Scala, types inferred for one method parameter cannot be used for other method parameters in the same parameter list. However, types inferred for one method parameter list can be used in subsequent lists. Separating the function parameters from the <code>seed</code> parameter means that the value inferred for <code>A</code> from <code>seed</code> can be used for inference of the function parameters’ input parameters.</p>
    <p>I have also declared some <strong>destructor</strong> methods, which are methods that take apart an algebraic data type. For <code>MyList</code> these are <code>head</code>, <code>tail</code>, and the predicate <code>isEmpty</code>. We’ll talk more about these a bit later.</p>
    <p>Here’s our starting point.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(_head: <span style="color: #4b69c6">A</span>, _tail: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>])<br><br>  <span style="color: #d73948">def</span> isEmpty: <span style="color: #d73948">Boolean</span> =<br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #d73948">true</span><br>      <span style="color: #d73948">case</span> <span style="color: #d73948">_</span>       <span style="color: #d73948">=></span> <span style="color: #d73948">false</span><br>    }<br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, <span style="color: #d73948">_</span>) <span style="color: #d73948">=></span> head<br>    }<br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(<span style="color: #d73948">_</span>, tail) <span style="color: #d73948">=></span> tail<br>    }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> MyList</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>)(stop: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, next: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">if</span> stop(seed) then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(f(seed), unfold(next(seed))(stop, f, next))<br>}</code></pre>
    <p>Now let’s define the constructors <code>fill</code> and <code>iterate</code>, and <code>map</code>, in terms of <code>unfold</code>. I think the constructors are a bit simpler, so I’ll do those first.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> MyList</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>)(stop: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, next: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">if</span> stop(seed) then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(f(seed), unfold(next(seed))(stop, f, next))<br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">fill</span>[<span style="color: #4b69c6">A</span>](n: <span style="color: #d73948">Int</span>)(elem: <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">iterate</span>[<span style="color: #4b69c6">A</span>](start: <span style="color: #4b69c6">A</span>, len: <span style="color: #d73948">Int</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>Here I’ve just added the method skeletons, which are taken straight from the <code>List</code> documentation. To implement these methods we can use one of two strategies:</p>
    <ul>
      <li>reasoning about loops in the way we might in an imperative language; or</li>
      <li>reasoning about structural recursion over the natural numbers.</li>
    </ul>
    <p>Let’s talk about each in turn.</p>
    <p>You might have noticed that the parameters to <code>unfold</code> are almost exactly those you need to create a for-loop in a language like Java. A classic for-loop, of the <code>for(i = 0; i &lt; n; i++)</code> kind, has four components:</p>
    <ol>
      <li>the initial value of the loop counter;</li>
      <li>the stopping condition of the loop;</li>
      <li>the statement that advances the counter; and</li>
      <li>the body of the loop that uses the counter.</li>
    </ol>
    <p>These correspond to the <code>seed</code>, <code>stop</code>, <code>next</code>, and <code>f</code> parameters of <code>unfold</code> respectively.</p>
    <p>Loop variants and invariants are the standard way of reasoning about imperative loops. I’m not going to describe them here, as you have probably already learned how to reason about loops (though perhaps not using these terms). Instead I’m going to discuss the second reasoning strategy, which relates writing <code>unfold</code> to something we’ve already discussed: structural recursion.</p>
    <p>Our first step is to note that natural numbers (the integers 0 and larger) are conceptually algebraic data types even though the implementation in Scala—using <code>Int</code>—is not. A natural number is either:</p>
    <ul>
      <li>zero; or</li>
      <li>1 + a natural number.</li>
    </ul>
    <p>It’s the simplest possible algebraic data type that is both a sum and a product type.</p>
    <p>Once we see this, we can use the reasoning tools for structural recursion for creating the parameters to <code>unfold</code>. Let’s show how this works with <code>fill</code>. The <code>n</code> parameter tells us how many elements there are in the <code>List</code> we’re creating. The <code>elem</code> parameter creates those elements, and is called once for each element. So our starting point is to consider this as a structural recursion over the natural numbers. We can take <code>n</code> as <code>seed</code>, and <code>stop</code> as the function <code>x => x == 0</code>. These are the standard conditions for a structural recursion over the natural numbers. What about <code>next</code>? Well, the definition of natural numbers tells us we should subtract one in the recursive case, so <code>next</code> becomes <code>x => x - 1</code>. We only need <code>f</code>, and that comes from the definition of how <code>fill</code> is supposed to work. We create the value from <code>elem</code>, so <code>f</code> is just <code>_ => elem</code></p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> MyList</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>)(stop: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, next: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">if</span> stop(seed) then <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Empty</span>()<br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">MyList</span>.<span style="color: #4b69c6">Pair</span>(f(seed), unfold(next(seed))(stop, f, next))<br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">fill</span>[<span style="color: #4b69c6">A</span>](n: <span style="color: #d73948">Int</span>)(elem: <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    unfold(n)(<span style="color: #d73948">_</span> <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>, <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> elem, <span style="color: #d73948">_</span> - <span style="color: #b60157">1</span>)<br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">iterate</span>[<span style="color: #4b69c6">A</span>](start: <span style="color: #4b69c6">A</span>, len: <span style="color: #d73948">Int</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">MyList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>We should check that our implementation works as intended. We can do this by comparing it to <code>List.fill</code>.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>.fill(<span style="color: #b60157">5</span>)(<span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: List[Int] = List(1, 1, 1, 1, 1)</span><br><span style="color: #4b69c6">MyList</span>.fill(<span style="color: #b60157">5</span>)(<span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: MyList[Int] = MyList(1, 1, 1, 1, 1)</span></code></pre>
    <p>Here’s a slightly more complex example, using a stateful method to create a list of ascending numbers. First we define the state and method that uses it.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">var</span> counter <span style="color: #d73948">=</span> <span style="color: #b60157">0</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">getAndInc</span>(): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> temp <span style="color: #d73948">=</span> counter<br>  counter <span style="color: #d73948">=</span> counter + <span style="color: #b60157">1</span><br>  temp <br>}</code></pre>
    <p>Now we can create it to create lists.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>.fill(<span style="color: #b60157">5</span>)(getAndInc())<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: List[Int] = List(0, 1, 2, 3, 4)</span><br>counter <span style="color: #d73948">=</span> <span style="color: #b60157">0</span><br><span style="color: #4b69c6">MyList</span>.fill(<span style="color: #b60157">5</span>)(getAndInc())<br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: MyList[Int] = MyList(0, 1, 2, 3, 4)</span></code></pre>
    <h5>Exercise: Iterate</h5>
    <p>Implement <code>iterate</code> using the same reasoning as we did for <code>fill</code>. This is slightly more complex than <code>fill</code> as we need to keep two bits of information: the value of the counter and the value of type <code>A</code>.</p>
    <h5>Exercise: Map</h5>
    <p>Once you’ve completed <code>iterate</code>, try to implement <code>map</code> in terms of <code>unfold</code>. You’ll need to use the destructors to implement it.</p>
    <p>Now a quick discussion on destructors. The destructors do two things:</p>
    <ol>
      <li>distinguish the different cases within a sum type; and</li>
      <li>extract elements from each product type.</li>
    </ol>
    <p>So for <code>MyList</code> the minimal set of destructors is <code>isEmpty</code>, which distinguishes <code>Empty</code> from <code>Pair</code>, and <code>head</code> and <code>tail</code>. The extractors are partial functions in the conceptual, not Scala, sense; they are only defined for a particular product type and throw an exception if used on a different case. You may have also noticed that the functions we passed to <code>fill</code> are exactly the destructors for natural numbers.</p>
    <p>The destructors are another part of the duality between structural recursion and corecursion. Structural recursion is:</p>
    <ul>
      <li>defined by pattern matching on the constructors; and</li>
      <li>takes apart an algebraic data type into smaller pieces.</li>
    </ul>
    <p>Structural corecursion instead is:</p>
    <ul>
      <li>defined by conditions on the input, which may use destructors; and</li>
      <li>build up an algebraic data type from smaller pieces.</li>
    </ul>
    <p>One last thing before we leave <code>unfold</code>. If we look at the usual definition of <code>unfold</code> we’ll probably find the following definition.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](in: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">B</span>]</code></pre>
    <p>This is equivalent to the definition we used, but a bit more compact in terms of the interface it presents. We used a more explicit definition that makes the structure of the method clearer.</p>
    <h3 id="loc-68">3.5. The Algebra of Algebraic Data Types</h3>
    <p>A question that sometimes comes up is where the “algebra” in algebraic data types comes from. I want to talk about this a little bit and show some of the algebraic manipulations that can be done on algebraic data types.</p>
    <p>The term algebra is used in the sense of abstract algebra, an area of mathematics. Abstract algebra deals with algebraic structures. An algebraic structure consists of a set of values, operations on that set, and properties that those operations must maintain. An example is the set of integers, the operations addition and multiplication, and the familiar properties of these operations such as associativity, which says that</p>
    <p>. The abstract in abstract algebra means that it doesn’t deal with concrete values like integers—that would be far too easy to understand—and instead with abstractions with wacky names like semigroup, monoid, and ring. The example of integers above is an instance of a ring. We’ll see a lot more of these soon enough!</p>
    <p>Algebraic data types also correspond to the algebraic structure called a ring. A ring has two operations, which are conventionally written</p>
    <p>and</p>
    <p>. You’ll perhaps guess that these correspond to sum and product types respectively, and you’d be absolutely correct. What about the properties of these operations? We’ll they are similar to what we know from basic algebra:</p>
    <ul>
      <li>
        <p>and</p>
        <p>are associative, so</p>
        <p>and likewise for</p>
        <p>;</p>
      </li>
      <li>
        <p>, known as commutivitiy;</p>
      </li>
      <li>
        <p>there is an identity</p>
        <p>such that</p>
        <p>;</p>
      </li>
      <li>
        <p>there is an identity</p>
        <p>such that</p>
        <p>;</p>
      </li>
      <li>
        <p>there is distribution, so that</p>
      </li>
    </ul>
    <p>So far, so abstract. Let’s make it concrete by looking at actual examples in Scala.</p>
    <p>Remember the algebraic data types work with types, so the operations</p>
    <p>and</p>
    <p>take types as parameters. So</p>
    <p>is equivalent to</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> IntAndString</span>(int: <span style="color: #d73948">Int</span>, string: <span style="color: #4b69c6">String</span>)</code></pre>
    <p>We can use tuples to avoid creating lots of names.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">IntAndString</span> <span style="color: #d73948">= </span>(<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>)</code></pre>
    <p>We can do the same thing for</p>
    <p>.</p>
    <p>is</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">IntOrString</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">IsInt</span>(int: <span style="color: #d73948">Int</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">IsString</span>(string: <span style="color: #4b69c6">String</span>)<br>}</code></pre>
    <p>or just</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">IntOrString</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>]</code></pre>
    <h5>Exercise: Identities</h5>
    <p>Can you work out which Scala type corresponds to the identity</p>
    <p>for product types?</p>
    <p>What about the Scala type corresponding to the identity</p>
    <p>for sum types?</p>
    <p>What about the distribution law? This allows us to manipulate algebraic data types to form equivalent, but perhaps more useful, representations. Consider this example of a user data type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Person</span>(name: <span style="color: #4b69c6">String</span>, permissions: <span style="color: #4b69c6">Permissions</span>)<br>enum <span style="color: #4b69c6">Permissions</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">User</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Moderator</span><br>}</code></pre>
    <p>Written in mathematical notation, this is</p>
    <p>Performing substitution gets us</p>
    <p>Applying distribution results in</p>
    <p>which in Scala we can represent as</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Person</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">User</span>(name: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Moderator</span>(name: <span style="color: #4b69c6">String</span>)<br>}</code></pre>
    <p>Is this representation more useful? I can’t say without the context of where the data is being used. However I can say that knowing this manipulation is possible, and correct, is useful.</p>
    <p>There is a lot more that could be said about algebraic data types, but at this point I feel we’re really getting into the weeds. I’ll finish up with a few pointers to other interesting facts:</p>
    <ul>
      <li>
        <p>Exponential types exist. They are functions! A function <code>A => B</code> is equivalent to</p>
        <p>.</p>
      </li>
      <li>Quotient types also exist, but they are a bit weird. Read up about them if you’re interested.</li>
      <li>Another interesting algebraic manipulation is taking the derivative of an algebraic data type. This gives us a kind of iterator, known as a zipper, for that type.</li>
    </ul>
    <h3 id="loc-69">3.6. Conclusions</h3>
    <p>We have covered a lot of material in this chapter. Let’s recap the key points.</p>
    <p>Algebraic data types allow us to express data types by combining existing data types with logical and and logical or. A logical and constructs a product type while a logical or constructs a sum type. Algebraic data types are the main way to represent data in Scala.</p>
    <p>Structural recursion gives us a skeleton for transforming any given algebraic data type into any other type. Structural recursion can be abstracted into a <code>fold</code> method.</p>
    <p>We use several reasoning principles to help us complete the problem specific parts of a structural recursion:</p>
    <ol>
      <li>reasoning independently by case;</li>
      <li>assuming recursion is correct; and</li>
      <li>following the types.</li>
    </ol>
    <p>Following the types is a very general strategy that is can be used in many other situations.</p>
    <p>Structural corecursion gives us a skeleton for creating any given algebraic data type from any other type. Structural corecursion can be abstracted into an <code>unfold</code> method. When reasoning about structural corecursion we can reason as we would for an imperative loop, or, if the input is an algebraic data type, use the principles for reasoning about structural recursion.</p>
    <p>Notice that the two main themes of functional programming—composition and reasoning—are both already apparent. Algebraic data types are compositional: we compose algebraic data types using sum and product. We’ve seen many reasoning principles in this chapter.</p>
    <p>I haven’t covered everything there is to know about algebraic data types; I think doing so would be a book in its own right. Below are some references that you might find useful if you want to dig in further, as well as some biographical remarks.</p>
    <p>Algebraic data types are standard in introductory material on functional programming. Structural recursion is certainly extremely common in functional programming, but strangely seems to rarely be explicitly defined as I’ve done here. I learned about both from <a href="#loc-503" role="doc-biblioref"><em>How to Design Programs</em> [27</a>].</p>
    <p>I’m not aware of any approachable yet thorough treatment of either algebraic data types or structural recursion. Both seem to have become assumed background of any researcher in the field of programming languages, and relatively recent work is caked in layers of mathematics and obtuse notation that I find difficult reading. The infamous <a id="loc-70" href="#loc-532" role="doc-biblioref"><em>Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</em> [56</a>] is an example of such work. I suspect the core ideas of both date back to at least the emergence of computability theory in the 1930s, well before any digital computers existed.</p>
    <p>The earliest reference I’ve found to structural recursion is <a id="loc-71" href="#loc-485" role="doc-biblioref"><em>Proving Properties of Programs by Structural Induction</em> [9</a>]. Algebraic data types don’t seem to have been fully developed, along with pattern matching, until <a href="https://en.wikipedia.org/wiki/NPL_(programming_language)">NPL<a id="loc-72" href="#loc-592" role="doc-noteref"><sup>19</sup></a></a> in 1977. NPL was quickly followed by the more influential language <a href="https://en.wikipedia.org/wiki/Hope_(programming_language)">Hope<a id="loc-73" href="#loc-593" role="doc-noteref"><sup>20</sup></a></a>, which spread the concept to other programming languages.</p>
    <p>Corecursion is a bit better documented in the contemporary literature. <a id="loc-74" href="#loc-511" role="doc-biblioref"><em>How to Design Co-Programs</em> [35</a>] covers the main ideas we have looked at here, while <a id="loc-75" href="#loc-508" role="doc-biblioref"><em>The Under-appreciated Unfold</em> [32</a>] discusses uses of <code>unfold</code>.</p>
    <p><a id="loc-76" href="#loc-531" role="doc-biblioref"><em>The Derivative of a Regular Type is its Type of One-Hole Contexts</em> [55</a>] describes the derivative of algebraic data types.</p>
    <h2 id="loc-77">4. Objects as Codata</h2>
    <p>In this chapter we will look at <strong>codata</strong>, the dual of algebraic data types. Algebraic data types focus on how things are constructed. Codata, in contrast, focuses on how things are used. We define codata by specifying the operations that can be performed on the type. This is very similar to the use of interfaces in object-oriented programming, and this is the first reason that we are interested in codata: codata puts object-oriented programming into a coherent conceptual framework with the other strategies we are discussing.</p>
    <p>We’re not only interested in codata as a lens to view object-oriented programming. Codata also has properties that algebraic data does not. Codata allows us to create structures with an infinite number of elements, such as a list that never ends or a server loop that runs indefinitely. Codata has a different form of extensibility to algebraic data. Whereas we can easily write new functions that transform algebraic data, we cannot add new cases to the definition of an algebraic data type without changing the existing code. The reverse is true for codata. We can easily create new implementations of codata, but functions that transform codata are limited by the interface the codata defines.</p>
    <p>In the previous chapter we saw structural recursion and structural corecursion as strategies to guide us in writing programs using algebraic data types. The same holds for codata. We can use codata forms of structural recursion and corecursion to guide us in writing programs that consume and produce codata respectively.</p>
    <p>We’ll begin our exploration of codata by more precisely defining it and seeing some examples. We’ll then talk about representing codata in Scala, and the relationship to object-oriented programming. Once we can create codata, we’ll see how to work with it using structural recursion and corecursion, using an example of an infinite structure. Next we will look at transforming algebraic data to codata, and vice versa. We will finish by examining differences in extensibility.</p>
    <p>A quick note about terminology before we proceed. We might expect to use the term algebraic codata for the dual of algebraic data, but conventionally just codata is used. I assume this is because data is usually understood to have a wider meaning than just algebraic data, but codata is not used outside of programming language theory. For simplicity and symmetry, within this chapter I’ll just use the term data to refer to algebraic data types.</p>
    <h3 id="loc-78">4.1. Data and Codata</h3>
    <p>Data describes what things are, while codata describes what things can do.</p>
    <p>We have seen that data is defined in terms of constructors producing elements of the data type. Let’s take a very simple example: a <code>Bool</code> is either <code>True</code> or <code>False</code>. We know we can represent this in Scala as</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Bool</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">True</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">False</span><br>}</code></pre>
    <p>The definition tells us there are two ways to construct an element of type <code>Bool</code>. Furthermore, if we have such an element we can tell exactly which case it is, by using a pattern match for example. Similarly, if the instances themselves hold data, as in <code>List</code> for example, we can always extract all the data within them. Again, we can use pattern matching to achieve this.</p>
    <p>Codata, in contrast, is defined in terms of operations we can perform on the elements of the type. These operations are sometimes called <strong>destructors</strong> (which we’ve already encountered), <strong>observations</strong>, or <strong>eliminators</strong>. A common example of codata is a data structure such as a set. We might define the operations on a <code>Set</code> with elements of type <code>A</code> as:</p>
    <ul>
      <li><code>contains</code>, which takes a <code>Set[A]</code> and an element <code>A</code> and returns a <code>Boolean</code> indicating if the set contains the element;</li>
      <li><code>insert</code>, which takes a <code>Set[A]</code> and an element <code>A</code> and returns a <code>Set[A]</code> containing all the elements from the original set and the new element; and</li>
      <li><code>union</code>, which takes a <code>Set[A]</code> and a set <code>Set[A]</code> and returns a <code>Set[A]</code> containing all the elements of both sets.</li>
    </ul>
    <p>In Scala we could implement this definition as</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Set</span>[<span style="color: #4b69c6">A</span>] {<br>  <br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> True if this set contains the given element </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Construct a new set containing all elements in this set and the given element </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Construct the union of this and that set </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>This definition does not tell us anything about the internal representation of the elements in the set. It could use a hash table, a tree, or something more exotic. It does, however, tell us what we can do with the set. We know we can take the union but not the intersection, for example.</p>
    <p>If you come from the object-oriented world you might recognize the description of codata above as programming to an interface. In some ways codata is just taking concepts from the object-oriented world and presenting them in a way that is consistent with the rest of the functional programming paradigm. However, this does not mean adopting all the features of object-oriented programming. We won’t use state, which is difficult to reason about. We also won’t use implementation inheritance either, for the same reason. In our subset of object-oriented programming we’ll either be defining interfaces (which may have default implementations of some methods) or final classes that implement those interfaces. Interestingly, this subset of object-oriented programming is often recommended by advocates of object-oriented programming<a id="loc-79" href="#loc-594" role="doc-noteref"><sup>21</sup></a>.</p>
    <p>Let’s now be a little more precise in our definition of codata, which will make the duality between data and codata clearer. Remember the definition of data: it is defined in terms of sums (logical ors) and products (logical ands). We can transform any data into a sum of products, which is disjunctive normal form. Each product in the sum is a constructor, and the product itself is the parameters that the constructor accepts. Finally, we can think of constructors as functions which take some arbitrary input and produce an element of data. Our end point is a sum of functions from arbitrary input to data.</p>
    <p>More concretely, if we are constructing an element of some data type <code>A</code> we call one of the constructors</p>
    <ul>
      <li><code>A1: (B, C, ...) => A</code>; or</li>
      <li><code>A2: (D, E, ...) => A</code>; or</li>
      <li><code>A3: (F, G, ...) => A</code>; and so on.</li>
    </ul>
    <p>Now we’ll turn to codata. Codata is defined as a product of functions, these functions being the destructors. The input to a destructor is always an element of the codata type and possibly some other parameters. The output is usually something that is not of the codata type. Thus constructing an element of some codata type <code>A</code> means defining</p>
    <ul>
      <li><code>A1: (A, B, ...) => C</code>; and</li>
      <li><code>A2: (A, D, ...) => E</code>; and</li>
      <li><code>A3: (A, F, ...) => G</code>; and so on.</li>
    </ul>
    <p>This hopefully makes the duality between the two clearer.</p>
    <p>Now we understand what codata is, we will turn to representing codata in Scala.</p>
    <h3 id="loc-80">4.2. Codata in Scala</h3>
    <p>We have already seen an example of codata, which I have repeated below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Set</span>[<span style="color: #4b69c6">A</span>] {<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>The abstract definition of this, which is a product of functions, defines a <code>Set</code> with elements of type <code>A</code> as:</p>
    <ul>
      <li>a function <code>contains</code> taking a <code>Set[A]</code> and an element <code>A</code> and returning a <code>Boolean</code>,</li>
      <li>a function <code>insert</code> taking a <code>Set[A]</code> and an element <code>A</code> and returning a <code>Set[A]</code>, and</li>
      <li>a function <code>union</code> taking a <code>Set[A]</code> and a set <code>Set[A]</code> and returning a <code>Set[A]</code>.</li>
    </ul>
    <p>Notice that the first parameter of each function is the type we are defining, <code>Set[A]</code>.</p>
    <p>The translation to Scala is:</p>
    <ul>
      <li>the overall type becomes a <code>trait</code>; and</li>
      <li>each function becomes a method on that <code>trait</code>. The first parameter is the hidden <code>this</code> parameter, and other parameters become normal parameters to the method.</li>
    </ul>
    <p>This gives us the Scala representation we started with.</p>
    <p>This is only half the story for codata. We also need to actually implement the interface we’ve just defined. There are three approaches we can use:</p>
    <ol>
      <li>a <code>final</code> subclass, in the case where we want to name the implementation;</li>
      <li>an anonymous subclass; or</li>
      <li>more rarely, an <code>object</code>.</li>
    </ol>
    <p>Neither <code>final</code> nor anonymous subclasses can be further extended, meaning we cannot create deep inheritance hierarchies. This in turn avoids the difficulties that come from reasoning about deep hierarchies. Using a <code>class</code> rather than a <code>case class</code> means we don’t expose implementation details like constructor arguments.</p>
    <p>Some examples are in order. Here’s a simple example of <code>Set</code>, which uses a <code>List</code> to hold the elements in the set.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> ListSet</span>[<span style="color: #4b69c6">A</span>](elements: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Set</span>[<span style="color: #4b69c6">A</span>] {<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>    elements.contains(elt)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">ListSet</span>(elt :: elements)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    elements.foldLeft(that) { (set, elt) <span style="color: #d73948">=></span> set.insert(elt) }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> ListSet</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>[<span style="color: #4b69c6">A</span>]: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">ListSet</span>(<span style="color: #4b69c6">List</span>.empty)<br>}</code></pre>
    <p>This uses the first implementation approach, a <code>final</code> subclass. Where would we use an anonymous subclass? They are most useful when implementing methods that return our codata type. Let’s take <code>union</code> as an example. It returns our codata type, <code>Set</code>, and we could implement it as shown below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Set</span>[<span style="color: #4b69c6">A</span>] {<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>        self.contains(elt) || that.contains(elt)<br>        <br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>        <span style="color: #74747c">//</span><span style="color: #74747c"> Arbitrary choice to insert into self</span><br>        self.insert(elt).union(that)<br>    }<br>  }<br>}</code></pre>
    <p>This uses an anonymous subclass to implement <code>union</code> on the <code>Set</code> trait, and hence defines the method for all subclasses. I haven’t made the method <code>final</code> so that subclasses can override it with a more efficient implementation. This does open up the danger of implementation inheritance. This is an example of where theory and craft diverge. In theory we never want implementation inheritance, but in practice it can be useful as an optimization.</p>
    <p>It can also be useful to implement utility methods defined purely in terms of the destructors. Let’s say we wanted to implement a method <code>containsAll</code> that checks if a <code>Set</code> <code>contains</code> all the elements in an <code>Iterable</code> collection.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">containsAll</span>(elements: <span style="color: #4b69c6">Iterable</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #d73948">Boolean</span></code></pre>
    <p>We can implement this purely in terms of <code>contains</code> on <code>Set</code> and <code>forall</code> on <code>Iterable</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Set</span>[<span style="color: #4b69c6">A</span>] {<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">containsAll</span>(elements: <span style="color: #4b69c6">Iterable</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>    elements.forall(elt <span style="color: #d73948">=></span> <span style="color: #d73948">this</span>.contains(elt))<br>}</code></pre>
    <p>Once again we could make this a <code>final</code> method. In this case it’s probably more justified as it’s difficult to imagine a more efficient implementation.</p>
    <p>Data and codata are both realized in Scala as variations of the same language features of classes and objects. This means we can define types that have properties of both data and codata. We have actually already done this. When we define data we must define names for the fields within the data, thus defining destructors. Most languages are same, not making a hard distinction between data and codata.</p>
    <p>Part of the appeal, I think, of classes and objects is that they can express so many conceptually different abstractions with the same language constructs. This gives them a surface appearance of simplicity; it seems we need to learn only one abstraction to solve a huge of number of coding problems. However this apparent simplicity hides real complexity, as this variety of uses forces us to reverse engineer the conceptual intention from the code.</p>
    <h3 id="loc-81">4.3. Structural Recursion and Corecursion for Codata</h3>
    <p>In this section we’ll build a library for streams, also known as lazy lists. These are the codata equivalent of lists. Whereas a list must have a finite length, streams have an infinite length. We’ll use this example to explore structural recursion and structural corecursion as applied to codata.</p>
    <p>Let’s start by reviewing structural recursion and corecursion. The key idea is to use the input or output type, respectively, to drive the process of writing the method. We’ve already seen how this works with data, where we emphasized structural recursion. With codata it’s more often the case that structural corecursion is used. The steps for using structural corecursion are:</p>
    <ol>
      <li>recognize the output of the method or function is codata;</li>
      <li>write down the skeleton to construct an instance of the codata type, usually using an anonymous subclass; and</li>
      <li>fill in the methods, where strategies such as structural recursion or following the types can help.</li>
    </ol>
    <p>It’s important that all computations are defined within the methods, and so only run when the methods are called. Once we start creating streams the importance of this will become clear.</p>
    <p>For structural recursion the steps are:</p>
    <ol>
      <li>recognize the input of the method or function is codata;</li>
      <li>note the codata’s destructors as possible sources of values in writing the method; and</li>
      <li>complete the method, using strategies such as following the types or structural corecursion and the methods identified above.</li>
    </ol>
    <p>Now on to creating streams. Our first step is to define our stream type. As this is codata, it is defined in terms of its destructors. The destructors that define a <code>Stream</code> of elements of type <code>A</code> are:</p>
    <ul>
      <li>a <code>head</code> of type <code>A</code>; and</li>
      <li>a <code>tail</code> of type <code>Stream[A]</code>.</li>
    </ul>
    <p>Note these are almost the destructors of <code>List</code>. We haven’t defined <code>isEmpty</code> as a destructor because our streams never end and thus this method would always return <code>false</code><a id="loc-82" href="#loc-596" role="doc-noteref"><sup>22</sup></a>.</p>
    <p>We can translate this to Scala, as we’ve previously seen, giving us</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>Now we can create an instance of <code>Stream</code>. Let’s create a never-ending stream of ones. We will start with the skeleton below and apply strategies to complete the code.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ones: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span></code></pre>
    <p>The first strategy is structural corecursion. We’re returning an instance of codata, so we can insert the skeleton to construct a <code>Stream</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ones: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>  }</code></pre>
    <p>Here I’ve used the anonymous subclass approach, so I can just write all the code in one place.</p>
    <p>The next step is to fill in the method bodies. The first method, <code>head</code>, is trivial. The answer is <code>1</code> by definition.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ones: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>  }</code></pre>
    <p>It’s not so obvious what to do with <code>tail</code>. We want to return a <code>Stream[Int]</code> so we could apply structural corecursion again.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ones: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>      <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] {<br>        <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>        <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>      }<br>  }</code></pre>
    <p>This approach doesn’t seem like it’s going to work. We’ll have to write this out an infinite number of times to correctly implement the method, which might be a problem.</p>
    <p>Instead we can follow the types. We need to return a <code>Stream[Int]</code>. We have one in scope: <code>ones</code>. This is exactly the <code>Stream</code> we need to return: the infinite stream of ones!</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ones: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> ones<br>  }</code></pre>
    <p>You might be alarmed to see the circular reference to <code>ones</code> in <code>tail</code>. This works because it is within a method, and so is only evaluated when that method is called. This delaying of evaluation is what allows us to represent an infinite number of elements, as we only ever evaluate a finite portion of them. This is a core difference from data, which is fully evaluated when it is constructed.</p>
    <p>Let’s check that our definition of <code>ones</code> does indeed work. We can’t extract all the elements from an infinite <code>Stream</code> (at least, not in finite time) so in general we’ll have to resort to checking a finite sequence of elements.</p>
    <pre><code data-lang="scala">ones.head<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Int = 1</span><br>ones.tail.head<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Int = 1</span><br>ones.tail.tail.head<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Int = 1</span></code></pre>
    <p>This all looks correct. We’ll often want to check our implementation in this way, so let’s implement a method, <code>take</code>, to make this easier.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">take</span>(count: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    count <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Nil</span><br>      <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> head :: tail.take(n - <span style="color: #b60157">1</span>)<br>    }<br>}</code></pre>
    <p>We can use either the structural recursion or structural corecursion strategies for data to implement <code>take</code>. Since we’ve already covered these in detail I won’t go through them here. The important point is that <code>take</code> only uses the destructors when interacting with the <code>Stream</code>.</p>
    <p>Now we can more easily check our implementations are correct.</p>
    <pre><code data-lang="scala">ones.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: List[Int] = List(1, 1, 1, 1, 1)</span></code></pre>
    <p>For our next task we’ll implement <code>map</code>. Implementing a method on <code>Stream</code> allows us to see both structural recursion and corecursion for codata in action. As usual we begin by writing out the method skeleton.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>Now we have a choice of strategy to use. Since we haven’t used structural recursion yet, let’s start with that. The input is codata, a <code>Stream</code>, and the structural recursion strategy tells us we should consider using the destructors. Let’s write them down to remind us of them.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">this</span>.head <span style="color: #d73948">???</span><br>    <span style="color: #d73948">this</span>.tail <span style="color: #d73948">???</span><br>  }<br>}</code></pre>
    <p>To make progress we can follow the types or use structural corecursion. Let’s choose corecursion to see another example of it in use.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">this</span>.head <span style="color: #d73948">???</span><br>    <span style="color: #d73948">this</span>.tail <span style="color: #d73948">???</span><br>    <br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>    }<br>  }<br>}</code></pre>
    <p>Now we’ve used structural recursion and structural corecursion, a bit of following the types is in order. This quickly arrives at the correct solution.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span> <br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span> f(self.head)<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> self.tail.map(f)<br>    }<br>  }<br>}</code></pre>
    <p>There are two important points. Firstly, notice how I gave the name <code>self</code> to <code>this</code>. This is so I can access the value inside the new <code>Stream</code> we are creating, where <code>this</code> would be bound to this new <code>Stream</code>. Next, notice that we access <code>self.head</code> and <code>self.tail</code> inside the methods on the new <code>Stream</code>. This maintains the correct semantics of only performing computation when it has been asked for. If we perform computation outside of the methods we create the possibility of infinite loops.</p>
    <p>As our final example, let’s return to constructing <code>Stream</code>, and implement the universal constructor <code>unfold</code>. We start with the skeleton for <code>unfold</code>, remembering the <code>seed</code> parameter.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Stream</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>It’s natural to apply structural corecursion to make progress.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Stream</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>]{<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>    }<br>}</code></pre>
    <p>Now we can follow the types, adding parameters as we need them. This gives us the complete method shown below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Stream</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">unfold</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, next: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>]{<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span> <br>        f(seed)<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <br>        unfold(next(seed), f, next)<br>    }<br>}</code></pre>
    <p>We can use this to implement some interesting streams. Here’s a stream that alternates between <code>1</code> and <code>-1</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> alternating <span style="color: #d73948">=</span> <span style="color: #4b69c6">Stream</span>.unfold(<br>  <span style="color: #d73948">true</span>, <br>  x <span style="color: #d73948">=></span> <span style="color: #d73948">if</span> x then <span style="color: #b60157">1</span> <span style="color: #d73948">else</span> -<span style="color: #b60157">1</span>, <br>  x <span style="color: #d73948">=></span> !x<br>)</code></pre>
    <p>We can check it works.</p>
    <pre><code data-lang="scala">alternating.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: List[Int] = List(1, -1, 1, -1, 1)</span></code></pre>
    <h5>Exercise: Stream Combinators</h5>
    <p>It’s time for you to get some practice with structural recursion and structural corecursion using codata. Implement <code>filter</code>, <code>zip</code>, and <code>scanLeft</code> on <code>Stream</code>. They have the same semantics as the same methods on <code>List</code>, and the signatures shown below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Stream</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">filter</span>(pred: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">zip</span>[<span style="color: #4b69c6">B</span>](that: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Stream</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">scanLeft</span>[<span style="color: #4b69c6">B</span>](zero: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">B</span>, <span style="color: #4b69c6">A</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>]<br>}</code></pre>
    <p>We can do some neat things with the methods defined above. For example, here is the stream of natural numbers.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> naturals <span style="color: #d73948">=</span> <span style="color: #4b69c6">Stream</span>.ones.scanLeft(<span style="color: #b60157">0</span>)((b, a) <span style="color: #d73948">=></span> b + a)</code></pre>
    <p>As usual, we should check it works.</p>
    <pre><code data-lang="scala">naturals.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res15: List[Int] = List(0, 1, 2, 3, 4)</span></code></pre>
    <p>We could also define <code>naturals</code> using <code>unfold</code>. More interesting is defining it in terms of itself.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> naturals: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Int</span>] =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span> <span style="color: #d73948">=</span> naturals.map(<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>)<br>  }</code></pre>
    <p>This might be confusing. If so, spend a bit of time thinking about it. It really does work!</p>
    <pre><code data-lang="scala">naturals.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res17: List[Int] = List(1, 2, 3, 4, 5)</span></code></pre>
    <h4 id="loc-83">4.3.1. Efficiency and Effects</h4>
    <p>You may have noticed that our implement recomputes values, possibly many times. A good example is the implementation of <code>filter</code>. This recalculates the <code>head</code> and <code>tail</code> on each call, which could be a very expensive operation.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">filter</span>(pred: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(stream: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>        <span style="color: #d73948">if</span> pred(stream.head) then stream.head<br>        <span style="color: #d73948">else</span> loop(stream.tail)<br>        <br>      loop(self)<br>    }<br>    <br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">tail</span>: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(stream: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>        <span style="color: #d73948">if</span> pred(stream.head) then stream.tail.filter(pred)<br>        <span style="color: #d73948">else</span> loop(stream.tail)<br>        <br>      loop(self)<br>    }<br>  }<br>}</code></pre>
    <p>We know that delaying the computation until the method is called is important, because that is how we can handle infinite and self-referential data. However we don’t need to redo this computation on successive calls. We can instead cache the result from the first call and use that next time. Scala makes this easy with <code>lazy val</code>, which is a <code>val</code> that is not computed until its first call. Additionally, Scala’s use of the <strong>uniform access principle</strong> means we can implement a method with no parameters using a <code>lazy val</code>. Here’s a quick example demonstrating it in use.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">always</span>[<span style="color: #4b69c6">A</span>](elt: <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] {<br>    <span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> head: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> elt<br>    <span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> tail: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> always(head)<br>  }<br>  <br><span style="color: #d73948">val</span> twos <span style="color: #d73948">=</span> always(<span style="color: #b60157">2</span>)</code></pre>
    <p>As usual we should check our work.</p>
    <pre><code data-lang="scala">twos.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res18: List[Int] = List(2, 2, 2, 2, 2)</span></code></pre>
    <p>We get the same result whether we use a method or a <code>lazy val</code>, because we are assuming that we are only dealing with pure computations that have no dependency on state that might change. In this case a <code>lazy val</code> simply consumes additional space to save on time.</p>
    <p>Recomputing a result every time it is needed is known as <strong>call-by-name</strong>, while caching the result the first time it is computed is known as <strong>call-by-need</strong>. These two different <strong>evaluation strategies</strong> can be applied to individual values, as we’ve done here, or across an entire programming. Haskell, for example, uses call-by-need; all values in Haskell are only computed the first time they are needed. call-by-need is also commonly known as <strong>lazy evaluation</strong>. Another alternative, called <strong>call-by-value</strong>, computes results when they are defined instead of waiting until they are needed. This is the default in Scala.</p>
    <p>We can illustrate the difference between call-by-name and call-by-need if we use an impure computation. For example, we can define a stream of random numbers. Random number generators depend on some internal state.</p>
    <p>Here’s the call-by-name implementation, using the methods we have already defined.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.util.Random<br><br><span style="color: #d73948">val</span> randoms: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span> <br>  <span style="color: #4b69c6">Stream</span>.unfold(<span style="color: #4b69c6">Random</span>, r <span style="color: #d73948">=></span> r.nextDouble(), r <span style="color: #d73948">=></span> r)</code></pre>
    <p>Notice that we get <em>different</em> results each time we <code>take</code> a section of the <code>Stream</code>. We would expect these results to be the same.</p>
    <pre><code data-lang="scala">randoms.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res19: List[Double] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.920201923216668,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.20820028255391054,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.8204156692178245,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.2289609606684302,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.18499934414625552</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br>randoms.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res20: List[Double] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.38827021726156163,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.28777643504981487,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.6382711497488422,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.10975282992922553,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.8661022092169123</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Now let’s define the same stream in a call-by-need style, using <code>lazy val</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> randomsByNeed: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Double</span>] =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Double</span>] {<br>    <span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> head: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Random</span>.nextDouble()<br>    <span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> tail: <span style="color: #4b69c6">Stream</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span> randomsByNeed<br>  }</code></pre>
    <p>This time we get the <em>same</em> result when we <code>take</code> a section, and each number is the same.</p>
    <pre><code data-lang="scala">randomsByNeed.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res21: List[Double] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br>randomsByNeed.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res22: List[Double] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.43395611985006044</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>If we wanted a stream that had a different random number for each element but those numbers were constant, we could redefine <code>unfold</code> to use call-by-need.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">unfoldByNeed</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](seed: <span style="color: #4b69c6">A</span>, f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, next: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>]{<br>    <span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> head: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span> <br>      f(seed)<br>    <span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> tail: <span style="color: #4b69c6">Stream</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <br>      unfoldByNeed(next(seed), f, next)<br>  }</code></pre>
    <p>Now redefining <code>randomsByNeed</code> using <code>unfoldByNeed</code> gives us the result we are after. First, redefine it.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> randomsByNeed2 <span style="color: #d73948">=</span><br>  unfoldByNeed(<span style="color: #4b69c6">Random</span>, r <span style="color: #d73948">=></span> r.nextDouble(), r <span style="color: #d73948">=></span> r)</code></pre>
    <p>Then check it works.</p>
    <pre><code data-lang="scala">randomsByNeed2.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res23: List[Double] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.12290009795690326,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.7915809437987975,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.8024560015560851,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.20463026555844588,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.20011519578000958</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br>randomsByNeed2.take(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res24: List[Double] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.12290009795690326,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.7915809437987975,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.8024560015560851,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.20463026555844588,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   0.20011519578000958</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>These subtleties are one of the reasons that functional programmers try to avoid using state as far as possible.</p>
    <h3 id="loc-84">4.4. Relating Data and Codata</h3>
    <p>In this section we’ll explore the relationship between data and codata, and in particular converting one to the other. We’ll look at it in two ways: firstly a very surface-level relationship between the two, and then a deep connection via <code>fold</code>.</p>
    <p>Remember that data is a sum of products, where the products are constructors and we can view constructors as functions. So we can view data as a sum of functions. Meanwhile, codata is a product of functions. We can easily make a direct correspondence between the functions-as-constructors and the functions in codata. What about the difference between the sum and the product that remains. Well, when we have a product of functions we only call one at any point in our code. So the logical or is in the choice of function to call.</p>
    <p>Let’s see how this works with a familiar example of data, <code>List</code>. As an algebraic data type we can define</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>])<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>}</code></pre>
    <p>The codata equivalent is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>In the codata implementation we are explicitly representing the constructors as methods, and pushing the choice of constructor to the caller. In a few chapters we’ll see a use for this relationship, but for now we’ll leave it and move on.</p>
    <p>The other way to view the relationship is a connection via <code>fold</code>. We’ve already learned how to derive the <code>fold</code> for any algebraic data type. For <code>Bool</code>, defined as</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Bool</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">True</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">False</span><br>}</code></pre>
    <p>the <code>fold</code> method is</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Bool</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">True</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">False</span><br>  <br>  <span style="color: #d73948">def</span> fold[<span style="color: #4b69c6">A</span>](t: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span> =<br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">True</span> <span style="color: #d73948">=></span> t<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">False</span> <span style="color: #d73948">=></span> f<br>    }<br>}</code></pre>
    <p>We know that <code>fold</code> is universal: we can write any other method in terms of it. It therefore provides a universal destructor and is the key to treating data as codata. This example of <code>fold</code> is something we use all the time, except we usually call it <code>if</code>.</p>
    <p>Here’s the codata version of <code>Bool</code>, with <code>fold</code> renamed to <code>if</code>. (Note that Scala allows us to define methods with the same name as key words, in this case <code>if</code>, but we have to surround them in backticks to use them.)</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Bool</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`if`</span>[<span style="color: #4b69c6">A</span>](t: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span><br>}</code></pre>
    <p>Now we can define the two instances of <code>Bool</code> purely as codata.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> True <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Bool</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`if`</span>[<span style="color: #4b69c6">A</span>](t: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> t<br>}<br><br><span style="color: #d73948">val</span> False <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Bool</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`if`</span>[<span style="color: #4b69c6">A</span>](t: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> f<br>}</code></pre>
    <p>Let’s see this in use by defining <code>and</code> in terms of <code>if</code>, and then creating some examples. First the definition of <code>and</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>(l: <span style="color: #4b69c6">Bool</span>, r: <span style="color: #4b69c6">Bool</span>): <span style="color: #4b69c6">Bool</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Bool</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">`if`</span>[<span style="color: #4b69c6">A</span>](t: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>      l.`if`(r)(<span style="color: #4b69c6">False</span>).`if`(t)(f)<br>  }</code></pre>
    <p>Now the examples. This is simple enough that we can try the entire truth table.</p>
    <pre><code data-lang="scala">and(<span style="color: #4b69c6">True</span>, <span style="color: #4b69c6">True</span>).`if`(<span style="color: #198810">"</span><span style="color: #198810">yes</span><span style="color: #198810">"</span>)(<span style="color: #198810">"</span><span style="color: #198810">no</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "yes"</span><br>and(<span style="color: #4b69c6">True</span>, <span style="color: #4b69c6">False</span>).`if`(<span style="color: #198810">"</span><span style="color: #198810">yes</span><span style="color: #198810">"</span>)(<span style="color: #198810">"</span><span style="color: #198810">no</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "no"</span><br>and(<span style="color: #4b69c6">False</span>, <span style="color: #4b69c6">True</span>).`if`(<span style="color: #198810">"</span><span style="color: #198810">yes</span><span style="color: #198810">"</span>)(<span style="color: #198810">"</span><span style="color: #198810">no</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "no"</span><br>and(<span style="color: #4b69c6">False</span>, <span style="color: #4b69c6">False</span>).`if`(<span style="color: #198810">"</span><span style="color: #198810">yes</span><span style="color: #198810">"</span>)(<span style="color: #198810">"</span><span style="color: #198810">no</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: String = "no"</span></code></pre>
    <h5>Exercise: Or and Not</h5>
    <p>Test your understanding of <code>Bool</code> by implementing <code>or</code> and <code>not</code> in the same way we implemented <code>and</code> above.</p>
    <p>Notice that, once again, computation only happens on demand. In this case, nothing happens until <code>if</code> is actually called. Until that point we’re just building up a representation of what we want to happen. This again points to how codata can handle infinite data, by only computing the finite amount required by the actual computation.</p>
    <p>The rules here for converting from data to codata are:</p>
    <ol>
      <li>On the interface (<code>trait</code>) defining the codata, define a method with the same signature as <code>fold</code>.</li>
      <li>Define an implementation of the interface for each product case in the data. The data’s constructor arguments become constructor arguments on the codata <code>classes</code>. If there are no constructor arguments, as in <code>Bool</code>, we can define values instead of classes.</li>
      <li>Each implementation implements the case of <code>fold</code> that it corresponds to.</li>
    </ol>
    <p>Let’s apply this to a slightly more complex example: <code>List</code>. We’ll start by defining it as data and implementing <code>fold</code>. I’ve chosen to implement <code>foldRight</code> but <code>foldLeft</code> would be just as good.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>])<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <br>  <span style="color: #d73948">def</span> foldRight[<span style="color: #4b69c6">B</span>](empty: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> =<br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> { <br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> f(head, tail.foldRight(empty)(f))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> empty<br>    }<br>}</code></pre>
    <p>Now let’s implement it as codata. We start by defining the interface with the <code>fold</code> method. In this case I’m calling it <code>foldRight</code> as it’s going to exactly mirror the <code>foldRight</code> we just defined.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">B</span>](empty: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span><br>}</code></pre>
    <p>Now we define the implementations. There is one for <code>Pair</code> and one for <code>Empty</code>, which are the two cases in data definition of <code>List</code>. Notice that in this case the classes have constructor arguments, which correspond to the constructor arguments on the correspnding product types.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Pair</span>[<span style="color: #4b69c6">A</span>](head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">B</span>](empty: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Empty</span>[<span style="color: #4b69c6">A</span>]() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">B</span>](empty: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>I didn’t implement the bodies of<code> foldRight</code> so I could show this as a separate step. The implementation here directly mirrors <code>foldRight</code> on the data implementation, and we can use the same strategies to implement the codata equivalents. That is to say, we can use the recursion rule, reasoning by case, and following the types. I’m going to skip these details as we’ve already gone through them in depth. The final code is shown below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Pair</span>[<span style="color: #4b69c6">A</span>](head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">B</span>](empty: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>    f(head, tail.foldRight(empty)(f))<br>}<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Empty</span>[<span style="color: #4b69c6">A</span>]() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">B</span>](empty: <span style="color: #4b69c6">B</span>)(f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>    empty<br>}</code></pre>
    <p>This code is almost the same as the dynamic dispatch implementation, which again shows the relationship between codata and object-oriented code.</p>
    <p>The transformation from data to codata goes under several names: <strong>refunctionalization</strong>, <strong>Church encoding</strong>, and <strong>Böhm-Berarducci encoding</strong>. The latter two terms specifically refer to transformations into the untyped and typed lambda calculus respectively. The lambda calculus is a simple model programming language that contains only functions. We’re going to take a quick detour to show that we can, indeed, encode lists using just functions. This demonstrates that objects and functions have equivalent power.</p>
    <p>The starting point is creating a type alias <code>List</code>, which defines a list as a fold. This uses a polymorphic function type, which is new in Scala 3. Inspect the type signature and you’ll see it is the same as <code>foldRight</code> above.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">= </span>(<span style="color: #4b69c6">B</span>, (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span></code></pre>
    <p>Now we can define <code>Pair</code> and <code>Empty</code> as functions. The first parameter list is the constructor arguments, and the second parameter list is the parameters for <code>foldRight</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> Empty: [<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=></span> () <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <br>  [<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span>> () <span style="color: #d73948">=></span> (empty, f) <span style="color: #d73948">=></span> empty<br><br><span style="color: #d73948">val</span> Pair: [<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=></span> (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>]) <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] =<br>  [<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span>> (head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>]) <span style="color: #d73948">=></span> (empty, f) <span style="color: #d73948">=></span> <br>    f(head, tail(empty, f))</code></pre>
    <p>Finally, let’s see an example to show it working. We will first define the list containing <code>1</code>, <code>2</code>, <code>3</code>. Due to a restriction in polymorphic function types, I have to add the useless empty parameter.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> list: [<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=></span> () <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <br>  [<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span>> () <span style="color: #d73948">=></span> <span style="color: #4b69c6">Pair</span>(<span style="color: #b60157">1</span>, <span style="color: #4b69c6">Pair</span>(<span style="color: #b60157">2</span>, <span style="color: #4b69c6">Pair</span>(<span style="color: #b60157">3</span>, <span style="color: #4b69c6">Empty</span>())))</code></pre>
    <p>Now we can compute the sum and product of the elements in this list.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> sum <span style="color: #d73948">=</span> list()(<span style="color: #b60157">0</span>, (a, b) <span style="color: #d73948">=></span> a + b)<br><span style="color: #74747c">//</span><span style="color: #74747c"> sum: Int = 6</span><br><span style="color: #d73948">val</span> product <span style="color: #d73948">=</span> list()(<span style="color: #b60157">1</span>, (a, b) <span style="color: #d73948">=></span> a * b)<br><span style="color: #74747c">//</span><span style="color: #74747c"> product: Int = 6</span></code></pre>
    <p>It works!</p>
    <p>The purpose of this little demonstration is to show that functions are just objects (in the codata sense) with a single method. Scala this makes apparent, as functions <em>are</em> objects with an <code>apply</code> method.</p>
    <p>We’ve seen that data can be translated to codata. The reverse is also possible: we simply tabulate the results of each possible method call. In other words, the data representation is memoisation, a lookup table, or a cache.</p>
    <p>Although we can convert data to codata and vice versa, there are good reasons to choose one over the other. We’ve already seen one reason: with codata we can represent infinite structures. In this next section we’ll see another difference: the extensibility that data and codata permit.</p>
    <h3 id="loc-85">4.5. Data and Codata Extensibility</h3>
    <p>We have seen that codata can represent types with an infinite number of elements, such as <code>Stream</code>. This is one expressive difference from data, which must always be finite. We’ll now look at another, which is the type of extensibility we get from data and from codata. Together these gives use guidelines to choose between the two.</p>
    <p>Firstly, let’s define extensibility. It means the ability to add new features without modifying existing code. (If we allow modification of existing code then any extension becomes trivial.) In particular there are two dimensions along which we can extend code: adding new functions or adding new elements. We will see that data and codata have orthogonal extensibility: it’s easy to add new functions to data but adding new elements is impossible without modifying existing code, while adding new elements to codata is straight-forward but adding new functions is not.</p>
    <p>Let’s start with a concrete example of both data and codata. For data we’ll use the familiar <code>List</code> type.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>()<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head: <span style="color: #4b69c6">A</span>, tail: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>])<br>}</code></pre>
    <p>For codata, we’ll use <code>Set</code> as our exemplar.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Set</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>We know there are lots of methods we can define on <code>List</code>. The standard library is full of them! We also know that any method we care to write can be written using structural recursion. Finally, we can write these methods without modifying existing code.</p>
    <p>Imagine <code>filter</code> was not defined on <code>List</code>. We can easily implement it as</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> List.*<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">filter</span>[<span style="color: #4b69c6">A</span>](list: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>], pred: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span>()<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <br>      <span style="color: #d73948">if</span> pred(head) then <span style="color: #4b69c6">Pair</span>(head, filter(tail, pred))<br>      <span style="color: #d73948">else</span> filter(tail, pred)<br>  }</code></pre>
    <p>We could even use an extension method to make it appear as a normal method.</p>
    <pre><code data-lang="scala">extension [<span style="color: #4b69c6">A</span>](list: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">filter</span>(pred: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <br>    list <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span>()<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pair</span>(head, tail) <span style="color: #d73948">=></span> <br>        <span style="color: #d73948">if</span> pred(head) then <span style="color: #4b69c6">Pair</span>(head, tail.filter(pred))<br>        <span style="color: #d73948">else</span> tail.filter(pred)<br>    }<br>}</code></pre>
    <p>This shows we can add new functions to data without issue.</p>
    <p>What about adding new elements to data? Perhaps we want to add a special case to optimize single-element lists. This is impossible without changing existing code. By definition, we cannot add a new element to an <code>enum</code> without changing the <code>enum</code>. Adding such a new element would break all existing pattern matches, and so require they all change. So in summary we can add new functions to data, but not new elements.</p>
    <p>Now let’s look at codata. This has the opposite extensibility; duality strikes again! In the codata case we can easily add new elements. We simply implement the <code>trait</code> that defines the codata interface. We saw this when we defined, for example, <code>ListSet</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> ListSet</span>[<span style="color: #4b69c6">A</span>](elements: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Set</span>[<span style="color: #4b69c6">A</span>] {<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>    elements.contains(elt)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">ListSet</span>(elt :: elements)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    elements.foldLeft(that) { (set, elt) <span style="color: #d73948">=></span> set.insert(elt) }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> ListSet</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>[<span style="color: #4b69c6">A</span>]: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">ListSet</span>(<span style="color: #4b69c6">List</span>.empty)<br>}</code></pre>
    <p>What about adding new functionality? If the functionality can be defined in terms of existing functionality then we’re ok. We can easily define this functionality, and we can use the extension method trick to make it appear like a built-in. However, if we want to define a function that cannot be expressed in terms of existing functions we are out of luck. Let’s saw we want to define some kind of iterator over the elements of a <code>Set</code>. We might use a <code>LazyList</code>, the standard library’s equivalent of <code>Stream</code> we defined earlier, because we know some sets have an infinite number of elements. Well, we can’t do this without changing the definition of <code>Set</code>, which in turn breaks all existing implementations. We cannot define it in a different way because we don’t know all the possible implementations of <code>Set</code>.</p>
    <p>So in summary we can add new elements to codata, but not new functions.</p>
    <p>If we tabulate this we clearly see that data and codata have orthogonal extensibility.</p>
    <p>This difference in extensibility gives us another rule for choosing between data and codata as an implementation strategy, in addition to the finite vs infinite distinction we saw earlier. If we want extensibilty of functions but not elements we should use data. If we have a fixed interface but an unknown number of possible implementations we should use codata.</p>
    <p>You might wonder if we can have both forms of extensibility. Achieving this is called the <strong>expression problem</strong>. There are various ways to solve the expression problem, and we’ll see one that works particularly well in Scala in <a href="#loc-367">Chapter 15</a>.</p>
    <h5>Exercise: Sets</h5>
    <p>In this extended exercise we’ll explore the <code>Set</code> interface we have already used in several examples, reproduced below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Set</span>[<span style="color: #4b69c6">A</span>] {<br>  <br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> True if this set contains the given element </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Construct a new set containing the given element </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Construct the union of this and that set </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>We also saw a simple implementation, storing the elements in the set in a <code>List</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> ListSet</span>[<span style="color: #4b69c6">A</span>](elements: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Set</span>[<span style="color: #4b69c6">A</span>] {<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>    elements.contains(elt)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">insert</span>(elt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">ListSet</span>(elt :: elements)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">union</span>(that: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    elements.foldLeft(that) { (set, elt) <span style="color: #d73948">=></span> set.insert(elt) }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> ListSet</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>[<span style="color: #4b69c6">A</span>]: <span style="color: #4b69c6">Set</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">ListSet</span>(<span style="color: #4b69c6">List</span>.empty)<br>}</code></pre>
    <p>The implementation for <code>union</code> is a bit unsatisfactory; it’s doesn’t use any of our strategies for writing code. We can implement both <code>union</code> and <code>insert</code> in a generic way that works for <em>all</em> sets (in other words, is implemented on the <code>Set</code> trait) and uses the strategies we’ve seen in this chapter. Go ahead and do this.</p>
    <p>Your next challenge is to implement <code>Evens</code>, the set of all even integers, which we’ll represent as a <code>Set[Int]</code>. This is an infinite set; we cannot directly enumerate all the elements in this set. (We actually could enumerate all the even elements that are 32-bit <code>Ints</code>, but we don’t want to as this would use excessive amounts of space.)</p>
    <p>We can generalize this idea to defining sets in terms of <strong>indicator functions</strong>, which is a function of type <code>A => Boolean</code>, returning returns true if the input belows to the set. Implement <code>IndicatorSet</code>, which is constructed with a single indicator function parameter.</p>
    <h3 id="loc-86">4.6. Conclusions</h3>
    <p>In this chapter we’ve explored codata, the dual of data. Codata is defined by its interface—what we can do with it—as opposed to data, which is defined by what it is. More formally, codata is a product of destructors, where destructors are functions from the codata type (and, optionally, some other inputs) to some type. By avoiding the elements of object-oriented programming that make it hard to reason about—state and implementation inheritance—codata brings elements of object-oriented programming that accord with the other functional programming strategies. In Scala we define codata as a <code>trait</code>, and implement it as a <code>final class</code>, anonymous subclass, or an object.</p>
    <p>We have two strategies for implementing methods using codata: structural corecursion, which we can use when the result is codata, and structural recursion, which we can use when an input is codata. Structural corecursion is usually the more useful of the two, as it gives more structure (pun intended) to the method we are implementing. The reverse is true for data.</p>
    <p>We saw that data is connected to codata via fold: any data can instead be implemented as codata with a single destructor that is the fold for that data. The reverse is also: we can enumerate all potential pairs of inputs and outputs of destructors to represent codata as data. However this does not mean that data and codata are equivalent. We have seen many examples of codata representing infinite structures, such as sets of all even numbers and streams of all natural numbers. We have also seen that data and codata offer different forms of extensibility: data makes it easy to add new functions, but adding new elements requires changing existing code, while it is easy to add new elements to codata but we change existing code if we add new functions.</p>
    <p><a id="loc-87" href="#loc-516" role="doc-biblioref"><em>Codatatypes in ML</em> [40</a>] is the earliest reference to codata in programming languages that I could find. This is much more recent than algebraic data, which I think explains why codata is relatively unknown. There are some excellent recent papers that deal with codata. I highly recommend <a id="loc-88" href="#loc-498" role="doc-biblioref"><em>Codata in Action</em> [22</a>], which inspired large portions of this chapter. <a id="loc-89" href="#loc-557" role="doc-biblioref"><em>Exploring Codata: The Relation to Object-Orientation</em> [81</a>] is also worthwhile. <a id="loc-90" href="#loc-566" role="doc-biblioref"><em>How to add laziness to a strict language without even being odd</em> [90</a>] is an older paper that discusses the implementation of streams, and in particular the difference between a not-quite-lazy-enough implementation they label odd and the version we saw, which they call even. These correspond to <code>Stream</code> and <code>LazyList</code> in the Scala standard library respectively. <a id="loc-91" href="#loc-497" role="doc-biblioref"><em>Classical (Co)Recursion: Programming</em> [21</a>] is an interesting survey of corecursion in different languages, and covers many of the same examples that I used here. Finally, if you really want to get into the weeds of the relationship between data and codata, <a id="loc-92" href="#loc-520" role="doc-biblioref"><em>Beyond Church encoding: Boehm-Berarducci isomorphism of algebraic data types and polymorphic lambda-terms</em> [44</a>] is for you.</p>
    <h2 id="loc-93">5. Contextual Abstraction</h2>
    <p>All but the simplest programs depend on the <strong>context</strong> in which they run. The number of available CPU cores is an example of context provided by the computer. A program might adapt to this context by changing how work is distributed. Other forms of context include configuration read from files and environment variables, and (and we’ll see at lot of this later) values created at compile-time, such as serialization formats, in response to the type of some method parameters.</p>
    <p>Scala is one of the few languages that provides features for <strong>contextual abstraction</strong>, known as <strong>implicits</strong> in Scala 2 or <strong>given instances</strong> in Scala 3. In Scala these features are intimately related to types; types are used to select between different available given instances and drive construction of given instances at compile-time.</p>
    <p>Most Scala programmers are less confident with the features for contextual abstraction than with other parts of the language, and they are often entirely novel to programmers coming from other languages. Hence this chapter will start by reviewing the abstractions formerly known as implicits: given instances and using clauses. We will then look at one of their major uses, <strong>type classes</strong>. Type classes allow us to extend existing types with new functionality, without using traditional inheritance, and without altering the original source code. Type classes are the core of <a href="https://typelevel.org/cats/">Cats<a id="loc-94" href="#loc-597" role="doc-noteref"><sup>23</sup></a></a>, which we will be exploring in the next part of this book.</p>
    <h3 id="loc-95">5.1. The Mechanics of Contextual Abstraction</h3>
    <p>In section we’ll go through the main Scala language features for contextual abstraction. Once we have a firm understanding of the mechanics of contextual abstraction we’ll move on to their use.</p>
    <p>The language features for contextual abstraction have changed name from Scala 2 to Scala 3, but they work in largely the same way. In the table below I show the Scala 3 features, and their Scala 2 equivalents. If you use Scala 2 you’ll find that most of the code works simply by replacing <code>given</code> with <code>implicit val</code> and <code>using</code> with <code>implicit</code>.</p>
    <p>Let’s now explain how these language features work.</p>
    <h4 id="loc-96">5.1.1. Using Clauses</h4>
    <p>We’ll start with <strong>using clauses</strong>. A using clause is a method parameter list that starts with the <code>using</code> keyword. We use the term <strong>context parameters</strong> for the parameters in a using clause.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">double</span>(using x: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=</span> x + x</code></pre>
    <p>The <code>using</code> keyword applies to all parameters in the list, so in <code>add</code> below both <code>x</code> and <code>y</code> are context parameters.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">add</span>(using x: <span style="color: #d73948">Int</span>, y: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=</span> x + y</code></pre>
    <p>We can have normal parameter lists, and multiple using clauses, in the same method.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">addAll</span>(x: <span style="color: #d73948">Int</span>)(using y: <span style="color: #d73948">Int</span>)(using z: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>  x + y + z</code></pre>
    <p>We cannot pass parameters to a using clause in the normal way. We must proceed the parameters with the <code>using</code> keyword as shown below.</p>
    <pre><code data-lang="scala">double(using <span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Int = 2</span><br>add(using <span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Int = 3</span><br>addAll(<span style="color: #b60157">1</span>)(using <span style="color: #b60157">2</span>)(using <span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Int = 6</span></code></pre>
    <p>However this is not the typical way to pass parameters. In fact we don’t usually explicitly pass parameters to using clause at all. We usually use given instances instead, so let’s turn to them.</p>
    <h4 id="loc-97">5.1.2. Given Instances</h4>
    <p>A given instance is a value that is defined with the <code>given</code> keyword. Here’s a simple example.</p>
    <pre><code data-lang="scala">given theMagicNumber: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">3</span></code></pre>
    <p>We can use a given instance like a normal value.</p>
    <pre><code data-lang="scala">theMagicNumber * <span style="color: #b60157">2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Int = 6</span></code></pre>
    <p>However, it’s more common to use them with a using clause. When we call a method that has a using clause, and we do not explicitly supply values for the context parameters, the compiler will look for given instances of the required type. If it finds a given instance it will automatically use it to complete the method call.</p>
    <p>For example, we defined <code>double</code> above with a single <code>Int</code> context parameter. The given instance we just defined, <code>theMagicNumber</code>, also has type <code>Int</code>. So if we call <code>double</code> without providing any value for the context parameter the compiler will provide the value <code>theMagicNumber</code> for us.</p>
    <pre><code data-lang="scala">double<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Int = 6</span></code></pre>
    <p>The same given instance will be used for multiple parameters with the same type in a using clause, as in <code>add</code> defined above.</p>
    <pre><code data-lang="scala">add<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Int = 6</span></code></pre>
    <p>The above are the most important points for using clauses and given instances. We’ll now turn to some of the details of their semantics.</p>
    <h4 id="loc-98">5.1.3. Given Scope and Imports</h4>
    <p>Given instances are usually not explicitly passed to using clauses. Their whole reason for existence is to get the compiler to do this for us. This could make code hard to understand, so we need to be very clear about which given instances are candidates to be supplied to a using clause. In this section we’ll look at the <strong>given scope</strong>, which is all the places that the compiler will look for given instances, and the special syntax for importing given instances.</p>
    <p>The first rule we should know about the given scope is that it starts at the <strong>call site</strong>, where the method with a using clause is called, not at the <strong>definition site</strong> where the method is defined. This means the following code does not compile, because the given instance is not in scope at the call site, even though it is in scope at the definition site.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> A</span> {<br>  given a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">whichInt</span>(using int: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> int<br>}<br><br><span style="color: #4b69c6">A</span>.whichInt<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type Int was found for parameter int of method whichInt in object A</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> A.whichInt</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   ^^^^^^^^</span></code></pre>
    <p>The second rule, which we have been relying on in all our examples so far, is that the given scope includes the <strong>lexical scope</strong> at the call site. The lexical scope is where we usually look up the values associated with names (like the names of method parameters or <code>val</code> declarations). This means the following code works, as <code>a</code> is defined in a scope that includes the call site.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> A</span> {<br>  given a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br><br>  <span style="color: #d73948">object</span><span style="color: #4b69c6"> B</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">whichInt</span>(using int: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> int<br>  }<br><br>  <span style="color: #d73948">object</span><span style="color: #4b69c6"> C</span> {<br>    <span style="color: #4b69c6">B</span>.whichInt<br>  }<br>}</code></pre>
    <p>However, if there are multiple given instances in the same scope the compiler will not arbitrarily choose one. Instead it fails with an error telling us the choice is ambiguous.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> A</span> {<br>  given a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br>  given b: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">2</span><br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">whichInt</span>(using int: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> int<br>    <br>  whichInt<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Ambiguous given instances: both given instance a in object A and</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> given instance b in object A match type Int of parameter int of </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> method whichInt in object A</span></code></pre>
    <p>We can import given instances from other scopes, just like we can import normal declarations, but we must explicitly say we want to import given instances. The following code does not work because we have not explicitly imported the given instances.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> A</span> {<br>  given a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">whichInt</span>(using int: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> int<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> B</span> {<br>  <span style="color: #d73948">import</span> A.*<br>    <br>  whichInt<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type Int was found for parameter int of method whichInt in object A</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Note: given instance a in object A was not considered because it was not imported with `import given`.</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   whichInt</span><br><span style="color: #74747c">//</span><span style="color: #74747c">           ^</span></code></pre>
    <p>It works when we do explicitly import them using <code>import A.given</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> A</span> {<br>  given a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">whichInt</span>(using int: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> int<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> B</span> {<br>  <span style="color: #d73948">import</span> A.{given, *}<br>    <br>  whichInt<br>}</code></pre>
    <p>One final wrinkle: the given scope includes the companion objects of any type involved in the type of the using clause. This is best illustrated with an example. We’ll start by defining a type <code>Sound</code> that represents the sound made by its type variable <code>A</code>, and a method <code>soundOf</code> to access that sound.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Sound</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span><br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">soundOf</span>[<span style="color: #4b69c6">A</span>](using s: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>  s.sound</code></pre>
    <p>Now we’ll define some given instances. Notice that they are defined on the relevant companion objects.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Cat</span><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Cat</span> {<br>  given catSound: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>]{<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">meow</span><span style="color: #198810">"</span><br>    }<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Dog</span><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Dog</span> {<br>  given dogSound: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Dog</span>] <span style="color: #d73948">=</span> <br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Dog</span>]{<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">woof</span><span style="color: #198810">"</span><br>    }<br>}</code></pre>
    <p>When we call <code>soundOf</code> we don’t have to explicitly bring the instances into scope. They are automatically in the given scope by virtue of being defined on the companion objects of the types we use (<code>Cat</code> and <code>Dog</code>). If we had defined these instances on the <code>Sound</code> companion object they would also be in the given scope; when looking for a <code>Sound[A]</code> both the companion objects of <code>Sound</code> and <code>A</code> are in scope.</p>
    <pre><code data-lang="scala">soundOf[<span style="color: #4b69c6">Cat</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: String = "meow"</span><br>soundOf[<span style="color: #4b69c6">Dog</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: String = "woof"</span></code></pre>
    <p>We should almost always be defining given instances on companion objects. This simple organization scheme means that users do not have to explicitly import them but can easily find the implementations if they wish to inspect them.</p>
    <h5>5.1.3.1. Given Instance Priority</h5>
    <p>Notice that given instance selection is based entirely on types. We don’t even pass any values to <code>soundOf</code>! This means given instances are easiest to use when there is only one instance for each type. In this case we can just put the instances on a relevant companion object and everything works out.</p>
    <p>However, this is not always possible (though it’s often an indication of a bad design if it is not). For cases where we need multiple instances for a type, we can use the instance priority rules to select between them. We’ll look at the three most important rules below.</p>
    <p>The first rule is that explicitly passing an instance takes priority over everything else.</p>
    <pre><code data-lang="scala">given a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">whichInt</span>(using int: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> int</code></pre>
    <pre><code data-lang="scala">whichInt(using <span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res15: Int = 2</span></code></pre>
    <p>The second rule is that instances in the lexical scope take priority over instances in a companion object. Here we define an instance on the <code>Cat</code> companion object.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Sound</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span><br>}<br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Cat</span><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Cat</span> {<br>  given catSound: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>]{<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">meow</span><span style="color: #198810">"</span><br>    }<br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">soundOf</span>[<span style="color: #4b69c6">A</span>](using s: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>  s.sound</code></pre>
    <p>Now we define an instance in the lexical scope, and we see it is chosen in preference to the instance on the companion object.</p>
    <pre><code data-lang="scala">given purr: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>]  <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>]{<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">purr</span><span style="color: #198810">"</span><br>  }<br><br>soundOf[<span style="color: #4b69c6">Cat</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res17: String = "purr"</span></code></pre>
    <p>The final rule is that instances in a closer lexical scope take preference over those further away.</p>
    <pre><code data-lang="scala">{<br>  given growl: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>] <span style="color: #d73948">=</span><br>   <span style="color: #d73948">new</span> <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>]{<br>     <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">growl</span><span style="color: #198810">"</span><br>   }<br>   <br>  {<br>    given mew: <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>] <span style="color: #d73948">=</span><br>     <span style="color: #d73948">new</span> <span style="color: #4b69c6">Sound</span>[<span style="color: #4b69c6">Cat</span>]{<br>       <span style="color: #d73948">def</span> <span style="color: #4b69c6">sound</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">mew</span><span style="color: #198810">"</span><br>     }<br>     <br>    soundOf[<span style="color: #4b69c6">Cat</span>]<br>  }<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res18: String = "mew"</span></code></pre>
    <p>We’re now seen most of the details of the workings of given instances and using clauses. This is a craft level explanation, and it naturally leads to the question: where would use these tools? This is what we’ll address next, where we look at type classes and their implementation in Scala.</p>
    <h3 id="loc-99">5.2. Anatomy of a Type Class</h3>
    <p>Let’s now look at how type classes are implemented. There are three important components to a type class: the type class itself, which defines an interface; type class instances, which implement the type class for particular types; and the methods that use type classes. The table below shows the language features that correspond to each component.</p>
    <p>Let’s see how this works in detail.</p>
    <h4 id="loc-100">5.2.1. The Type Class</h4>
    <p>A type class is an interface or API that represents some functionality we want implemented. In Scala a type class is represented by a trait with at least one type parameter. For example, we can represent generic “serialize to JSON” behaviour as follows:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Define a very simple JSON AST</span><br>enum <span style="color: #4b69c6">Json</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">JsObject</span>(get: <span style="color: #4b69c6">Map</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">Json</span>])<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">JsString</span>(get: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">JsNumber</span>(get: <span style="color: #d73948">Double</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">JsNull</span><br>}<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> The "serialize to JSON" behaviour is encoded in this trait</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> JsonWriter</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">write</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Json</span><br>}</code></pre>
    <p><code>JsonWriter</code> is our type class in this example, with the <code>Json</code> algebraic data type providing supporting code. When we come to implement instances of <code>JsonWriter</code>, the type parameter <code>A</code> will be the concrete type of data we are writing.</p>
    <h4 id="loc-101">5.2.2. Type Class Instances</h4>
    <p>The instances of a type class provide implementations of the type class for specific types we care about, which can include types from the Scala standard library and types from our domain model.</p>
    <p>In Scala we create type class instances by defining given instances implementing the type class.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> JsonWriterInstances</span> {<br>  given stringWriter: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">String</span>] {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">write</span>(value: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>        <span style="color: #4b69c6">Json</span>.<span style="color: #4b69c6">JsString</span>(value)<br>    }<br>  <br>  <span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Person</span>(name: <span style="color: #4b69c6">String</span>, email: <span style="color: #4b69c6">String</span>)<br>  <br>  given <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Person</span>] with<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">write</span>(value: <span style="color: #4b69c6">Person</span>): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>      <span style="color: #4b69c6">Json</span>.<span style="color: #4b69c6">JsObject</span>(<span style="color: #4b69c6">Map</span>(<br>        <span style="color: #198810">"</span><span style="color: #198810">name</span><span style="color: #198810">"</span> -> <span style="color: #4b69c6">Json</span>.<span style="color: #4b69c6">JsString</span>(value.name),<br>        <span style="color: #198810">"</span><span style="color: #198810">email</span><span style="color: #198810">"</span> -> <span style="color: #4b69c6">Json</span>.<span style="color: #4b69c6">JsString</span>(value.email)<br>      ))<br>  <br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br>}</code></pre>
    <p>In this example we define two type class instances of <code>JsonWriter</code>, one for <code>String</code> and one for <code>Person</code>. The definition for <code>String</code> uses the syntax we saw in the previous section. The definition for <code>Person</code> uses two bits of syntax that are new in Scala 3. Firstly, writing <code>given JsonWriter[Person]</code> creates an anonymous given instance. We declare just the type and don’t need to name the instance. This is fine because we don’t usually need to refer to given instances by name. The second bit of syntax is the use of <code>with</code> to implement a trait directly without having to write out <code>new JsonWriter[Person]</code> and so on.</p>
    <p>In a real implementation we’d usually want to define the instances on a companion object: the instance for <code>String</code> on the <code>JsonWriter</code> companion object (because we cannot define it on the <code>String</code> companion object) and the instance for <code>Person</code> on the <code>Person</code> companion object. I haven’t done this here because I would need to redeclare <code>JsonWriter</code>, as a type and its companion object must be declared at the same time.</p>
    <h4 id="loc-102">5.2.3. Type Class Use</h4>
    <p>A type class use is any functionality that requires a type class instance to work. In Scala this means any method that accepts instances of the type class as part of a using clause.</p>
    <p>We’re going to look at two patterns of type class usage, which we call <strong>interface objects</strong> and <strong>interface syntax</strong>. You’ll find these in Cats and other libraries.</p>
    <h5>5.2.3.1. Interface Objects</h5>
    <p>The simplest way of creating an interface that uses a type class is to place methods in an object.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Json</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">toJson</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>)(using w: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>    w.write(value)<br>}</code></pre>
    <p>To use this object, we import any type class instances we care about and call the relevant method:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> JsonWriterInstances.{*, given}</code></pre>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Json</span>.toJson(<span style="color: #4b69c6">Person</span>(<span style="color: #198810">"</span><span style="color: #198810">Dave</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">dave@example.com</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Json = JsObject(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   get = Map(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     "name" -> JsString(get = "Dave"),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     "email" -> JsString(get = "dave@example.com")</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   )</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>The compiler spots that we’ve called the <code>toJson</code> method without providing the given instances. It tries to fix this by searching for given instances of the relevant types and inserting them at the call site.</p>
    <h5>5.2.3.2. Interface Syntax</h5>
    <p>We can alternatively use <strong>extension methods</strong> to extend existing types with interface methods<a id="loc-103" href="#loc-598" role="doc-noteref"><sup>24</sup></a>. This is sometimes called <strong>syntax</strong> for the type class, which is the term used by Cats. Scala 2 has an equivalent to extension methods known as <strong>implicit classes</strong>.</p>
    <p>Here’s an example defining an extension method to add a <code>toJson</code> method to any type for which we have a <code>JsonWriter</code> instance.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> JsonSyntax</span> {<br>  extension [<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>) {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">toJson</span>(using w: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>      w.write(value)<br>  }<br>}</code></pre>
    <p>We use interface syntax by importing it alongside the instances for the types we need:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> JsonWriterInstances.given<br><span style="color: #d73948">import</span> JsonSyntax.*</code></pre>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Person</span>(<span style="color: #198810">"</span><span style="color: #198810">Dave</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">dave@example.com</span><span style="color: #198810">"</span>).toJson<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Json = JsObject(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   get = Map(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     "name" -> JsString(get = "Dave"),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     "email" -> JsString(get = "dave@example.com")</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   )</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <div>
      <h5>Extension Methods on Traits</h5>
      <p>In Scala 3 we can define extension methods directly on a type class trait. Since we’re defining <code>toJson</code> as just calling <code>write</code> on <code>JsonWriter</code>, we could instead define <code>toJson</code> directly on <code>JsonWriter</code> and avoid creating an separate extension method.</p>
      <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> JsonWriter</span>[<span style="color: #4b69c6">A</span>] {<br>  extension (value: <span style="color: #4b69c6">A</span>) <span style="color: #d73948">def</span> <span style="color: #4b69c6">toJson</span>: <span style="color: #4b69c6">Json</span><br>}<br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> JsonWriter</span> {<br>  given stringWriter: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">String</span>] {<br>      extension (value: <span style="color: #4b69c6">String</span>) <br>        <span style="color: #d73948">def</span> <span style="color: #4b69c6">toJson</span>: <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Json</span>.<span style="color: #4b69c6">JsString</span>(value)<br>    }<br>  <br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br>}</code></pre>
      <p>We do <em>not</em> advocate this approach, because of a limitation in how Scala searches for extension methods. The following code fails because Scala only looks within the <code>String</code> companion object for extension methods, and consequently does not find the extension method on the instance in the <code>JsonWriter</code> companion object.</p>
      <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">A string</span><span style="color: #198810">"</span>.toJson<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> value toJson is not a member of String</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> "A string".toJson</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> ^^^^^^^^^^^^^^^^^</span></code></pre>
      <p>This means that users will have to explicitly import at least the instances for the built-in types (for which we cannot modify the companion objects).</p>
      <pre><code data-lang="scala"><span style="color: #d73948">import</span> JsonWriter.given<br><br><span style="color: #198810">"</span><span style="color: #198810">A string</span><span style="color: #198810">"</span>.toJson<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Json = JsString(get = "A string")</span></code></pre>
      <p>For consistency we recommend separating the syntax from the type class instances and always explicitly importing it, rather than requiring explicit imports for only some extension methods.</p>
    </div>
    <h5>5.2.3.3. The <code>summon</code> Method</h5>
    <p>The Scala standard library provides a generic type class interface called <code>summon</code>. Its definition is very simple:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">summon</span>[<span style="color: #4b69c6">A</span>](using value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>  value</code></pre>
    <p>We can use <code>summon</code> to summon any value in the given scope. We provide the type we want and <code>summon</code> does the rest:</p>
    <pre><code data-lang="scala">summon[<span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">String</span>]]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: JsonWriter[String] = repl.MdocSession$MdocApp3$JsonWriter$$anon$9@4662023f</span></code></pre>
    <p>Most type classes in Cats provide other means to summon instances. However, <code>summon</code> is a good fallback for debugging purposes. We can insert a call to <code>summon</code> within the general flow of our code to ensure the compiler can find an instance of a type class and ensure that there are no ambiguity errors.</p>
    <h3 id="loc-104">5.3. Type Class Composition</h3>
    <p>So far we’ve seen type classes as a way to get the compiler to pass values to methods. This is nice but it does seem like we’ve introduced a lot of new concepts for a small gain. The real power of type classes lies in the compiler’s ability to combine given instances to construct new given instances. This is known as <strong>type class composition</strong>.</p>
    <p>Type class composition works by a feature of given instances we have not yet seen: given instances can themselves have context parameters. However, before we go into this let’s see a motivational example.</p>
    <p>Consider defining a <code>JsonWriter</code> for <code>Option</code>. We would need a <code>JsonWriter[Option[A]]</code> for every <code>A</code> we care about in our application. We could try to brute force the problem by creating a library of given instances:</p>
    <pre><code data-lang="scala">given optionIntWriter: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span><br><br>given optionPersonWriter: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">Person</span>]] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> and so on...</span></code></pre>
    <p>This approach clearly doesn’t scale. We end up requiring two given instances for every type <code>A</code> in our application: one for <code>A</code> and one for <code>Option[A]</code>.</p>
    <p>Fortunately, we can abstract the code for handling <code>Option[A]</code> into a common constructor based on the instance for <code>A</code>:</p>
    <ul>
      <li>
        <p>if the option is <code>Some(aValue)</code>, write <code>aValue</code> using the writer for <code>A</code>;</p>
      </li>
      <li>
        <p>if the option is <code>None</code>, return <code>JsNull</code>.</p>
      </li>
    </ul>
    <p>Here is the same code written out using a parameterized given instance:</p>
    <pre><code data-lang="scala">given optionWriter[<span style="color: #4b69c6">A</span>](using writer: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">write</span>(option: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>      option <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(aValue) <span style="color: #d73948">=></span> writer.write(aValue)<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>         <span style="color: #d73948">=></span> <span style="color: #4b69c6">Json</span>.<span style="color: #4b69c6">JsNull</span><br>      }<br>  }</code></pre>
    <p>This method constructs a <code>JsonWriter</code> for <code>Option[A]</code> by relying on a context parameter to fill in the <code>A</code>-specific functionality. When the compiler sees an expression like this:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Json</span>.toJson(<span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">A string</span><span style="color: #198810">"</span>))</code></pre>
    <p>it searches for an given instance <code>JsonWriter[Option[String]]</code>. It finds the given instance for <code>JsonWriter[Option[A]]</code>:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Json</span>.toJson(<span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">A string</span><span style="color: #198810">"</span>))(using optionWriter[<span style="color: #4b69c6">String</span>])</code></pre>
    <p>and recursively searches for a <code>JsonWriter[String]</code> to use as the context parameter to <code>optionWriter</code>:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Json</span>.toJson(<span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">A string</span><span style="color: #198810">"</span>))(using optionWriter(using stringWriter))</code></pre>
    <p>In this way, given instance resolution becomes a search through the space of possible combinations of given instance, to find a combination that creates a type class instance of the correct overall type.</p>
    <h4 id="loc-105">5.3.1. Type Class Composition in Scala 2</h4>
    <p>In Scala 2 we can achieve the same effect with an <code>implicit</code> method with <code>implicit</code> parameters. Here’s the Scala 2 equivalent of <code>optionWriter</code> above.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">implicit</span> <span style="color: #d73948">def</span> <span style="color: #4b69c6">scala2OptionWriter</span>[<span style="color: #4b69c6">A</span>]<br>    (<span style="color: #d73948">implicit</span> writer: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">write</span>(option: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>      option <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(aValue) <span style="color: #d73948">=></span> writer.write(aValue)<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>         <span style="color: #d73948">=></span> <span style="color: #4b69c6">JsNull</span><br>      }<br>  }</code></pre>
    <p>Make sure you make the method’s parameter implicit! If you don’t, you’ll end up defining an <strong>implicit conversion</strong>. Implicit conversion is an older programming pattern that is frowned upon in modern Scala code. Fortunately, the compiler will warn you should you do this.</p>
    <h3 id="loc-106">5.4. What Type Classes Are</h3>
    <p>We’ve have now seen the mechanics of type classes: they are a specific arrangement of trait, given instances, and using clauses. This is a very craft-level explanation. Let’s now raise the level of the explanation with three different views of type classes.</p>
    <p>The first view goes back <a href="#loc-77">Chapter 4</a>, where we looked at codata. The type class itself—the trait—is an example of codata with the usual advantages of codata (we can easily add implementations) and disadvantages (we cannot easily change the interface). Given instances and using clauses add the ability to chose the codata implementation based on the type of the context parameter and the instances in the given scope, and to compose instances from smaller components.</p>
    <p>Raising the level of abstraction again, we can say that type classes allow us to implement functionality (the type class instance) separately from the type to which it applies, so that the implementation only needs to be defined at the point of the use—the call site—not at the point of declaration.</p>
    <p>Raising the level again, we can say type classes allow us to implement <strong>ad-hoc polymorphism</strong>. I find it easiest to understand ad-hoc polymorphism in contrast to <strong>parametric polymorphism</strong>. Parametric polymorphism is what we get with type parameters, also known as generic types. It allows us to treat all types in a uniform way. For example, the following function calculates the length of any list of an arbitrary type <code>A</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">length</span>[<span style="color: #4b69c6">A</span>](list: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>  list <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Nil</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>    <span style="color: #d73948">case</span> x :: xs <span style="color: #d73948">=></span> <span style="color: #b60157">1</span> + length(xs)<br>  }</code></pre>
    <p>We can implement <code>length</code> because we don’t require any particular functionality from the values of type <code>A</code> that make up the elements of the list. We don’t call any methods on them, and indeed we cannot call any methods on them because we don’t know what concrete type <code>A</code> will be at the point where <code>length</code> is defined<a id="loc-107" href="#loc-599" role="doc-noteref"><sup>25</sup></a>.</p>
    <p>Ad-hoc polymorphism allows us to call methods on values with a generic type. The methods we can call are exactly those defined by the type class. For example, we can use the <code>Numeric</code> type class from the standard library to write a method that adds together elements of any type that implements that type class.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.math.Numeric<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">add</span>[<span style="color: #4b69c6">A</span>](x: <span style="color: #4b69c6">A</span>, y: <span style="color: #4b69c6">A</span>)(using n: <span style="color: #4b69c6">Numeric</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> {<br>  n.plus(x, y)<br>}</code></pre>
    <p>So parametric polymorphism can be understood as meaning any type, while ad-hoc polymorphism means any type <em>that also implements this functionality</em>. In ad-hoc polymorphism there doesn’t have to be any particular type relationship between the concrete types that implement the functionality of interest. This is in contast to object-oriented style polymorphism where all concrete types must be subtypes of the type that defines the functionality of interest.</p>
    <h3 id="loc-108">5.5. Exercise: Display Library</h3>
    <p>Scala provides a <code>toString</code> method to let us convert any value to a <code>String</code>. This method comes with a few disadvantages:</p>
    <ol>
      <li>
        <p>It is implemented for <em>every</em> type in the language. There are situations where we don’t want to be able to view data. For example, we may want to ensure we don’t log sensitive information, such as passwords, in plain text.</p>
      </li>
      <li>
        <p>We can’t customize <code>toString</code> for types we don’t control.</p>
      </li>
    </ol>
    <p>Let’s define a <code>Display</code> type class to work around these problems:</p>
    <ol>
      <li>
        <p>Define a type class <code>Display[A]</code> containing a single method <code>display</code>. <code>display</code> should accept a value of type <code>A</code> and return a <code>String</code>.</p>
      </li>
      <li>
        <p>Create instances of <code>Display</code> for <code>String</code> and <code>Int</code> on the <code>Display</code> companion object.</p>
      </li>
      <li>
        <p>On the <code>Display</code> companion object create two generic interface methods:</p>
        <ul>
          <li>
            <p><code>display</code> accepts a value of type <code>A</code> and a <code>Display</code> of the corresponding type. It uses the relevant <code>Display</code> to convert the <code>A</code> to a <code>String</code>.</p>
          </li>
          <li>
            <p><code>print</code> accepts the same parameters as <code>display</code> and returns <code>Unit</code>. It prints the displayed <code>A</code> value to the console using <code>println</code>.</p>
          </li>
        </ul>
      </li>
    </ol>
    <h4 id="loc-109">5.5.1. Using the Library</h4>
    <p>The code above forms a general purpose printing library that we can use in multiple applications. Let’s define an “application” now that uses the library.</p>
    <p>First we’ll define a data type to represent a well-known type of furry animal:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Cat</span>(name: <span style="color: #4b69c6">String</span>, age: <span style="color: #d73948">Int</span>, color: <span style="color: #4b69c6">String</span>)</code></pre>
    <p>Next we’ll create an implementation of <code>Display</code> for <code>Cat</code> that returns content in the following format:</p>
    <pre><code data-lang="ruby">NAME is a AGE year<span style="color: #d73948">-</span>old COLOR cat.</code></pre>
    <p>Finally, use the type class on the console or in a short demo app: create a <code>Cat</code> and print it to the console:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Define a cat:</span><br><span style="color: #d73948">val</span> cat <span style="color: #d73948">=</span> <span style="color: #4b69c6">Cat</span>(<span style="color: #74747c">/* ... */</span>)<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Print the cat!</span></code></pre>
    <h4 id="loc-110">5.5.2. Better Syntax</h4>
    <p>Let’s make our printing library easier to use by adding extension methods for its functionality:</p>
    <ol>
      <li>
        <p>Create an object <code>DisplaySyntax</code>.</p>
      </li>
      <li>
        <p>Define <code>display</code> and <code>print</code> as extension methods on <code>DisplaySyntax</code>.</p>
      </li>
      <li>
        <p>Use the extension methods to print the example <code>Cat</code> you created in the previous exercise.</p>
      </li>
    </ol>
    <h3 id="loc-111">5.6. Type Classes and Variance</h3>
    <p>In this section we’ll discuss how <strong>variance</strong> interacts with type class instance selection. Variance is one of the darker corners of Scala’s type system, so we start by reviewing it before moving on to its interaction with type classes.</p>
    <h4 id="loc-112">5.6.1. Variance</h4>
    <p>Variance concerns the relationship between an instance defined on a type and its subtypes. For example, if we define a <code>JsonWriter[Option[Int]]</code>, will the expression <code>Json.toJson(Some(1))</code> select this instance? (Remember that <code>Some</code> is a subtype of <code>Option</code>).</p>
    <p>We need two concepts to explain variance: type constructors, and subtyping.</p>
    <p>Variance applies to any <strong>type constructor</strong>, which is the <code>F</code> in a type <code>F[A]</code>. So, for example, <code>List</code>, <code>Option</code>, and <code>JsonWriter</code> are all type constructors. A type constructor must have at least one type parameter, and may have more. So <code>Either</code>, with two type parameters, is also a type constructor.</p>
    <p><strong>Subtyping</strong> is a relationship between types. We say that <code>B</code> is a subtype of <code>A</code> if we can use a value of type <code>B</code> anywhere we expect a value of type <code>A</code>. We may sometimes use the shorthand <code>B &lt;: A</code> to indicate that <code>B</code> is a subtype of <code>A</code>.</p>
    <p>Variance concerns the subtyping relationship between types <code>F[A]</code> and <code>F[B]</code>, given a subtyping relationship between <code>A</code> and <code>B</code>. If <code>B</code> is a subtype of <code>A</code> then</p>
    <ol>
      <li>if <code>F[B] &lt;: F[A]</code> we say <code>F</code> is <strong>covariant</strong> in <code>A</code>; else</li>
      <li>if <code>F[B] >: F[A]</code> we say <code>F</code> is <strong>contravariant</strong> in <code>A</code>; else</li>
      <li>if there is no subtyping relationship between <code>F[B]</code> and <code>F[A]</code> we say <code>F</code> is <strong>invariant</strong> in <code>A</code>.</li>
    </ol>
    <p>When we define a type constructor we can also add variance annotations to its type parameters. For example, we denote covariance with a <code>+</code> symbol:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> F</span>[<span style="color: #d73948">+</span><span style="color: #4b69c6">A</span>] <span style="color: #74747c">//</span><span style="color: #74747c"> the "+" means "covariant"</span></code></pre>
    <p>Similarly, the <code>-</code> variance annotation indicate contravariance. If we don’t add a variance annotation, the type parameter is invariant. Let’s now look at covariance, contravariance, and invariance in detail.</p>
    <h4 id="loc-113">5.6.2. Covariance</h4>
    <p>Covariance means that the type <code>F[B]</code> is a subtype of the type <code>F[A]</code> if <code>B</code> is a subtype of <code>A</code>. This is useful for modelling many types, including collections like <code>List</code> and <code>Option</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> List</span>[<span style="color: #d73948">+</span><span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Option</span>[<span style="color: #d73948">+</span><span style="color: #4b69c6">A</span>]</code></pre>
    <p>The covariance of Scala collections allows us to substitute collections of one type with a collection of a subtype in our code. For example, we can use a <code>List[Circle]</code> anywhere we expect a <code>List[Shape]</code> because <code>Circle</code> is a subtype of <code>Shape</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Shape</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Circle</span>(radius: <span style="color: #d73948">Double</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Shape</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> circles: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Circle</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Circle</span>(<span style="color: #b60157">5</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>))<br><span style="color: #d73948">val</span> shapes: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Shape</span>] <span style="color: #d73948">=</span> circles</code></pre>
    <p>Generally speaking, covariance is used for outputs: data that we can later get out of a container type such as <code>List</code>, or is otherwise returned by some method.</p>
    <h4 id="loc-114">5.6.3. Contravariance</h4>
    <p>What about contravariance? We write contravariant type constructors with a <code>-</code> symbol like this:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> F</span>[<span style="color: #d73948">-</span><span style="color: #4b69c6">A</span>]</code></pre>
    <p>Perhaps confusingly, contravariance means that the type <code>F[B]</code> is a subtype of <code>F[A]</code> if <code>A</code> is a subtype of <code>B</code>. This is useful for modelling types that represent inputs, like our <code>JsonWriter</code> type class above:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> JsonWriter</span>[<span style="color: #d73948">-</span><span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">write</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Json</span><br>}</code></pre>
    <p>Let’s unpack this a bit further. Remember that variance is all about the ability to substitute one value for another. Consider a scenario where we have two values, one of type <code>Shape</code> and one of type <code>Circle</code>, and two <code>JsonWriters</code>, one for <code>Shape</code> and one for <code>Circle</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> shape: <span style="color: #4b69c6">Shape</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><span style="color: #d73948">val</span> circle: <span style="color: #4b69c6">Circle</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><br><span style="color: #d73948">val</span> shapeWriter: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Shape</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><span style="color: #d73948">val</span> circleWriter: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">Circle</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span></code></pre>
    <p>We also have a method <code>format</code> that expects a <code>JsonWriter</code> instance.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">format</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>, writer: <span style="color: #4b69c6">JsonWriter</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Json</span> <span style="color: #d73948">=</span><br>  writer.write(value)</code></pre>
    <p>Now ask yourself the question: “Which combinations of value and writer can I pass to <code>format</code>?” We can <code>write</code> a <code>Circle</code> with either writer because all <code>Circles</code> are <code>Shapes</code>. Conversely, we can’t write a <code>Shape</code> with <code>circleWriter</code> because not all <code>Shapes</code> are <code>Circles</code>.</p>
    <p>This relationship is what we formally model using contravariance. <code>JsonWriter[Shape]</code> is a subtype of <code>JsonWriter[Circle]</code> because <code>Circle</code> is a subtype of <code>Shape</code>. This means we can use <code>shapeWriter</code> anywhere we expect to see a <code>JsonWriter[Circle]</code>.</p>
    <h4 id="loc-115">5.6.4. Invariance</h4>
    <p>Invariance is the easiest situation to describe. It’s what we get when we don’t write a <code>+</code> or <code>-</code> in a type constructor:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> F</span>[<span style="color: #4b69c6">A</span>]</code></pre>
    <p>This means the types <code>F[A]</code> and <code>F[B]</code> are never subtypes of one another, no matter what the relationship between <code>A</code> and <code>B</code>. This is the default semantics for Scala type constructors.</p>
    <h4 id="loc-116">5.6.5. Variance and Instance Selection</h4>
    <p>When the compiler searches for a given instance it looks for one matching the type <em>or subtype</em>. Thus we can use variance annotations to control type class instance selection to some extent.</p>
    <p>There are two issues that tend to arise. Let’s imagine we have an algebraic data type like:</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">A</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">B</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">C</span><br>}</code></pre>
    <p>The issues are:</p>
    <ol>
      <li>
        <p>Will an instance defined on a supertype be selected if one is available? For example, can we define an instance for <code>A</code> and have it work for values of type <code>B</code> and <code>C</code>?</p>
      </li>
      <li>
        <p>Will an instance for a subtype be selected in preference to that of a supertype. For instance, if we define an instance for <code>A</code> and <code>B</code>, and we have a value of type <code>B</code>, will the instance for <code>B</code> be selected in preference to <code>A</code>?</p>
      </li>
    </ol>
    <p>It turns out we can’t have both at once. The three choices give us behaviour as follows:</p>
    <p>Let’s see some examples, using the following types to show the subtyping relationship.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Animal</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Cat</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Animal</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> DomesticShorthair</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Cat</span></code></pre>
    <p>Now we’ll define three different type classes for the three types of variance, and define an instance of each for the <code>Cat</code> types.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Inv</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">result</span>: <span style="color: #4b69c6">String</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Inv</span> {<br>  given <span style="color: #4b69c6">Inv</span>[<span style="color: #4b69c6">Cat</span>] with<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">result</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Invariant</span><span style="color: #198810">"</span><br>    <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">A</span>](using instance: <span style="color: #4b69c6">Inv</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    instance.result<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Co</span>[<span style="color: #d73948">+</span><span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">result</span>: <span style="color: #4b69c6">String</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Co</span> {<br>  given <span style="color: #4b69c6">Co</span>[<span style="color: #4b69c6">Cat</span>] with<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">result</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Covariant</span><span style="color: #198810">"</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">A</span>](using instance: <span style="color: #4b69c6">Co</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    instance.result<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Contra</span>[<span style="color: #d73948">-</span><span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">result</span>: <span style="color: #4b69c6">String</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Contra</span> {<br>  given <span style="color: #4b69c6">Contra</span>[<span style="color: #4b69c6">Cat</span>] with<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">result</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Contravariant</span><span style="color: #198810">"</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">A</span>](using instance: <span style="color: #4b69c6">Contra</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    instance.result<br>}</code></pre>
    <p>Now the cases that work, all of which select the <code>Cat</code> instance. For the invariant case we must ask for exactly the <code>Cat</code> type. For the covariant case we can ask for a supertype of <code>Cat</code>. For contravariance we can ask for a subtype of <code>Cat</code>.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Inv</span>[<span style="color: #4b69c6">Cat</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "Invariant"</span><br><span style="color: #4b69c6">Co</span>[<span style="color: #4b69c6">Animal</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "Covariant"</span><br><span style="color: #4b69c6">Co</span>[<span style="color: #4b69c6">Cat</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "Covariant"</span><br><span style="color: #4b69c6">Contra</span>[<span style="color: #4b69c6">DomesticShorthair</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: String = "Contravariant"</span><br><span style="color: #4b69c6">Contra</span>[<span style="color: #4b69c6">Cat</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: String = "Contravariant"</span></code></pre>
    <p>Now cases that fail. With invariance any type that is not <code>Cat</code> will fail. So the supertype fails</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Inv</span>[<span style="color: #4b69c6">Animal</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> error: </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type MdocApp0.this.Inv[MdocApp0.this.Animal] was found for parameter instance of method apply in object Inv</span></code></pre>
    <p>as does the subtype.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Inv</span>[<span style="color: #4b69c6">DomesticShorthair</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> error: </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type MdocApp0.this.Inv[MdocApp0.this.DomesticShorthair] was found for parameter instance of method apply in object Inv</span></code></pre>
    <p>Covariance fails for any subtype of the type for which the instance is declared.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Co</span>[<span style="color: #4b69c6">DomesticShorthair</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> error: </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type MdocApp0.this.Co[MdocApp0.this.DomesticShorthair] was found for parameter instance of method apply in object Co</span></code></pre>
    <p>Contravariance fails for any supertype of the type for which the instance is declared.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Contra</span>[<span style="color: #4b69c6">Animal</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> error: </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type MdocApp0.this.Contra[MdocApp0.this.Animal] was found for parameter instance of method apply in object Contra</span></code></pre>
    <p>It’s clear there is no perfect system. The most common choice is to use invariant type classes. This allows us to specify more specific instances for subtypes if we want. It does mean that if we have, for example, a value of type <code>Some[Int]</code>, our type class instance for <code>Option</code> will not be used. We can solve this problem with a type annotation like <code>Some(1) : Option[Int]</code> or by using “smart constructors” like <code>Option.apply</code> and <code>Option.empty</code> which always return a result of type <code>Option</code>.</p>
    <h3 id="loc-117">5.7. Conclusions</h3>
    <p>In this chapter we took a first look at type classes. We saw the components that make up a type class:</p>
    <ul>
      <li>
        <p>A <code>trait</code>, which is the type class</p>
      </li>
      <li>
        <p>Type class instances, which are given instances.</p>
      </li>
      <li>
        <p>Type class usage, which uses using clauses.</p>
      </li>
    </ul>
    <p>We saw that type classes can be composed from components using type class composition. This is one form of metaprogramming in Scala, where we can get the compiler to do work for us based on our program’s types.</p>
    <p>We can view type classes as marrying codata with tools to select and compose implementations based on type. We can also view type classes as shifting implementation from the definition site to the call site. Finally, can see type classes as a mechanism for ad-hoc polymorphism, allowing us to define common functionality for otherwise unrelated types.</p>
    <p>Type classes were first described in <a id="loc-118" href="#loc-518" role="doc-biblioref"><em>Parametric Overloading in Polymorphic Programming Languages</em> [42</a>] and <a id="loc-119" href="#loc-564" role="doc-biblioref"><em>How to make ad-hoc polymorphism less ad hoc</em> [88</a>]. <a id="loc-120" href="#loc-541" role="doc-biblioref"><em>Type Classes as Objects and Implicits</em> [65</a>] details the encoding of type classes in Scala 2, and compares Scala’s and Haskell’s approach to type classes. Note that type classes are not restricted to Haskell and Scala. For examples, Rust’s traits are essentially type classes.</p>
    <p>As we have seen, Scala’s support for type classes is based on implicit parameters (known as using clauses in Scala 3). Implicit parameters <span id="loc-121">[</span><a href="#loc-527" role="doc-biblioref">51</a>] were motivated by a desire to decompose type classes into smaller orthogonal language features, but they have been shown to be useful for other tasks. <a id="loc-122" href="#loc-523" role="doc-biblioref"><em>Scala Implicits Are Everywhere: A Large-Scale Study of the Use of Scala Implicits in the Wild</em> [47</a>] surveys different uses of implicits in Scala. There is a particularly mind-bending example in <a id="loc-123" href="#loc-540" role="doc-biblioref"><em>Scala for Generic Programmers: Comparing Haskell and Scala Support for Generic Programming</em> [64</a>]. We’ll see some of these different uses in later chapters.</p>
    <p>Scala 3 has a few language features related to contextual abstraction that we haven’t mentioned in this chapter. Context functions <span id="loc-124">[</span><a href="#loc-538" role="doc-biblioref">62</a>] allow functions to have using clauses. They are something the community is still exploring, and well defined use cases only beginning to emerge. <a href="https://docs.scala-lang.org/scala3/reference/contextual/derivation.html">Type class derivation<a id="loc-125" href="#loc-601" role="doc-noteref"><sup>26</sup></a></a> allows us to write code that generates type classes instances. Although this is extremely useful I think it’s conceptually quite simple and doesn’t warrant space in this book.</p>
    <h2 id="loc-126">6. Reified Interpreters</h2>
    <p>The interpreter strategy is perhaps the most important in all of functional programming. The central idea is to <strong>separate description from action</strong>. When we use the interpreter strategy our program consists of two parts: the description, instructions, or program that describes what we want to do, and the interpreter that carries the actions in the description. In this chapter we’ll start exploring the design and implementation of interpreters, focusing on implementations using algebraic data types.</p>
    <p>Interpreters arise whenever there is this distinction between description and action. You may think an interpreter is a complex piece requiring a lot of development effort, but I hope to show you this is not the case. You probably already use lots of interpreters in your daily coding without realizing it. For example, consider the code below which is taken from a web framework called <a href="https://github.com/creativescala/krop">Krop<a id="loc-127" href="#loc-602" role="doc-noteref"><sup>27</sup></a></a></p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> route <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Route</span>(<br>    <span style="color: #4b69c6">Request</span>.get(<span style="color: #4b69c6">Path</span>.root / <span style="color: #198810">"</span><span style="color: #198810">user</span><span style="color: #198810">"</span> / <span style="color: #4b69c6">Param</span>.int),<br>    <span style="color: #4b69c6">Response</span>.ok(<span style="color: #4b69c6">Entity</span>.text)<br>  ).handle(userId <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">You asked for the user </span><span style="color: #198810">${</span>userId.toString<span style="color: #198810">}</span><span style="color: #198810">"</span>)</code></pre>
    <p>This defines a route, which matches <code>GET</code> requests for the path <code>"/user/&lt;int>"</code>, and responds with an <code>Ok</code> containing text. This kind of routing library is ubiquitous in web frameworks, is simple to write, and yet contains everything we need for the interpreter strategy.</p>
    <p>Interpreters are so important because they are the key to enabling compositionality and reasoning, particularly while allowing effects. For example, imagine implementing a graphics library using the interpreter strategy. A program simply describes what we want to draw on the screen, but critically it does not draw anything. The interpreter takes this description and creates the drawing described by it. We can freely compose descriptions only because they do not carry out any effects. For example, if we have a description that describes a circle, and one for a square, we can compose them by saying we should draw the circle next to the square thereby creating a new description. If we immediately drew pictures there would be nothing to compose with. Similarly, it’s easier to reason about pictures in this system because a program describes exactly what will appear on the screen, and there is no state from prior drawing that we need to worry about.</p>
    <p>Throughout this chapter we will explore the interpreter strategy by building a series of interpreters for regular expressions. We’ve chosen to use regular expressions because they are already familiar to many and they are simple to work with. This means we can focus on the details of the interpreter strategy without getting caught up in problem specific details, but we still end up with a realistic and useful result.</p>
    <p>We’ll start with a basic implementation strategy that uses algebraic data types and structural recursion. We’ll then look at transformations to turn our interpreter into a version that avoids using the stack and hence avoids the possibility of stack overflow.</p>
    <h3 id="loc-128">6.1. Regular Expressions</h3>
    <p>We’ll start this case study by briefly describing the usual task for regular expressions—matching text—and then take a more theoretical view. We’ll then move on to implementation.</p>
    <p>We most commonly use regular expressions to determine if a string matches a particular pattern. The simplest regular expression is one that matches only one string. In Scala we can create a regular expression by calling the <code>r</code> method on <code>String</code>. Here’s a regular expression that matches exactly the string <code>"Scala"</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> regexp <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span>.r</code></pre>
    <p>We can see that it matches only <code>"Scala"</code> and fails if we give it a shorter or longer input.</p>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Sca</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Boolean = false</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalaland</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Boolean = false</span></code></pre>
    <p>Notice we already have a separation between description and action. The description is the regular expression itself, created by calling the <code>r</code> method, and the action is calling the <code>matches</code> method on the regular expression.</p>
    <p>There are some characters that have a special meaning within the <code>String</code> describing a regular expression. For example, the character <code>*</code> matches the preceding character zero or more times.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> regexp <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Scala*</span><span style="color: #198810">"</span>.r</code></pre>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scal</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalaaaa</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Boolean = true</span></code></pre>
    <p>We can also use parentheses to group sequences of characters. For example, if we wanted to match all the strings like <code>"Scala"</code>, <code>"Scalala"</code>, <code>"Scalalala"</code> and so on, we could use the following regular expression.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> regexp <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Scala(la)*</span><span style="color: #198810">"</span>.r</code></pre>
    <p>Let’s check it matches what we’re looking for.</p>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalalalala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Boolean = true</span></code></pre>
    <p>We should also check it fails to match as expected.</p>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Sca</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Boolean = false</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalal</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Boolean = false</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalaland</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Boolean = false</span></code></pre>
    <p>That’s all I’m going to say about Scala’s built-in regular expressions. If you’d like to learn more there are many resources online. The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/regex/Pattern.html">JDK documentation<a id="loc-129" href="#loc-603" role="doc-noteref"><sup>28</sup></a></a> is one example, which describes all the features available in the JVM implementation of regular expressions.</p>
    <p>Let’s turn to the theoretical description, such as we might find in a textbook. A regular expression is:</p>
    <ol>
      <li>the empty regular expression that matches nothing;</li>
      <li>a string, which matches exactly that string (including the empty string);</li>
      <li>the concatenation of two regular expressions, which matches the first regular expression and then the second;</li>
      <li>the union of two regular expressions, which matches if either expression matches; and</li>
      <li>the repetition of a regular expression (often known as the Kleene star), which matches zero or more repetitions of the underlying expression.</li>
    </ol>
    <p>This kind of description may seem very abstract if you’re not used to it. It is very useful for our purposes because it defines a minimal API that we can easily implement. Let’s walk through the description and see how each part relates to code.</p>
    <p>The empty regular expression is defining a constructor with type <code>() => Regexp</code>, which we can simplify to a value of type <code>Regexp</code>. In Scala we put constructors on the companion object, so this tells us we need</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> =<br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>The second part tells us we need another constructor, this one with type <code>String => Regexp</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> =<br>    <span style="color: #d73948">???</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>The other three components all take a regular expression and produce a regular expression. In Scala these will become methods on the <code>Regexp</code> type. Let’s model this as a <code>trait</code> for now, and define these methods.</p>
    <p>The first method, the concatenation of two regular expressions, is conventionally called <code>++</code> in Scala.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>}</code></pre>
    <p>Union is conventionally called <code>orElse</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>}</code></pre>
    <p>Repetition we’ll call <code>repeat</code>, and define an alias <code>*</code> that matches how this operation is written in conventional regular expression notation.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br>}</code></pre>
    <p>We’re missing one thing: a method to actually match our regular expression against some input. Let’s call this method <code>matches</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span><br>}</code></pre>
    <p>This completes our API. Now we can turn to implementation. We’re going to represent <code>Regexp</code> as an algebraic data type, and each method that returns a <code>Regexp</code> will return an instance of this algebraic data type. What should be the elements that make up the algebraic data type? There will be one element for each method, and the constructor arguments will be exactly the parameters passed to the method <em>including the hidden <code>this</code> parameter for methods on the trait</em>.</p>
    <p>Here’s the resulting code.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>  <br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left: <span style="color: #4b69c6">Regexp</span>, right: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first: <span style="color: #4b69c6">Regexp</span>, second: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Empty</span><br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <p>A quick note about <code>this</code>. We can think of every method on an object as accepting a hidden parameter that is the object itself. This is <code>this</code>. (If you have used Python, it makes this explicit as the <code>self</code> parameter.) As we consider <code>this</code> to be a parameter to a method call, and our implementation strategy is to capture all the method parameters in a data structure, we must make sure we capture <code>this</code> when it is available. The only case where we don’t capture <code>this</code> is when we are defining a constructor on a companion object.</p>
    <p>Notice that we haven’t implemented <code>matches</code>. It doesn’t return a <code>Regexp</code> so we cannot return an element of our algebraic data type. What should we do here? <code>Regexp</code> is an algebraic data type and <code>matches</code> transforms an algebraic data type into a <code>Boolean</code>. Therefore we can use structural recursion! Let’s write out the skeleton, including the recursion rule.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>      left.matches(<span style="color: #d73948">???</span>) <span style="color: #d73948">???</span> right.matches(<span style="color: #d73948">???</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>      first.matches(<span style="color: #d73948">???</span>) <span style="color: #d73948">???</span> second.matches(<span style="color: #d73948">???</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>      source.matches(<span style="color: #d73948">???</span>) <span style="color: #d73948">???</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>  }</code></pre>
    <p>Now we can apply the usual strategies to complete the implementation. Let’s reason independently by case, starting with the case for <code>Empty</code>. This case is trivial as it always fails to match, so we just return <code>false</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right)   <span style="color: #d73948">=></span> left.matches(<span style="color: #d73948">???</span>) <span style="color: #d73948">???</span> right.matches(<span style="color: #d73948">???</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span> first.matches(<span style="color: #d73948">???</span>) <span style="color: #d73948">???</span> second.matches(<span style="color: #d73948">???</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source)        <span style="color: #d73948">=></span> source.matches(<span style="color: #d73948">???</span>) <span style="color: #d73948">???</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string)         <span style="color: #d73948">=></span> <span style="color: #d73948">???</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span>                 <span style="color: #d73948">=></span> <span style="color: #d73948">false</span><br>  }</code></pre>
    <p>Let’s move on to the <code>Append</code> case. This should match if the <code>left</code> regular expression matches the start of the <code>input</code>, and the <code>right</code> regular expression matches starting where the <code>left</code> regular expression stopped. This has uncovered a hidden requirement: we need to keep an index into the <code>input</code> that tells us where we should start matching from. Using a nested method is the easiest way to keep around additional information that we need. Here I’ve created a nested method that returns an <code>Option[Int]</code>. The <code>Int</code> is the new index to use, and we return an <code>Option</code> to indicate if the regular expression matched or not.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>    regexp <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>        loop(left, idx).flatMap(idx <span style="color: #d73948">=></span> loop(right, idx))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span> <br>        loop(first, idx) <span style="color: #d73948">???</span> loop(second, <span style="color: #d73948">???</span>)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span> <br>        loop(source, idx) <span style="color: #d73948">???</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span> <br>        <span style="color: #d73948">???</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>        <span style="color: #4b69c6">None</span><br>    }<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>  loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>).map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size).getOrElse(<span style="color: #d73948">false</span>)<br>}</code></pre>
    <p>Now we can go ahead and complete the implementation.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>    regexp <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>        loop(left, idx).flatMap(i <span style="color: #d73948">=></span> loop(right, i))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span> <br>        loop(first, idx).orElse(loop(second, idx))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>        loop(source, idx)<br>          .flatMap(i <span style="color: #d73948">=></span> loop(regexp, i))<br>          .orElse(<span style="color: #4b69c6">Some</span>(idx))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>        <span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size)<br>    }<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>  loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>).map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size).getOrElse(<span style="color: #d73948">false</span>)<br>}</code></pre>
    <p>The implementation for <code>Repeat</code> is a little tricky, so I’ll walk through the code.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>  loop(source, idx)<br>    .flatMap(i <span style="color: #d73948">=></span> loop(regexp, i))<br>    .orElse(<span style="color: #4b69c6">Some</span>(idx))</code></pre>
    <p>The first line (<code>loop(source, index)</code>) is seeing if the <code>source</code> regular expression matches. If it does we loop again, but on <code>regexp</code> (which is <code>Repeat(source)</code>), not <code>source</code>. This is because we want to repeat an indefinite number of times. If we looped on <code>source</code> we would only try twice. Remember that failing to match is still a success; repeat matches zero or more times. This condition is handled by the <code>orElse</code> clause.</p>
    <p>We should test that our implementation works.</p>
    <p>Here’s the example regular expression we started the chapter with.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> regexp <span style="color: #d73948">=</span> <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">Sca</span><span style="color: #198810">"</span>) ++ <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">la</span><span style="color: #198810">"</span>) ++ <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">la</span><span style="color: #198810">"</span>).repeat</code></pre>
    <p>Here are cases that should succeed.</p>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalalalala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res15: Boolean = true</span></code></pre>
    <p>Here are cases that should fail.</p>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Sca</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res16: Boolean = false</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalal</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res17: Boolean = false</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalaland</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res18: Boolean = false</span></code></pre>
    <p>Success! At this point we could add many extensions to our library. For example, regular expressions usually have a method (by convention denoted <code>+</code>) that matches one or more times, and one that matches zero or once (usually denoted <code>?</code>). These are both conveniences we can build on our existing API. However, our goal at the moment is to fully understand interpreters and the implementation technique we’ve used here. So in the next section we’ll discuss these in detail.</p>
    <div>
      <h5>Regular Expression Semantics</h5>
      <p>Our regular expression implementation handles union differently to Scala’s built-in regular expressions. Look at the following example comparing the two.</p>
      <pre><code data-lang="scala"><span style="color: #d73948">val</span> r1 <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">(z|zxy)ab</span><span style="color: #198810">"</span>.r<br><span style="color: #d73948">val</span> r2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">z</span><span style="color: #198810">"</span>).orElse(<span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">zxy</span><span style="color: #198810">"</span>)) ++ <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">ab</span><span style="color: #198810">"</span>)</code></pre>
      <pre><code data-lang="scala">r1.matches(<span style="color: #198810">"</span><span style="color: #198810">zxyab</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res19: Boolean = true</span><br>r2.matches(<span style="color: #198810">"</span><span style="color: #198810">zxyab</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res20: Boolean = false</span></code></pre>
      <p>The reason for this difference is that our implementation commits to the first branch in a union that successfully matches some of the input, regardless of how that affects later matching. We should instead try both branches, but doing so makes the implementation more complex. The semantics of regular expressions are not essential to what we’re trying to do here; we’re just using them as an example to motivate the programming strategies we’re learning. I decided the extra complexity of implementing union in the usual way outweighed the benefits, and so kept the simpler implementation. Don’t worry, we’ll see how to do it properly in <a href="#loc-386">Chapter 16</a>!</p>
    </div>
    <h3 id="loc-130">6.2. Interpreters and Reification</h3>
    <p>There are two different programming strategies at play in the regular expression code we’ve just written:</p>
    <ol>
      <li>the interpreter strategy; and</li>
      <li>the interpreter’s implementation strategy of reification.</li>
    </ol>
    <p>Remember the essence of the <strong>interpreter strategy</strong> is to separate description and action. Therefore, whenever we use the interpreter strategy we need at least two things: a description and an interpreter. Descriptions are programs; things that we want to happen. The interpreter runs the programs, carrying out the actions described within them.</p>
    <p>In the regular expression example, a <code>Regexp</code> value is a program. It is a description of a pattern we are looking for within a <code>String</code>. The <code>matches</code> method is an interpreter. It carries out the instructions in the description, checking the pattern matches the entire input. We could have other interpreters, such as one that matches if at least some part of the input matches the pattern.</p>
    <h4 id="loc-131">6.2.1. The Structure of Interpreters</h4>
    <p>All uses of the interpreter strategy have a particular structure to their methods. There are three different kinds of methods:</p>
    <ol>
      <li>
        <p><strong>constructors</strong>, or <strong>introduction forms</strong>, with type <code>A => Program</code>. Here <code>A</code> is any type that isn’t a program, and <code>Program</code> is the type of programs. Constructors conventionally live on the <code>Program</code> companion object in Scala. We see that <code>apply</code> is a constructor of <code>Regexp</code>. It has type <code>String => Regexp</code>, which matches the pattern <code>A => Program</code> for a constructor. The other constructor, <code>empty</code>, is just a value of type <code>Regexp</code>. This is equivalent to a method with type <code>() => Regexp</code> and so it also matches the pattern for a constructor.</p>
      </li>
      <li>
        <p><strong>combinators</strong> have at least one program input and a program output. The type is similar to <code>Program => Program</code> but there are often additional parameters. All of <code>++</code>, <code>orElse</code>, and <code>repeat</code> are combinators in our regular expression example. They all have a <code>Regexp</code> input (the <code>this</code> parameter) and produce a <code>Regexp</code>. Some of them have additional parameters, such as <code>++</code> or <code>orElse</code>. For both these methods the single additional parameter is a <code>Regexp</code>, but it is not the case that additional parameters to a combinator must be of the program type. Conventionally these methods live on the <code>Program</code> type.</p>
      </li>
      <li>
        <p><strong>destructors</strong>, <strong>interpreters</strong>, or <strong>elimination forms</strong>, have type <code>Program => A</code>. In our regular expression example we have a single interpreter, <code>matches</code>, but we could easily add more. For example, we often want to extract elements from the input or find a match at any location in the input.</p>
      </li>
    </ol>
    <p>This structure is often called an <strong>algebra</strong> or <strong>combinator library</strong> in the functional programming world. When we talk about constructors and destructors in an algebra we’re talking at a more abstract level then when we talk about constructors and destructors on algebraic data types. A constructor of an algebra is an abstract concept, at the theory level in my taxonomy, that we can choose to concretely implement at the craft level with the constructor of an algebraic data type. There are other possible implementations. We’ll see one later.</p>
    <h4 id="loc-132">6.2.2. Implementing Interpreters with Reification</h4>
    <p>Now that we understand the components of an interpreter we can talk more clearly about the implementation strategy we used. We used a strategy called <strong>reification</strong>, <strong>defunctionalization</strong>, <strong>deep embedding</strong>, or an <strong>initial algebra</strong>.</p>
    <p>Reification, in an abstract sense, means to make concrete what is abstract. Concretely, reification in the programming sense means to turn methods or functions into data. When using reification in the interpreter strategy we reify all the components that produce the <code>Program</code> type. This means reifying constructors and combinators.</p>
    <p>Here are the rules for reification:</p>
    <ol>
      <li>We define some type, which we’ll call <code>Program</code>, to represent programs.</li>
      <li>We implement <code>Program</code> as an algebraic data type.</li>
      <li>All constructors and combinators become product types within the <code>Program</code> algebraic data type.</li>
      <li>Each product type holds exactly the parameters to the constructor or combinator, including the <code>this</code> parameter for combinators.</li>
    </ol>
    <p>Once we’ve defined the <code>Program</code> algebraic data type, the interpreter becomes a structural recursion on <code>Program</code>.</p>
    <h5>Exercise: Arithmetic</h5>
    <p>Now it’s your turn to practice using reification. Your task is to implement an interpreter for arithmetic expressions. An expression is:</p>
    <ul>
      <li>a literal number, which takes a <code>Double</code> and produces an <code>Expression</code>;</li>
      <li>an addition of two expressions;</li>
      <li>a substraction of two expressions;</li>
      <li>a multiplication of two expressions; or</li>
      <li>a division of two expressions;</li>
    </ul>
    <p>Reify this description as a type <code>Expression</code>.</p>
    <p>Now implement an interpreter <code>eval</code> that produces a <code>Double</code>. This interpreter should interpret the expression using the usual rules of arithmetic.</p>
    <p>Add methods <code>+</code>, <code>-</code> and so on that make your system a bit nicer to use. Then write some expressions and show that it works as expected.</p>
    <h3 id="loc-133">6.3. Tail Recursive Interpreters</h3>
    <p>Structural recursion, as we have written it, uses the stack. This is not often a problem, but particularly deep recursions can lead to the stack running out of space. A solution is to write a <strong>tail recursive</strong> program. A tail recursive program does not need to use any stack space, and so is sometimes known as <strong>stack safe</strong>. Any program can be turned into a tail recursive version, which does not use the stack and therefore cannot run out of stack space.</p>
    <div>
      <h5>The Call Stack</h5>
      <p>Method and function calls are usually implemented using an area of memory known as the call stack, or just the stack for short. Every method or function call uses a small amount of memory on the stack, called a stack frame. When the method or function returns, this memory is freed and becomes available for future calls to use.</p>
      <p>A large number of method calls, without corresponding returns, can require more stack frames than the stack can accommodate. When there is no more memory available on the stack we say we have overflowed the stack. In Scala a <code>StackOverflowError</code> is raised when this happens.</p>
    </div>
    <p>In this section we will discuss tail recursion, converting programs to tail recursive form, and limitations and workarounds for the Scala’s runtimes.</p>
    <h4 id="loc-134">6.3.1. The Problem of Stack Safety</h4>
    <p>Let’s start by seeing the problem. In Scala we can create a repeated <code>String</code> using the <code>*</code> method.</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span> * <span style="color: #b60157">4</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: String = "aaaa"</span></code></pre>
    <p>We can match such a <code>String</code> with a regular expression and <code>repeat</code>.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span>).repeat.matches(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span> * <span style="color: #b60157">4</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Boolean = true</span></code></pre>
    <p>However, if we make the input very long the interpreter will fail with a stack overflow exception.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span>).repeat.matches(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span> * <span style="color: #b60157">20000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> java.lang.StackOverflowError</span></code></pre>
    <p>This is because the interpreter calls <code>loop</code> for each instance of a repeat, without returning. However, all is not lost. We can rewrite the interpreter in a way that consumes a fixed amount of stack space, and therefore match input that is as large as we like.</p>
    <h4 id="loc-135">6.3.2. Tail Calls and Tail Position</h4>
    <p>Our starting point is <strong>tail calls</strong>. A tail call is a method call that does not take any additional stack space. Only method calls that are in <strong>tail position</strong> are candidates to be turned into tail calls. Even then, runtime limitations mean that not all calls in tail position will be converted to tail calls.</p>
    <p>A method call in tail position is a call that immediately returns the value returned by the call. Let’s see an example. Below are two versions of a method to calculate the sum of the integers from 0 to <code>count</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">isntTailRecursive</span>(count: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>  count <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>    <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)<br>  }<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">isTailRecursive</span>(count: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(count: <span style="color: #d73948">Int</span>, accum: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>    count <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> accum<br>      <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, accum + n)<br>    }<br>    <br>  loop(count, <span style="color: #b60157">0</span>)<br>}</code></pre>
    <p>The method call to <code>isntTailRecursive</code> in</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)</code></pre>
    <p>is not in tail position, because the value returned by the call is then used in the addition. However, the call to <code>loop</code> in</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, accum + n)</code></pre>
    <p>is in tail position because the value returned by the call to <code>loop</code> is itself immediately returned. Similarly, the call to <code>loop</code> in</p>
    <pre><code data-lang="scala">loop(count, <span style="color: #b60157">0</span>)</code></pre>
    <p>is also in tail position.</p>
    <p>A method call in tail position is a candidate to be turned into a tail call. Limitations of Scala’s runtimes mean that not all calls in tail position can be made tail calls. Currently, only calls from a method to itself that are also in tail position will be converted to tail calls. This means</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, accum + n)</code></pre>
    <p>is converted to a tail call, because <code>loop</code> is calling itself. However, the call</p>
    <pre><code data-lang="scala">loop(count, <span style="color: #b60157">0</span>)</code></pre>
    <p>is not converted to a tail call, because the call is from <code>isTailRecursive</code> to <code>loop</code>. This will not cause issues with stack consumption, however, because this call only happens once.</p>
    <div>
      <h5>Runtimes and Tail Calls</h5>
      <p>Scala supports three different platforms: the JVM, Javascript via Scala.js, and native code via Scala Native. Each platform provides what is known as a runtime, which is code that supports our Scala code when it is running. The garbage collector, for example, is part of the runtime.</p>
      <p>At the time of writing none of Scala’s runtimes support full tail calls. However, there is reason to think this may change in the future. <a href="https://wiki.openjdk.org/display/loom/Main">Project Loom<a id="loc-136" href="#loc-604" role="doc-noteref"><sup>29</sup></a></a> should eventually add support for tail calls to the JVM. Scala Native is likely to support tail calls soon, as part of other work to implement continuations. Tail calls have been part of the Javascript specification for a long time, but remain unimplemented by the majority of Javascript runtimes. However, WebAssembly does support tail calls and will probably replace compiling Scala to Javascript in the medium term.</p>
    </div>
    <p>We can ask the Scala compiler to check that all self calls are in tail position by adding the <code>@tailrec</code> annotation to a method. The code will fail to compile if any calls from the method to itself are not in tail position.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.annotation.tailrec<br><br><span style="color: #301414">@</span><span style="color: #301414">tailrec</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">isntTailRecursive</span>(count: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>  count <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>    <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)<br>  }<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Cannot rewrite recursive call: it is not in tail position</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     case n => n + isntTailRecursive(n - 1)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                   ^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
    <p>We can check the tail recursive version is truly tail recursive by passing it a very large input. The non-tail recursive version crashes.</p>
    <pre><code data-lang="scala">isntTailRecursive(<span style="color: #b60157">100000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> java.lang.StackOverflowError</span></code></pre>
    <p>The tail recursive version runs just fine.</p>
    <pre><code data-lang="scala">isTailRecursive(<span style="color: #b60157">100000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Int = 705082704</span></code></pre>
    <h4 id="loc-137">6.3.3. Continuation-Passing Style</h4>
    <p>Now that we know about tail calls, how do we convert the regular expression interpreter to use them? Any program can be converted to an equivalent program with all calls in tail position. This conversion is known as <strong>continuation-passing style</strong> or CPS for short. Our first step to understanding CPS is to understand <strong>continuations</strong>.</p>
    <p>A continuation is an encapsulation of “what happens next”. Let’s return to our <code>Regexp</code> example. Here’s the full code for reference.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span> : <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>      regexp <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>          loop(left, idx).flatMap(i <span style="color: #d73948">=></span> loop(right, i))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>          loop(first, idx).orElse(loop(second, idx))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>          loop(source, idx)<br>            .flatMap(i <span style="color: #d73948">=></span> loop(regexp, i))<br>            .orElse(<span style="color: #4b69c6">Some</span>(idx))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>          <span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size)<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>          <span style="color: #4b69c6">None</span><br>      }<br><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>    loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>).map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size).getOrElse(<span style="color: #d73948">false</span>)<br>  }<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left: <span style="color: #4b69c6">Regexp</span>, right: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first: <span style="color: #4b69c6">Regexp</span>, second: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Empty</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <p>Let’s consider the case for <code>Append</code> in <code>matches</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>  loop(left, idx).flatMap(i <span style="color: #d73948">=></span> loop(right, i))</code></pre>
    <p>What happens next when we call <code>loop(left, idx)</code>? Let’s give the name <code>result</code> to the value returned by the call to <code>loop</code>. The answer is we run <code>result.flatMap(i => loop(right, i))</code>. We can represent this as a function, to which we pass <code>result</code>:</p>
    <pre><code data-lang="scala">(result: <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]) <span style="color: #d73948">=></span> result.flatMap(i <span style="color: #d73948">=></span> loop(right, i))</code></pre>
    <p>This is exactly the continuation, reified as a value.</p>
    <p>As is often the case, there is a distinction between the concept and the representation. The concept of continuations always exists in code. A continuation means “what happens next”. In other words, it is the program’s control flow. There is always some concept of control flow, even if it is just “the program halts”. We can represent continuations as functions in code. This transforms the abstract concept of continuations into concrete values in our program, and hence reifies them.</p>
    <p>Now that we know about continuations, and their reification as functions, we can move on to continuation-passing style. In CPS we, as the name suggests, pass around continuations. Specifically, each function or method takes an extra parameter that is a continuation. Instead of returning a value it calls that continuation with the value. This is another example of duality, in this case between returning a value and calling a continuation.</p>
    <p>Let’s see how this works. We’ll start with a simple example written in the normal style, also known as <strong>direct style</strong>.</p>
    <pre><code data-lang="scala">(<span style="color: #b60157">1</span> + <span style="color: #b60157">2</span>) * <span style="color: #b60157">3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Int = 9</span></code></pre>
    <p>To rewrite this in CPS style we need to create replacements for <code>+</code> and <code>*</code> with the extra continuation parameter.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">= </span><span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Int</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">add</span>(x: <span style="color: #d73948">Int</span>, y: <span style="color: #d73948">Int</span>, k: <span style="color: #4b69c6">Continuation</span>) <span style="color: #d73948">=</span> k(x + y)<br><span style="color: #d73948">def</span> <span style="color: #4b69c6">mul</span>(x: <span style="color: #d73948">Int</span>, y: <span style="color: #d73948">Int</span>, k: <span style="color: #4b69c6">Continuation</span>) <span style="color: #d73948">=</span> k(x * y)</code></pre>
    <p>Now we can rewrite our example in CPS. <code>(1 + 2)</code> becomes <code>add(1, 2, k)</code>, but what is <code>k</code>, the continuation? What we do next is multiply the result by <code>3</code>. Thus the continuation is <code>a => mul(a, 3, k2)</code>. What is the next continuation, <code>k2</code>? Here the program finishes, so we just return the value with the identity continuation <code>b => b</code>. Put it all together and we get</p>
    <pre><code data-lang="scala">add(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, a <span style="color: #d73948">=></span> mul(a, <span style="color: #b60157">3</span>, b <span style="color: #d73948">=></span> b))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Int = 9</span></code></pre>
    <p>Notice that every continuation call is in tail position in the CPS code. This means that code written in CPS can potentially consume no stack space.</p>
    <p>Now we can return to the interpreter loop for <code>Regexp</code>. We are going to CPS it, so we need to add an extra parameter for the continuation. In this case the contination accepts and returns the result type of <code>loop</code>: <code>Option[Int]</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Define a type alias so we can easily write continuations</span><br>  <span style="color: #d73948">type</span> <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>, cont: <span style="color: #4b69c6">Continuation</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br>}</code></pre>
    <p>Now we go through each case and convert it to CPS. Each continuation we construct must call <code>cont</code> as its final step. This is tedious and a bit error-prone, so good tests are helpful.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Define a type alias so we can easily write continuations</span><br>  <span style="color: #d73948">type</span> <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(<br>      regexp: <span style="color: #4b69c6">Regexp</span>,<br>      idx: <span style="color: #d73948">Int</span>,<br>      cont: <span style="color: #4b69c6">Continuation</span><br>  ): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>    regexp <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> cont(<span style="color: #4b69c6">None</span>)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(right, i, cont)<br>        }<br>        loop(left, idx, k)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span> <span style="color: #d73948">=></span> loop(second, idx, cont)<br>          <span style="color: #d73948">case</span> some <span style="color: #d73948">=></span> cont(some)<br>        }<br>        loop(first, idx, k)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> =<br>          <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> cont(<span style="color: #4b69c6">Some</span>(idx))<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(regexp, i, cont)<br>          }<br>        loop(source, idx, k)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>        cont(<span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size))<br>        <br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>        cont(<span style="color: #4b69c6">None</span>)<br>    }<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>  loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>, identity).map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size).getOrElse(<span style="color: #d73948">false</span>)<br>}</code></pre>
    <p>Every call in this interpreter loop is in tail position. However Scala cannot convert these to tail calls because the calls go from <code>loop</code> to a continuation and vice versa. To make the interpreter fully stack safe we need to add <strong>trampolining</strong>.</p>
    <h5>Exercise: CPS Arithmetic</h5>
    <p>In a previous exercise we wrote an interpreter for arithmetic expressions. Your task now is to CPS this interpreter. For reference, the definition of an arithmetic expression is:</p>
    <ul>
      <li>a literal number, which takes a <code>Double</code> and produces an <code>Expression</code>;</li>
      <li>an addition of two expressions;</li>
      <li>a substraction of two expressions;</li>
      <li>a multiplication of two expressions; or</li>
      <li>a division of two expressions;</li>
    </ul>
    <h4 id="loc-138">6.3.4. Trampolining</h4>
    <p>Earlier we said that CPS utilizes the duality between function calls and returns: instead of returning a value we call a function with a value. This allows us to transform our code so it only has calls in tail positions. However, we still have a problem with stack safety. Scala’s runtimes don’t support full tail calls, so calls from a continuation to <code>loop</code> or from <code>loop</code> to a continuation will use a stack frame. We can use this same duality to avoid using the stack by, instead of making a call, returning a value that reifies the call we want to make. This idea is the core of trampolining. Let’s see it in action, which will help clear up what exactly this all means.</p>
    <p>Our first step is to reify all the method calls made by the interpreter loop and the continuations. There are three cases: calls to <code>loop</code>, calls to a continuation, and, to avoid an infinite loop, the case when we’re done.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span><br><br>enum <span style="color: #4b69c6">Call</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, index: <span style="color: #d73948">Int</span>, continuation: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Continue</span>(index: <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>], continuation: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Done</span>(index: <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>])<br>}</code></pre>
    <p>Now we update <code>loop</code> to return instances of <code>Call</code> instead of making the calls directly.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>, cont: <span style="color: #4b69c6">Continuation</span>): <span style="color: #4b69c6">Call</span> <span style="color: #d73948">=</span><br>  regexp <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>      <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<span style="color: #4b69c6">None</span>, cont)<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(right, i, cont)<br>      }<br>      <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(left, idx, k)<br><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>      <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(second, idx, cont)<br>        <span style="color: #d73948">case</span> some <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(some, cont)<br>      }<br>      <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(first, idx, k)<br><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>      <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> =<br>        <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<span style="color: #4b69c6">Some</span>(idx), cont)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(regexp, i, cont)<br>        }<br>      <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(source, idx, k)<br><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>      <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<br>        <span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size),<br>        cont<br>      )<br><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>      <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<span style="color: #4b69c6">None</span>, cont)<br>  }</code></pre>
    <p>This gives us an interpreter loop that returns values instead of making calls, and so does not consume stack space. However, we need to actually make these calls at some point, and doing this is the job of the trampoline. The trampoline is simply a tail recursive loop that makes calls until it reaches <code>Done</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">trampoline</span>(next: <span style="color: #4b69c6">Call</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  next <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(regexp, index, continuation) <span style="color: #d73948">=></span><br>      trampoline(loop(regexp, index, continuation))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(index, continuation) <span style="color: #d73948">=></span><br>      trampoline(continuation(index))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Done</span>(index) <span style="color: #d73948">=></span> index<br>  }</code></pre>
    <p>Now every call has a corresponding return, so the stack usage is limited. Our interpreter can handle input of any size, up to the limits of available memory.</p>
    <p>Here’s the complete code for reference.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Define a type alias so we can easily write continuations</span><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span><br><br>enum <span style="color: #4b69c6">Call</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, index: <span style="color: #d73948">Int</span>, continuation: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Continue</span>(index: <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>], continuation: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Done</span>(index: <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>])<br>}<br><br>enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span> : <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>, cont: <span style="color: #4b69c6">Continuation</span>): <span style="color: #4b69c6">Call</span> <span style="color: #d73948">=</span><br>      regexp <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>          <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<span style="color: #4b69c6">None</span>, cont)<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(right, i, cont)<br>          }<br>          <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(left, idx, k)<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>          <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(second, idx, cont)<br>            <span style="color: #d73948">case</span> some <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(some, cont)<br>          }<br>          <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(first, idx, k)<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>          <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> =<br>            <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>              <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<span style="color: #4b69c6">Some</span>(idx), cont)<br>              <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(regexp, i, cont)<br>            }<br>          <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(source, idx, k)<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>          <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<br>            <span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size),<br>            cont<br>          )<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>          <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(<span style="color: #4b69c6">None</span>, cont)<br>      }<br><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">trampoline</span>(next: <span style="color: #4b69c6">Call</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>      next <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Loop</span>(regexp, index, continuation) <span style="color: #d73948">=></span><br>          trampoline(loop(regexp, index, continuation))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Continue</span>(index, continuation) <span style="color: #d73948">=></span><br>          trampoline(continuation(index))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Done</span>(index) <span style="color: #d73948">=></span> index<br>      }<br><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>    trampoline(loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>, opt <span style="color: #d73948">=></span> <span style="color: #4b69c6">Call</span>.<span style="color: #4b69c6">Done</span>(opt)))<br>      .map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size)<br>      .getOrElse(<span style="color: #d73948">false</span>)<br>  }<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left: <span style="color: #4b69c6">Regexp</span>, right: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first: <span style="color: #4b69c6">Regexp</span>, second: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Empty</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <h5>Exercise: Trampolined Arithmetic</h5>
    <p>Convert the CPSed arithmetic interpreter we wrote earlier to a trampolined version.</p>
    <h4 id="loc-139">6.3.5. When Tail Recursion is Easy</h4>
    <p>Doing a full CPS conversion and trampoline can be quite involved. Some methods can be made tail recursive without so large a change. Remember these examples we looked at earlier?</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">isntTailRecursive</span>(count: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>  count <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>    <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)<br>  }<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">isTailRecursive</span>(count: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(count: <span style="color: #d73948">Int</span>, accum: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>    count <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> accum<br>      <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, accum + n)<br>    }<br>    <br>  loop(count, <span style="color: #b60157">0</span>)<br>}</code></pre>
    <p>The tail recursive version doesn’t seem to involve the complexity of CPS. How can we relate this to what we’ve just learned, and when can we avoid the work of CPS and trampolining?</p>
    <p>Let’s use substitution to show how the stack is used by each method, for a small value of <code>count</code>.</p>
    <pre><code data-lang="scala">isntTailRecursive(<span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> <span style="color: #d73948">match</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>  <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)<br>})<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> + isntTailRecursive(<span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> + (<span style="color: #b60157">1</span> <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>        <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)<br>      }))<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> + (<span style="color: #b60157">1</span> + isntTailRecursive(n - <span style="color: #b60157">1</span>)))<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> + (<span style="color: #b60157">1</span> + (<span style="color: #b60157">0</span> <span style="color: #d73948">match</span> {<br>             <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>             <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> n + isntTailRecursive(n - <span style="color: #b60157">1</span>)<br>           })))<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> + (<span style="color: #b60157">1</span> + (<span style="color: #b60157">0</span>)))<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br><span style="color: #b60157">3</span></code></pre>
    <p>Here each set of brackets indicates a new method call and hence a stack frame allocation.</p>
    <p>Now let’s do the same for <code>isTailRecursive</code>.</p>
    <pre><code data-lang="scala">isTailRecursive(<span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(loop(<span style="color: #b60157">2</span>, <span style="color: #b60157">0</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">2</span> <span style="color: #d73948">match</span> {<br>   <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">0</span><br>   <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, <span style="color: #b60157">0</span> + n)<br> })<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(loop(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> call to loop is a tail call, so no stack frame is allocated </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">1</span> <span style="color: #d73948">match</span> {<br>   <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">2</span><br>   <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, <span style="color: #b60157">2</span> + n)<br> })<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(loop(<span style="color: #b60157">0</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> call to loop is a tail call, so no stack frame is allocated </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">0</span> <span style="color: #d73948">match</span> {<br>   <span style="color: #d73948">case</span> <span style="color: #b60157">0</span> <span style="color: #d73948">=></span> <span style="color: #b60157">3</span><br>   <span style="color: #d73948">case</span> n <span style="color: #d73948">=></span> loop(n - <span style="color: #b60157">1</span>, <span style="color: #b60157">3</span> + n)<br> })<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br>(<span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> expands to</span><br><span style="color: #b60157">3</span></code></pre>
    <p>The non-tail recursive function computes the result <code>(2 + (1 + (0)))</code> If we look closely, we’ll see that the tail recursive version computes <code>(((2) + 1) + 0)</code>, which simply accumulates the result in the reverse order. This works because addition is associative, meaning <code>(a + b) + c == a + (b + c)</code>. This is our first criteria for using the “easy” method for converting to a tail recursive form: the operation that accumulates results must be associative.</p>
    <p>This doesn’t explain, though, how we come to realize that addition is the correct operation to use. The second criteria is that we don’t need any memory beyond the partial result calculated from the data we’ve already seen. Some implications of this are that we can stop at any time and have a usable result, and that we are only applying a single operation to the data. This is not the case in the regular expression example. For example, we have the following code in the <code>Append</code> case:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>  loop(left, idx).flatMap(i <span style="color: #d73948">=></span> loop(right, i))</code></pre>
    <p>To compute the result for the <code>Append</code> we need to compute and combine results from both <code>left</code> and <code>right</code>. So when we have computed the result for <code>right</code> we need to remember both the result from <code>left</code> and that we’re combining the two results using the rule for <code>Append</code> rather than, say, <code>OrElse</code>. It’s remembering this that is exactly what the continuation does, and what stops us from using the easy method we saw when summing the elements of a list.</p>
    <p>So, in summary, if we are applying only a single associative operation to data we can use the simple method for writing a tail recursive method:</p>
    <ol>
      <li>define an structurally recursive loop with an additional parameter that is the partial result or accumulator;</li>
      <li>in the base cases return the accumulator; and</li>
      <li>in the recursive cases update the accumulator and call the loop in tail position.</li>
    </ol>
    <p>You might be wondering how we handle tree-shaped data with this technique. One consequence of an associative operation is that we can transform any sequence of operations into a list-shaped sequence. If, for example, we have an expression tree that suggests we should call operations in the order <code>(1 + 2) + (3 + 4)</code> (where I’m using <code>+</code> to indicate the operation) we can rewrite that to <code>(((1 + 2) + 3) + 4)</code> via associativity. So we can transform our tree into a list and then apply the recipe above.</p>
    <h3 id="loc-140">6.4. Conclusions</h3>
    <p>In this chapter we’ve discussed why we might want to build interpreters, and seen techniques for building them. To recap, the core of the interpreter strategy is a separation between description and action. The description is the program, and the interpreter is the action that carries out the program. This separation is allows for composition of programs, and managing effects by delaying them till the time the program is run. We sometimes call this structure an algebra, with constructs and combinators defining programs and destructors defining interpreters. Although the name of the strategy focuses on the interpreter, the design of the program is just as important as it is the user interface through which the programmer interacts with the system.</p>
    <p>Our starting implementation strategy is reification of the algebra’s constructors and compositional methods as an algebraic data type. The interpreter is then a structural recursion over this ADT. We saw that the straightforward implementation is not stack-safe, and which caused us to introduction the idea of tail recursion and continuations. We reified continuations as functions, and saw that we can convert any program into continuation-passing style which has every method call in tail position. Due to Scala runtime limitations not all calls in tail position can be converted to tail calls, so we reified calls and returns into data structures used by a recursive loop called a trampoline. Underlying all these strategies in the concept of duality. We have seen a duality between functions and data, which we utilize in reification, and a duality between calling functions and returning data, which we use in continuations and trampolines.</p>
    <p>Stack-safe interpreters are important in many situations, but the code is harder to read than the basic structural recursion. In some contexts a basic interpreter may be just fine. It’s unlikely to run out of stack space when evaluating a straightforward expression tree, as in the arithmetic example. The depth of such a tree grows logarithmically with the number of elements, so only extremely large trees will have sufficient depth that stack safety becomes relevant. However, in the regular expression example the stack consumption is determined not by the depth of the regular expression tree, but by the length of the input being matched. In this situation stack safety is more important. There may still be other constraints that allow a simpler implementation. For example, if we know the library will only used in situations where inputs were guaranteed to be small. As always, only use coding techniques where they make sense.</p>
    <p>These ideas are classics in programming language theory. <a id="loc-141" href="#loc-549" role="doc-biblioref"><em>Definitional Interpreters for Higher-Order Programming Languages</em> [73</a>] details defunctionalization, a limited form of reification and continuation-passing style. (If you want to read this paper, I suggest the <a href="https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/reynolds-definitional-interpreters-1998.pdf">re-typeset version from 1998<a id="loc-142" href="#loc-605" role="doc-noteref"><sup>30</sup></a></a>, which is much more readable than the original typewriter version.) These ideas are expanded on in <a id="loc-143" href="#loc-493" role="doc-biblioref"><em>Defunctionalization at Work</em> [17</a>]. <a id="loc-144" href="#loc-512" role="doc-biblioref"><em>Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity</em> [36</a>] is a very readable and elegant paper that highlights the importance of associativity in these transformations.</p>
    <span id="loc-145"></span>
    <p>In this part of the book we move on to type classes. We looked at the implementation of type classes in <a href="#loc-93">Chapter 5</a>. Our focus here is on a handful of specific type classes, that are both very useful for day-to-day programming tasks and as conceptual models that can drive program design. In this part we’ll be looking more at their use for day-to-day programming, while the case studies will focus on their role in design.</p>
    <p>In <a href="#loc-147">Chapter 7</a> we introduce the <a href="https://typelevel.org/cats">Cats<a id="loc-146" href="#loc-606" role="doc-noteref"><sup>31</sup></a></a> library. Cats provides implementation of the type classes we’re interested in, and so it saves a lot of time and typing to use it.</p>
    <h2 id="loc-147">7. Using Cats</h2>
    <p>In this Chapter we’ll learn how to use the <a href="https://typelevel.org/cats">Cats<a id="loc-148" href="#loc-607" role="doc-noteref"><sup>32</sup></a></a> library. Cats provides two main things: type classes and their instances, and some useful data structures. Our focus will mostly be on the type classes, though we will touch on the data structures where appropriate.</p>
    <h3 id="loc-149">7.1. Quick Start</h3>
    <p>The easiest, and recommended, way to use Cats is to add the following imports:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*<br><span style="color: #d73948">import</span> cats.syntax.all.*</code></pre>
    <p>The first import adds all the type classes (and makes their instances available, as they are found in the companion objects.) The second import adds the syntax helpers, which makes the type classes easier to work with. Note we don’t need to <code>import cats.{*, given}</code> as, at the time of writing, Cats is written in Scala 2 style (using <code>implicits</code>) and these are imported by the wildcard import.</p>
    <p>If we want use some of Cats’ datastructures, we also need to add</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.*</code></pre>
    <h3 id="loc-150">7.2. Using Cats</h3>
    <p>Let’s now see how we work with Cats, using <a href="http://typelevel.org/cats/api/cats/Show.html"><code>cats.Show</code><a id="loc-151" href="#loc-608" role="doc-noteref"><sup>33</sup></a></a> as an example.</p>
    <p><code>Show</code> is Cats’ equivalent of the <code>Display</code> type class we defined in <a href="#loc-108">Section 5.5</a>. It provides a mechanism for producing developer-friendly console output without using <code>toString</code>. Here’s an abbreviated definition:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Show</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">show</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">String</span><br>}</code></pre>
    <p>The easiest way to use <code>Show</code> is with the wildcard import above. However, we can also import <code>Show</code> directly from the <code>cats</code> package if we want:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Show</code></pre>
    <p>The companion object of every Cats type class has an <code>apply</code> method that locates an instance for any type we specify:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> showInt <span style="color: #d73948">=</span> <span style="color: #4b69c6">Show</span>.apply[<span style="color: #d73948">Int</span>]</code></pre>
    <p>Once we have an instance we can call methods on it.</p>
    <pre><code data-lang="scala">showInt.show(<span style="color: #b60157">42</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: String = "42"</span></code></pre>
    <p>More common, however, is to use the syntax or extension methods, which we imported with <code>import cats.syntax.all.*</code>. In the case of <code>Show</code>, an extension method <code>show</code> is defined.</p>
    <pre><code data-lang="scala"><span style="color: #b60157">42</span>.show<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "42"</span></code></pre>
    <p>If, for some reason, we wanted just the syntax for <code>show</code>, we could import <code>cats.syntax.show</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.show.* <span style="color: #74747c">//</span><span style="color: #74747c"> for show</span></code></pre>
    <h4 id="loc-152">7.2.1. Defining Custom Instances</h4>
    <p>As we learned in <a href="#loc-93">Chapter 5</a>, we can define an instance of <code>Show</code> by implementing a given instance of the trait for a specific type. Let’s implement <code>Show</code> for <code>java.util.Date</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> java.util.Date<br><br>given dateShow: <span style="color: #4b69c6">Show</span>[<span style="color: #4b69c6">Date</span>] <span style="color: #d73948">with</span> <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">show</span>(date: <span style="color: #4b69c6">Date</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>date.getTime<span style="color: #198810">}</span><span style="color: #198810">ms since the epoch.</span><span style="color: #198810">"</span></code></pre>
    <p>It works as expected.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">new</span> <span style="color: #4b69c6">Date</span>().show<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "1768321413057ms since the epoch."</span></code></pre>
    <p>However, Cats also provides a couple of convenient methods to simplify the process. There are two construction methods on the companion object of <code>Show</code> that we can use to define instances for our own types:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Show</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Convert a function to a `Show` instance:</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">show</span>[<span style="color: #4b69c6">A</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Show</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Create a `Show` instance from a `toString` method:</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">fromToString</span>[<span style="color: #4b69c6">A</span>]: <span style="color: #4b69c6">Show</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>These allow us to quickly construct instances with less ceremony than defining them from scratch:</p>
    <pre><code data-lang="scala">given dateShow: <span style="color: #4b69c6">Show</span>[<span style="color: #4b69c6">Date</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Show</span>.show(date <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>date.getTime<span style="color: #198810">}</span><span style="color: #198810">ms since the epoch.</span><span style="color: #198810">"</span>)</code></pre>
    <p>As you can see, the code using construction methods is much terser than the code without. Many type classes in Cats provide helper methods like these for constructing instances, either from scratch or by transforming existing instances for other types.</p>
    <h5>Exercise: Cat Show</h5>
    <p>In this exercise we’ll re-implement the <code>Cat</code> application from <a href="#loc-109">Section 5.5.1</a> using <code>Show</code> instead of <code>Display</code>.</p>
    <p>Using this data type to represent a well-known type of furry animal:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Cat</span>(name: <span style="color: #4b69c6">String</span>, age: <span style="color: #d73948">Int</span>, color: <span style="color: #4b69c6">String</span>)</code></pre>
    <p>create an implementation of <code>Display</code> for <code>Cat</code> that returns content in the following format:</p>
    <pre><code data-lang="ruby">NAME is a AGE year<span style="color: #d73948">-</span>old COLOR cat.</code></pre>
    <p>Then use the type class on the console or in a short demo app: create a <code>Cat</code> and print it to the console:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Define a cat:</span><br><span style="color: #d73948">val</span> cat <span style="color: #d73948">=</span> <span style="color: #4b69c6">Cat</span>(<span style="color: #74747c">/* ... */</span>)<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Print the cat!</span></code></pre>
    <h3 id="loc-153">7.3. Example: Eq</h3>
    <p>We will finish off this chapter by looking at another useful type class: <a href="http://typelevel.org/cats/api/cats/kernel/Eq.html"><code>cats.Eq</code><a id="loc-154" href="#loc-609" role="doc-noteref"><sup>34</sup></a></a>. <code>Eq</code> is designed to support <em>type-safe equality</em> and address annoyances using Scala’s built-in <code>==</code> operator.</p>
    <p>Almost every Scala developer has written code like this before:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).map(<span style="color: #4b69c6">Option</span>(<span style="color: #d73948">_</span>)).filter(item <span style="color: #d73948">=></span> item <span style="color: #d73948">==</span> <span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Values of types Option[Int] and Int cannot be compared with == or !=</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> List(1, 2, 3).map(Option(_)).filter(item => item == 1)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                                             ^^^^^^^^^</span></code></pre>
    <p>Ok, many of you won’t have made such a simple mistake as this, but the principle is sound. The predicate in the <code>filter</code> clause always returns <code>false</code> because it is comparing an <code>Int</code> to an <code>Option[Int]</code>.</p>
    <p>This is programmer error—we should have compared <code>item</code> to <code>Some(1)</code> instead of <code>1</code>. However, it’s not technically a type error because <code>==</code> works for any pair of objects, no matter what types we compare. <code>Eq</code> is designed to add some type safety to equality checks and work around this problem.<a id="loc-155" href="#loc-610" role="doc-noteref"><sup>35</sup></a></p>
    <h4 id="loc-156">7.3.1. Equality, Liberty, and Fraternity</h4>
    <p>We can use <code>Eq</code> to define type-safe equality between instances of any given type:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Eq</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eqv</span>(a: <span style="color: #4b69c6">A</span>, b: <span style="color: #4b69c6">A</span>): <span style="color: #d73948">Boolean</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> other concrete methods based on eqv...</span><br>}</code></pre>
    <p>The interface syntax, defined in <a href="https://www.javadoc.io/doc/org.typelevel/cats-docs_3/latest/cats/syntax/EqSyntax.html"><code>cats.syntax.eq</code><a id="loc-157" href="#loc-613" role="doc-noteref"><sup>37</sup></a></a>, provides two methods for performing equality checks provided there is an instance <code>Eq[A]</code> in scope:</p>
    <ul>
      <li><code>===</code> compares two objects for equality;</li>
      <li><code>=!=</code> compares two objects for inequality.</li>
    </ul>
    <h4 id="loc-158">7.3.2. Comparing Ints</h4>
    <p>Let’s look at a few examples. First we import the type class:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*</code></pre>
    <p>Now let’s grab an instance for <code>Int</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> eqInt <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eq</span>[<span style="color: #d73948">Int</span>]</code></pre>
    <p>We can use <code>eqInt</code> directly to test for equality:</p>
    <pre><code data-lang="scala">eqInt.eqv(<span style="color: #b60157">123</span>, <span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Boolean = true</span><br>eqInt.eqv(<span style="color: #b60157">123</span>, <span style="color: #b60157">234</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Boolean = false</span></code></pre>
    <p>Unlike Scala’s <code>==</code> method, if we try to compare objects of different types using <code>eqv</code> we get a compile error:</p>
    <pre><code data-lang="scala">eqInt.eqv(<span style="color: #b60157">123</span>, <span style="color: #198810">"</span><span style="color: #198810">234</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    ("234" : String)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: Int</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> eqInt.eqv(123, "234")</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                ^^^^^</span></code></pre>
    <p>We can also import the interface syntax to use the <code>===</code> and <code>=!=</code> methods:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.* <span style="color: #74747c">//</span><span style="color: #74747c"> for === and =!=</span></code></pre>
    <p>Now the syntax methods are available.</p>
    <pre><code data-lang="scala"><span style="color: #b60157">123</span> === <span style="color: #b60157">123</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Boolean = true</span><br><span style="color: #b60157">123</span> =!= <span style="color: #b60157">234</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Boolean = true</span></code></pre>
    <p>Again, comparing values of different types causes a compiler error:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">123</span> === <span style="color: #198810">"</span><span style="color: #198810">123</span><span style="color: #198810">"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    ("123" : String)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: Int</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> 123 === "123"</span><br><span style="color: #74747c">//</span><span style="color: #74747c">         ^^^^^</span></code></pre>
    <h4 id="loc-159">7.3.3. Comparing Options</h4>
    <p>Now for a more interesting example—<code>Option[Int]</code>.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Some</span>(<span style="color: #b60157">1</span>) === <span style="color: #4b69c6">None</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> value === is not a member of Some[Int] - did you mean Some[Int].==?</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Some(1) === None</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> ^^^^^^^^^^^</span></code></pre>
    <p>We have received an error here because the types don’t quite match up. We have <code>Eq</code> instances in scope for <code>Int</code> and <code>Option[Int]</code> but the values we are comparing are of type <code>Some[Int]</code>. To fix the issue we have to re-type the arguments as <code>Option[Int]</code>:</p>
    <pre><code data-lang="scala">(<span style="color: #4b69c6">Some</span>(<span style="color: #b60157">1</span>) : <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]) === (<span style="color: #4b69c6">None</span> : <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>])<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Boolean = false</span></code></pre>
    <p>We can do this in a friendlier fashion using the <code>Option.apply</code> and <code>Option.empty</code> methods from the standard library:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>) === <span style="color: #4b69c6">Option</span>.empty[<span style="color: #d73948">Int</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Boolean = false</span></code></pre>
    <p>or using special syntax from <a href="https://www.javadoc.io/doc/org.typelevel/cats-docs_3/latest/cats/syntax/OptionSyntax.html"><code>cats.syntax.option</code><a id="loc-160" href="#loc-614" role="doc-noteref"><sup>38</sup></a></a>:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">1</span>.some === none[<span style="color: #d73948">Int</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Boolean = false</span><br><span style="color: #b60157">1</span>.some =!= none[<span style="color: #d73948">Int</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Boolean = true</span></code></pre>
    <h4 id="loc-161">7.3.4. Comparing Custom Types</h4>
    <p>We can define our own instances of <code>Eq</code> using the <code>Eq.instance</code> method, which accepts a function of type <code>(A, A) => Boolean</code> and returns an <code>Eq[A]</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> java.util.Date<br><br>given dateEq: <span style="color: #4b69c6">Eq</span>[<span style="color: #4b69c6">Date</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Eq</span>.instance[<span style="color: #4b69c6">Date</span>] { (date1, date2) <span style="color: #d73948">=</span>><br>    date1.getTime === date2.getTime<br>  }</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> x <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Date</span>() <span style="color: #74747c">//</span><span style="color: #74747c"> now</span><br><span style="color: #d73948">val</span> y <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Date</span>() <span style="color: #74747c">//</span><span style="color: #74747c"> a bit later than now</span></code></pre>
    <pre><code data-lang="scala">x === x<br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: Boolean = true</span><br>x === y<br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: Boolean = true</span></code></pre>
    <h5>Exercise: Equality, Liberty, and Felinity</h5>
    <p>Implement an instance of <code>Eq</code> for our running <code>Cat</code> example:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Cat</span>(name: <span style="color: #4b69c6">String</span>, age: <span style="color: #d73948">Int</span>, color: <span style="color: #4b69c6">String</span>)</code></pre>
    <p>Use this to compare the following pairs of objects for equality and inequality:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> cat1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Garfield</span><span style="color: #198810">"</span>,   <span style="color: #b60157">38</span>, <span style="color: #198810">"</span><span style="color: #198810">orange and black</span><span style="color: #198810">"</span>)<br><span style="color: #d73948">val</span> cat2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Heathcliff</span><span style="color: #198810">"</span>, <span style="color: #b60157">33</span>, <span style="color: #198810">"</span><span style="color: #198810">orange and black</span><span style="color: #198810">"</span>)<br><br><span style="color: #d73948">val</span> optionCat1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Option</span>(cat1)<br><span style="color: #d73948">val</span> optionCat2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Option</span>.empty[<span style="color: #4b69c6">Cat</span>]</code></pre>
    <h3 id="loc-162">7.4. Conclusions</h3>
    <p>We have also seen the general patterns in Cats type classes:</p>
    <ul>
      <li>
        <p>The type classes themselves are generic traits in the <code>cats</code> package.</p>
      </li>
      <li>
        <p>Each type class has a companion object with, an <code>apply</code> method for materializing instances, one or more construction methods for creating instances, and a collection of other relevant helper methods.</p>
      </li>
      <li>
        <p>Many type classes have extension methods provided via the <code>cats.syntax</code> package.</p>
      </li>
    </ul>
    <p>In the remaining chapters of <a href="#loc-145">Part II</a> we will look at several broad and powerful type classes—<code>Semigroup</code>, <code>Monoid</code>, <code>Functor</code>, <code>Monad</code>, <code>Semigroupal</code>, <code>Applicative</code>, <code>Traverse</code>, and more. In each case we will learn what functionality the type class provides, the formal rules it follows, and how it is implemented in Cats. Many of these type classes are more abstract than <code>Show</code> or <code>Eq</code>. While this makes them harder to learn, it makes them far more useful for solving general problems in our code.</p>
    <h2 id="loc-163">8. Monoids and Semigroups</h2>
    <p>In this section we explore our first type classes, <strong>monoid</strong> and <strong>semigroup</strong>. These allow us to add or combine values. There are instances for <code>Ints</code>, <code>Strings</code>, <code>Lists</code>, <code>Options</code>, and many more. Let’s start by looking at a few simple types and operations to see what common principles we can extract.</p>
    <p>Addition of <code>Ints</code> is a binary operation that is <em>closed</em>, meaning that adding two <code>Ints</code> always produces another <code>Int</code>:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">2</span> + <span style="color: #b60157">1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Int = 3</span></code></pre>
    <p>There is also the <em>identity</em> element <code>0</code> with the property that <code>a + 0 == 0 + a == a</code> for any <code>Int</code> <code>a</code>:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">2</span> + <span style="color: #b60157">0</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Int = 2</span><br><br><span style="color: #b60157">0</span> + <span style="color: #b60157">2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Int = 2</span></code></pre>
    <p>There are also other properties of addition. For instance, it doesn’t matter in where we place brackets when we add elements, as we always get the same result. This is a property known as <em>associativity</em>:</p>
    <pre><code data-lang="scala">(<span style="color: #b60157">1</span> + <span style="color: #b60157">2</span>) + <span style="color: #b60157">3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Int = 6</span><br><br><span style="color: #b60157">1</span> + (<span style="color: #b60157">2</span> + <span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Int = 6</span></code></pre>
    <p>The same properties for addition also apply for multiplication, provided we use <code>1</code> as the identity instead of <code>0</code>:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">1</span> * <span style="color: #b60157">3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Int = 3</span><br><br><span style="color: #b60157">3</span> * <span style="color: #b60157">1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Int = 3</span></code></pre>
    <p>Multiplication, like addition, is associative:</p>
    <pre><code data-lang="scala">(<span style="color: #b60157">1</span> * <span style="color: #b60157">2</span>) * <span style="color: #b60157">3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Int = 6</span><br><br><span style="color: #b60157">1</span> * (<span style="color: #b60157">2</span> * <span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Int = 6</span></code></pre>
    <p>We can also add <code>Strings</code>, using string concatenation as our binary operator:</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">One</span><span style="color: #198810">"</span> ++ <span style="color: #198810">"</span><span style="color: #198810">two</span><span style="color: #198810">"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: String = "Onetwo"</span></code></pre>
    <p>and the empty string as the identity:</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">"</span> ++ <span style="color: #198810">"</span><span style="color: #198810">Hello</span><span style="color: #198810">"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: String = "Hello"</span><br><br><span style="color: #198810">"</span><span style="color: #198810">Hello</span><span style="color: #198810">"</span> ++ <span style="color: #198810">"</span><span style="color: #198810">"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: String = "Hello"</span></code></pre>
    <p>Once again, concatenation is associative:</p>
    <pre><code data-lang="scala">(<span style="color: #198810">"</span><span style="color: #198810">One</span><span style="color: #198810">"</span> ++ <span style="color: #198810">"</span><span style="color: #198810">Two</span><span style="color: #198810">"</span>) ++ <span style="color: #198810">"</span><span style="color: #198810">Three</span><span style="color: #198810">"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: String = "OneTwoThree"</span><br><br><span style="color: #198810">"</span><span style="color: #198810">One</span><span style="color: #198810">"</span> ++ (<span style="color: #198810">"</span><span style="color: #198810">Two</span><span style="color: #198810">"</span> ++ <span style="color: #198810">"</span><span style="color: #198810">Three</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: String = "OneTwoThree"</span></code></pre>
    <p>Note that we used <code>++</code> above instead of the more usual <code>+</code> to suggest a parallel with sequences. We can do the same with other types of sequence, using concatenation as the binary operator and the empty sequence as our identity.</p>
    <h3 id="loc-164">8.1. Definition of a Monoid</h3>
    <p>We’ve seen a number of “addition” scenarios above each with an associative binary addition and an identity element. It will be no surprise to learn that this is a monoid. Formally, a monoid for a type <code>A</code> is:</p>
    <ul>
      <li>an operation <code>combine</code> with type <code>(A, A) => A</code></li>
      <li>an element <code>empty</code> of type <code>A</code></li>
    </ul>
    <p>This definition translates nicely into Scala code. Here is a simplified version of the definition from Cats:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Monoid</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">combine</span>(x: <span style="color: #4b69c6">A</span>, y: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>: <span style="color: #4b69c6">A</span><br>}</code></pre>
    <p>In addition to providing the <code>combine</code> and <code>empty</code> operations, monoids must formally obey several <em>laws</em>. For all values <code>x</code>, <code>y</code>, and <code>z</code>, in <code>A</code>, <code>combine</code> must be associative and <code>empty</code> must be an identity element:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">associativeLaw</span>[<span style="color: #4b69c6">A</span>](x: <span style="color: #4b69c6">A</span>, y: <span style="color: #4b69c6">A</span>, z: <span style="color: #4b69c6">A</span>)<br>      (using m: <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  m.combine(x, m.combine(y, z)) ==<br>    m.combine(m.combine(x, y), z)<br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">identityLaw</span>[<span style="color: #4b69c6">A</span>](x: <span style="color: #4b69c6">A</span>)<br>      (using m: <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  (m.combine(x, m.empty) <span style="color: #d73948">==</span> x) &amp;&amp;<br>    (m.combine(m.empty, x) <span style="color: #d73948">==</span> x)<br>}</code></pre>
    <p>Integer subtraction, for example, is not a monoid because subtraction is not associative:</p>
    <pre><code data-lang="scala">(<span style="color: #b60157">1</span> - <span style="color: #b60157">2</span>) - <span style="color: #b60157">3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: Int = -4</span><br><br><span style="color: #b60157">1</span> - (<span style="color: #b60157">2</span> - <span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res15: Int = 2</span></code></pre>
    <p>In practice we only need to think about laws when we are writing our own <code>Monoid</code> instances. Unlawful instances are dangerous, not because using them can cause us to end up in jail, but because they can yield unpredictable results when used with the rest of Cats’ machinery. Most of the time we can rely on the instances provided by Cats and assume the library authors knew what they were doing.</p>
    <h3 id="loc-165">8.2. Definition of a Semigroup</h3>
    <p>A semigroup is just the <code>combine</code> part of a monoid, without the <code>empty</code> part. While many semigroups are also monoids, there are some data types for which we cannot define an <code>empty</code> element. For example, we have just seen that sequence concatenation and integer addition are monoids. However, if we restrict ourselves to non-empty sequences and positive integers, we are no longer able to define a sensible <code>empty</code> element. As a concrete example, Cats has a <a href="http://typelevel.org/cats/api/cats/data/NonEmptyList.html"><code>NonEmptyList</code><a id="loc-166" href="#loc-615" role="doc-noteref"><sup>39</sup></a></a> data type that has an implementation of <code>Semigroup</code> but no implementation of <code>Monoid</code>.</p>
    <p>A more accurate (though still simplified) definition of Cats’ <a href="http://typelevel.org/cats/api/cats/Monoid.html"><code>Monoid</code><a id="loc-167" href="#loc-616" role="doc-noteref"><sup>40</sup></a></a> is:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Semigroup</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">combine</span>(x: <span style="color: #4b69c6">A</span>, y: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span><br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Monoid</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Semigroup</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>: <span style="color: #4b69c6">A</span><br>}</code></pre>
    <p>We’ll see this kind of inheritance often when discussing type classes. It provides modularity and allows us to re-use behaviour. If we define a <code>Monoid</code> for a type <code>A</code>, we get a <code>Semigroup</code> for free. Similarly, if a method requires a parameter of type <code>Semigroup[B]</code>, we can pass a <code>Monoid[B]</code> instead.</p>
    <h5>8.2.0.1. Exercise: The Truth About Monoids</h5>
    <p>We’ve seen a few examples of monoids but there are plenty more to be found. Consider <code>Boolean</code>. How many monoids can you define for this type? For each monoid, define the <code>combine</code> and <code>empty</code> operations and convince yourself that the monoid laws hold. Use the following definitions as a starting point:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Semigroup</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">combine</span>(x: <span style="color: #4b69c6">A</span>, y: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span><br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Monoid</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Semigroup</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>: <span style="color: #4b69c6">A</span><br>}<br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Monoid</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">A</span>](<span style="color: #d73948">implicit</span> monoid: <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">A</span>]) <span style="color: #d73948">=</span><br>    monoid<br>}</code></pre>
    <h5>8.2.0.2. Exercise: All Set for Monoids</h5>
    <p>What monoids and semigroups are there for sets?</p>
    <h3 id="loc-168">8.3. Monoids in Cats</h3>
    <p>Now we’ve seen what monoids are, let’s look at their implementation in Cats. Once again we’ll look at the three main aspects of the implementation: the <em>type class</em>, the <em>instances</em>, and the <em>interface</em>.</p>
    <h4 id="loc-169">8.3.1. The Monoid Type Class</h4>
    <p>The monoid type class is <code>cats.kernel.Monoid</code>, which is aliased as <a href="http://typelevel.org/cats/api/cats/kernel/Monoid.html"><code>cats.Monoid</code><a id="loc-170" href="#loc-617" role="doc-noteref"><sup>41</sup></a></a>. <code>Monoid</code> extends <code>cats.kernel.Semigroup</code>, which is aliased as <a href="http://typelevel.org/cats/api/cats/kernel/Semigroup.html"><code>cats.Semigroup</code><a id="loc-171" href="#loc-618" role="doc-noteref"><sup>42</sup></a></a>. When using Cats we normally import type classes from the <a href="http://typelevel.org/cats/api/cats/"><code>cats</code><a id="loc-172" href="#loc-619" role="doc-noteref"><sup>43</sup></a></a> package:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monoid<br><span style="color: #d73948">import</span> cats.Semigroup</code></pre>
    <p>or just</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*</code></pre>
    <div>
      <h5>Cats Kernel?</h5>
      <p>Cats Kernel is a subproject of Cats providing a small set of typeclasses for libraries that don’t require the full Cats toolbox. While these core type classes are technically defined in the <a href="http://typelevel.org/cats/api/cats/kernel/"><code>cats.kernel</code><a id="loc-173" href="#loc-620" role="doc-noteref"><sup>44</sup></a></a> package, they are all aliased to the <a href="http://typelevel.org/cats/api/cats/"><code>cats</code><a id="loc-174" href="#loc-621" role="doc-noteref"><sup>45</sup></a></a> package so we rarely need to be aware of the distinction.</p>
      <p>The Cats Kernel type classes covered in this book are <a href="http://typelevel.org/cats/api/cats/kernel/Eq.html"><code>Eq</code><a id="loc-175" href="#loc-622" role="doc-noteref"><sup>46</sup></a></a>, <a href="http://typelevel.org/cats/api/cats/kernel/Semigroup.html"><code>Semigroup</code><a id="loc-176" href="#loc-623" role="doc-noteref"><sup>47</sup></a></a>, and <a href="http://typelevel.org/cats/api/cats/kernel/Monoid.html"><code>Monoid</code><a id="loc-177" href="#loc-624" role="doc-noteref"><sup>48</sup></a></a>. All the other type classes we cover are part of the main Cats project and are defined directly in the <a href="http://typelevel.org/cats/api/cats/"><code>cats</code><a id="loc-178" href="#loc-625" role="doc-noteref"><sup>49</sup></a></a> package.</p>
    </div>
    <h4 id="loc-179">8.3.2. Monoid Instances</h4>
    <p><code>Monoid</code> follows the standard Cats pattern for the user interface: the companion object has an <code>apply</code> method that returns the type class instance for a particular type. For example, if we want the monoid instance for <code>String</code>, and we have the correct given instances in scope, we can write the following:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monoid<br><span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">String</span>].combine(<span style="color: #198810">"</span><span style="color: #198810">Hi </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">there</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "Hi there"</span><br><span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">String</span>].empty<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = ""</span></code></pre>
    <p>which is equivalent to</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Monoid</span>.apply[<span style="color: #4b69c6">String</span>].combine(<span style="color: #198810">"</span><span style="color: #198810">Hi </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">there</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "Hi there"</span><br><span style="color: #4b69c6">Monoid</span>.apply[<span style="color: #4b69c6">String</span>].empty<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: String = ""</span></code></pre>
    <p>As we know, <code>Monoid</code> extends <code>Semigroup</code>. If we don’t need <code>empty</code> we can instead write</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Semigroup</code></pre>
    <p>and then summon instances of <code>Semigroup</code> in the usual way:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Semigroup</span>[<span style="color: #4b69c6">String</span>].combine(<span style="color: #198810">"</span><span style="color: #198810">Hi </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">there</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: String = "Hi there"</span></code></pre>
    <p>The standard type class instances for <code>Monoid</code> are all found on the appropriate companion objects, and so are automatically in the given scope with no further imports required.</p>
    <h4 id="loc-180">8.3.3. Monoid Syntax</h4>
    <p>Cats provides syntax for the <code>combine</code> method in the form of the <code>|+|</code> operator. Because <code>combine</code> technically comes from <code>Semigroup</code>, we access the syntax by importing from <a href="http://typelevel.org/cats/api/cats/syntax/package$$semigroup$"><code>cats.syntax.semigroup</code><a id="loc-181" href="#loc-626" role="doc-noteref"><sup>50</sup></a></a>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.semigroup.* <span style="color: #74747c">//</span><span style="color: #74747c"> for |+|</span></code></pre>
    <p>Now we can use <code>|+|</code> in place of calling <code>combine</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> stringResult <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Hi </span><span style="color: #198810">"</span> |+| <span style="color: #198810">"</span><span style="color: #198810">there</span><span style="color: #198810">"</span> |+| <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">String</span>].empty<br><span style="color: #74747c">//</span><span style="color: #74747c"> stringResult: String = "Hi there"</span><br><br><span style="color: #d73948">val</span> intResult <span style="color: #d73948">=</span> <span style="color: #b60157">1</span> |+| <span style="color: #b60157">2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> intResult: Int = 3</span></code></pre>
    <p>As always, unless there is compelling reason not, we recommend importing all the syntax with</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*</code></pre>
    <h5>8.3.3.1. Exercise: Adding All The Things</h5>
    <p>The cutting edge <em>SuperAdder v3.5a-32</em> is the world’s first choice for adding together numbers. The main function in the program has signature <code>def add(items: List[Int]): Int</code>. In a tragic accident this code is deleted! Rewrite the method and save the day!</p>
    <p>Well done! SuperAdder’s market share continues to grow, and now there is demand for additional functionality. People now want to add <code>List[Option[Int]]</code>. Change <code>add</code> so this is possible. The SuperAdder code base is of the highest quality, so make sure there is no code duplication!</p>
    <p>SuperAdder is entering the POS (point-of-sale, not the other POS) market. Now we want to add up <code>Orders</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Order</span>(totalCost: <span style="color: #d73948">Double</span>, quantity: <span style="color: #d73948">Double</span>)</code></pre>
    <p>We need to release this code really soon so we can’t make any modifications to <code>add</code>. Make it so!</p>
    <h3 id="loc-182">8.4. Applications of Monoids</h3>
    <p>We now know what a monoid is—an abstraction of the concept of adding or combining—but where is it useful? Here are a few big ideas where monoids play a major role. These are explored in more detail in case studies later in the book.</p>
    <h4 id="loc-183">8.4.1. Big Data</h4>
    <p>In big data applications like Spark and Flink we distribute data analysis over many machines, giving fault tolerance and scalability. This means each machine will return results over a portion of the data, and we must then combine these results to get our final result. In the vast majority of cases this can be viewed as a monoid.</p>
    <p>If we want to calculate how many total visitors a web site has received, that means calculating an <code>Int</code> on each portion of the data. We know the monoid instance of <code>Int</code> is addition, which is the right way to combine partial results.</p>
    <p>If we want to find out how many unique visitors a website has received, that’s equivalent to building a <code>Set[User]</code> on each portion of the data. We know the monoid instance for <code>Set</code> is the set union, which is the right way to combine partial results.</p>
    <p>If we want to calculate 99% and 95% response times from our server logs, we can use a data structure called a <code>QTree</code> for which there is a monoid.</p>
    <p>Hopefully you get the idea. Almost every analysis that we might want to do over a large data set is a monoid, and therefore we can build an expressive and powerful analytics system around this idea. This is exactly what Twitter’s Algebird and Summingbird projects have done. We explore this idea further in the map-reduce case study in <a href="#loc-419">Chapter 20</a>.</p>
    <h4 id="loc-184">8.4.2. Distributed Systems</h4>
    <p>In a distributed system, different machines may end up with different views of data. For example, one machine may receive an update that other machines did not receive. We would like to reconcile these different views, so every machine has the same data if no more updates arrive. This is called <strong>eventual consistency</strong>.</p>
    <p>A particular class of data types support this reconciliation. These data types are called conflict-free replicated data types (CRDTs). The key operation is the ability to merge two data instances, with a result that captures all the information in both instances. This operation relies on having a monoid instance. We explore this idea further in the CRDT case study.</p>
    <h4 id="loc-185">8.4.3. Monoids in the Small</h4>
    <p>The two examples above are cases where monoids inform the entire system architecture. There are also many cases where having a monoid around makes it easier to write a small code fragment. We’ll see lots of examples in the remainder of this book.</p>
    <h3 id="loc-186">8.5. Summary</h3>
    <p>We hit a big milestone in this chapter—we covered our first type classes with fancy functional programming names:</p>
    <ul>
      <li>a <code>Semigroup</code> represents an addition or combination operation;</li>
      <li>a <code>Monoid</code> extends a <code>Semigroup</code> by adding an identity or “zero” element.</li>
    </ul>
    <p>We can use <code>Semigroups</code> and <code>Monoids</code> by importing two things: the type classes themselves, and the semigroup syntax to give us the <code>|+|</code> operator:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monoid<br><span style="color: #d73948">import</span> cats.syntax.semigroup.* <span style="color: #74747c">//</span><span style="color: #74747c"> for |+|</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span> |+| <span style="color: #198810">"</span><span style="color: #198810"> with </span><span style="color: #198810">"</span> |+| <span style="color: #198810">"</span><span style="color: #198810">Cats</span><span style="color: #198810">"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: String = "Scala with Cats"</span></code></pre>
    <p>With the correct instances in scope, we can set about adding anything we want:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>) |+| <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Option[Int] = Some(value = 3)</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> map1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>, <span style="color: #198810">"</span><span style="color: #198810">b</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>)<br><span style="color: #d73948">val</span> map2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<span style="color: #198810">"</span><span style="color: #198810">b</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>, <span style="color: #198810">"</span><span style="color: #198810">d</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>)</code></pre>
    <pre><code data-lang="scala">map1 |+| map2<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Map[String, Int] = Map("b" -> 5, "d" -> 4, "a" -> 1)</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> tuple1 <span style="color: #d73948">=</span> (<span style="color: #198810">"</span><span style="color: #198810">hello</span><span style="color: #198810">"</span>, <span style="color: #b60157">123</span>)<br><span style="color: #d73948">val</span> tuple2 <span style="color: #d73948">=</span> (<span style="color: #198810">"</span><span style="color: #198810">world</span><span style="color: #198810">"</span>, <span style="color: #b60157">321</span>)</code></pre>
    <pre><code data-lang="scala">tuple1 |+| tuple2<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Tuple2[String, Int] = ("helloworld", 444)</span></code></pre>
    <p>We can also write generic code that works with any type for which we have an instance of <code>Monoid</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">addAll</span>[<span style="color: #4b69c6">A</span>](values: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>])<br>      (using monoid: <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>  values.foldRight(monoid.empty)(<span style="color: #d73948">_</span> |+| <span style="color: #d73948">_</span>)</code></pre>
    <pre><code data-lang="scala">addAll(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Int = 6</span><br>addAll(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">None</span>, <span style="color: #4b69c6">Some</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Some</span>(<span style="color: #b60157">2</span>)))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Option[Int] = Some(value = 3)</span></code></pre>
    <p><code>Monoids</code> are a great gateway to Cats. They’re easy to understand and simple to use. However, they’re just the tip of the iceberg in terms of the abstractions Cats enables us to make. In the next chapter we’ll look at <strong>functors</strong>, the type class personification of the beloved <code>map</code> method. That’s where the fun really begins!</p>
    <h2 id="loc-187">9. Functors</h2>
    <p>In this chapter we will investigate <strong>functors</strong>, an abstraction that allows us to represent sequences of operations within a context such as a <code>List</code>, an <code>Option</code>, or any one of thousands of other possibilities. Functors on their own aren’t so useful, but special cases of functors, such as <strong>monads</strong> and <strong>applicative functors</strong>, are some of the most commonly used abstractions.</p>
    <h3 id="loc-188">9.1. Examples of Functors</h3>
    <p>Informally, a functor is anything with a <code>map</code> method. You probably know lots of types that have this: <code>Option</code>, <code>List</code>, and <code>Either</code>, to name a few.</p>
    <p>We typically first encounter <code>map</code> when iterating over <code>Lists</code>. However, to understand functors we need to think of the method in another way. Rather than traversing the list, we should think of it as transforming all of the values inside in one go. We specify the function to apply, and <code>map</code> ensures it is applied to every item. The values change but the structure of the list (the number of elements and their order) remains the same:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).map(n <span style="color: #d73948">=></span> n + <span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: List[Int] = List(2, 3, 4)</span></code></pre>
    <p>Similarly, when we <code>map</code> over an <code>Option</code>, we transform the contents but leave the <code>Some</code> or <code>None</code> context unchanged. The same principle applies to <code>Either</code> with its <code>Left</code> and <code>Right</code> contexts. This general notion of transformation, along with the common pattern of type signatures shown in <a href="#loc-189">Figure 1</a>, is what connects the behaviour of <code>map</code> across different data types.</p>
    <figure id="loc-189">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjExNjBweCIgdmlld0JveD0iMCAwIDE3NjEgMTE2MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggNDMuMiAoMzkwNjkpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPmxpc3Qtb3B0aW9uLWVpdGhlci1tYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8Y2lyY2xlIGlkPSJwYXRoLTEiIGN4PSI3MjkiIGN5PSIxNDAiIHI9IjgwIj48L2NpcmNsZT4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0yIiBwb2ludHM9IjEwMzkuNTk1MDkgMTk0IDk4Ni42OTQ0MTQgMjIxLjgxMTUyOSA5OTYuNzk3NTQzIDE2Mi45MDU3NjUgOTU0IDEyMS4xODg0NzEgMTAxMy4xNDQ3NSAxMTIuNTk0MjM1IDEwMzkuNTk1MDkgNTkgMTA2Ni4wNDU0MiAxMTIuNTk0MjM1IDExMjUuMTkwMTcgMTIxLjE4ODQ3MSAxMDgyLjM5MjYzIDE2Mi45MDU3NjUgMTA5Mi40OTU3NiAyMjEuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMyIgcG9pbnRzPSI4NTEgMTIwIDg5MSAxMjAgODkxIDEwMCA5MzEgMTM5LjQ5Nzc2NyA4OTEgMTgwIDg5MSAxNjAgODUxIDE2MCI+PC9wb2x5Z29uPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTQiIGN4PSI2My41NjE0MzM0IiBjeT0iNjMuNjQyNDA1MSIgcng9IjYzLjU2MTQzMzQiIHJ5PSI2My42NDI0MDUxIj48L2VsbGlwc2U+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNSIgcG9pbnRzPSIyNDkuMzU0MzggMTI2LjY0MTU5IDIwNS42MDY5NDEgMTQ5LjY0OTE0MyAyMTMuOTYxOTU4IDEwMC45MTgzNjUgMTc4LjU2OTUzNiA2Ni40MDcwMzYgMjI3LjQ4MDY2IDU5LjI5NzMxMTMgMjQ5LjM1NDM4IDE0Ljk2MDU4NDggMjcxLjIyODEgNTkuMjk3MzExMyAzMjAuMTM5MjI0IDY2LjQwNzAzNiAyODQuNzQ2ODAyIDEwMC45MTgzNjUgMjkzLjEwMTgxOSAxNDkuNjQ5MTQzIj48L3BvbHlnb24+CiAgICAgICAgPHBhdGggZD0iTTIwLjA1ODgwOCwxNTUuNzY4NzUzIEMzNC42ODE4MjE0LDE3MS44OTMxMTkgNTUuNjc1MTg4LDE4MiA3OSwxODIgQzEyMy4xODI3OCwxODIgMTU5LDE0NS43MzUwNjUgMTU5LDEwMSBDMTU5LDc3Ljc0NTQ4MDIgMTQ5LjMyMTQ0Niw1Ni43Nzk3NjQ2IDEzMy44MjA0MjIsNDIuMDA3MTM4OSBMMjAuMDU4ODA4LDE1NS43Njg3NTMgWiIgaWQ9InBhdGgtNiI+PC9wYXRoPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTciIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTM4Ljk0MTE5MiIgaGVpZ2h0PSIxMzkuOTkyODYxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNiI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwYXRoIGQ9Ik0yMy45MjYwMTE1LDE1OC4wNTg4MzcgQzkuMTU4NTA1MjMsMTQzLjU0NDY0NCAtMS40MjEwODU0N2UtMTQsMTIzLjM0MTg2NCAtMS40MjEwODU0N2UtMTQsMTAxIEMtMS40MjEwODU0N2UtMTQsNTYuODE3MjIgMzUuODE3MjIsMjEgODAsMjEgQzEwMi4zNDE4NjQsMjEgMTIyLjU0NDY0NCwzMC4xNTg1MDUyIDEzNy4wNTg4MzcsNDQuOTI2MDExNSBMMjMuOTI2MDExNSwxNTguMDU4ODM3IFoiIGlkPSJwYXRoLTgiPjwvcGF0aD4KICAgICAgICA8cGF0aCBkPSJNMTA5My41NTgwNiwxNDMuMTk0MTQ2IEwxMDg3LDE4MS40MzA1OTMgTDExMzkuOTAwNjcsMTUzLjYxOTA2NCBMMTE5Mi44MDEzNSwxODEuNDMwNTkzIEwxMTgyLjY5ODIyLDEyMi41MjQ4MjggTDEyMjUuNDk1NzYsODAuODA3NTM0IEwxMTY2LjM1MTAxLDcyLjIxMzI5ODggTDExNjUuNzUyMjEsNzEgTDEwOTMuNTU4MDYsMTQzLjE5NDE0NiBaIiBpZD0icGF0aC05Ij48L3BhdGg+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTAiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTM4LjQ5NTc1OSIgaGVpZ2h0PSIxMTAuNDMwNTkzIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwYXRoIGQ9Ik0xMDkxLjk3NzgsMTUxLjAwNzA1MyBMMTA5Ni43OTc1NCwxMjIuOTA1NzY1IEwxMDU0LDgxLjE4ODQ3MDUgTDExMTMuMTQ0NzUsNzIuNTk0MjM1MyBMMTEzOS41OTUwOSwxOSBMMTE2Ni4wNDU0Miw3Mi41OTQyMzUzIEwxMTY5LjgzOTMzLDczLjE0NTUyMTcgTDEwOTEuOTc3OCwxNTEuMDA3MDUzIFoiIGlkPSJwYXRoLTExIj48L3BhdGg+CiAgICAgICAgPGNpcmNsZSBpZD0icGF0aC0xMiIgY3g9IjcyOSIgY3k9IjE0MCIgcj0iODAiPjwvY2lyY2xlPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTEzIiBwb2ludHM9IjEwMzkuNTk1MDkgMTk0IDk4Ni42OTQ0MTQgMjIxLjgxMTUyOSA5OTYuNzk3NTQzIDE2Mi45MDU3NjUgOTU0IDEyMS4xODg0NzEgMTAxMy4xNDQ3NSAxMTIuNTk0MjM1IDEwMzkuNTk1MDkgNTkgMTA2Ni4wNDU0MiAxMTIuNTk0MjM1IDExMjUuMTkwMTcgMTIxLjE4ODQ3MSAxMDgyLjM5MjYzIDE2Mi45MDU3NjUgMTA5Mi40OTU3NiAyMjEuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMTQiIHBvaW50cz0iODUxIDEyMCA4OTEgMTIwIDg5MSAxMDAgOTMxIDEzOS40OTc3NjcgODkxIDE4MCA4OTEgMTYwIDg1MSAxNjAiPjwvcG9seWdvbj4KICAgICAgICA8Y2lyY2xlIGlkPSJwYXRoLTE1IiBjeD0iODAiIGN5PSI4MCIgcj0iODAiPjwvY2lyY2xlPgogICAgICAgIDxjaXJjbGUgaWQ9InBhdGgtMTYiIGN4PSIxMDAiIGN5PSIxMDAiIHI9IjgwIj48L2NpcmNsZT4KICAgICAgICA8Y2lyY2xlIGlkPSJwYXRoLTE3IiBjeD0iMTIwIiBjeT0iMTIwIiByPSI4MCI+PC9jaXJjbGU+CiAgICAgICAgPGNpcmNsZSBpZD0icGF0aC0xOCIgY3g9IjcyNyIgY3k9IjE0MyIgcj0iODAiPjwvY2lyY2xlPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTE5IiBwb2ludHM9IjEwMzcuNTk1MDkgMTk3IDk4NC42OTQ0MTQgMjI0LjgxMTUyOSA5OTQuNzk3NTQzIDE2NS45MDU3NjUgOTUyIDEyNC4xODg0NzEgMTAxMS4xNDQ3NSAxMTUuNTk0MjM1IDEwMzcuNTk1MDkgNjIgMTA2NC4wNDU0MiAxMTUuNTk0MjM1IDExMjMuMTkwMTcgMTI0LjE4ODQ3MSAxMDgwLjM5MjYzIDE2NS45MDU3NjUgMTA5MC40OTU3NiAyMjQuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMjAiIHBvaW50cz0iODUuNTk1MDg2NSAxMzUgMzIuNjk0NDEzOCAxNjIuODExNTI5IDQyLjc5NzU0MzIgMTAzLjkwNTc2NSAtMS4xNzIzOTU1MWUtMTMgNjIuMTg4NDcwNSA1OS4xNDQ3NTAxIDUzLjU5NDIzNTMgODUuNTk1MDg2NSAwIDExMi4wNDU0MjMgNTMuNTk0MjM1MyAxNzEuMTkwMTczIDYyLjE4ODQ3MDUgMTI4LjM5MjYzIDEwMy45MDU3NjUgMTM4LjQ5NTc1OSAxNjIuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMjEiIHBvaW50cz0iMTAxLjU5NTA4NiAxNTUgNDguNjk0NDEzOCAxODIuODExNTI5IDU4Ljc5NzU0MzIgMTIzLjkwNTc2NSAxNiA4Mi4xODg0NzA1IDc1LjE0NDc1MDEgNzMuNTk0MjM1MyAxMDEuNTk1MDg2IDIwIDEyOC4wNDU0MjMgNzMuNTk0MjM1MyAxODcuMTkwMTczIDgyLjE4ODQ3MDUgMTQ0LjM5MjYzIDEyMy45MDU3NjUgMTU0LjQ5NTc1OSAxODIuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMjIiIHBvaW50cz0iMTE5LjU5NTA4NiAxNzggNjYuNjk0NDEzOCAyMDUuODExNTI5IDc2Ljc5NzU0MzIgMTQ2LjkwNTc2NSAzNCAxMDUuMTg4NDcxIDkzLjE0NDc1MDEgOTYuNTk0MjM1MyAxMTkuNTk1MDg2IDQzIDE0Ni4wNDU0MjMgOTYuNTk0MjM1MyAyMDUuMTkwMTczIDEwNS4xODg0NzEgMTYyLjM5MjYzIDE0Ni45MDU3NjUgMTcyLjQ5NTc1OSAyMDUuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMjMiIHBvaW50cz0iODQ5IDEyMyA4ODkgMTIzIDg4OSAxMDMgOTI5IDE0Mi40OTc3NjcgODg5IDE4MyA4ODkgMTYzIDg0OSAxNjMiPjwvcG9seWdvbj4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJsaXN0LW9wdGlvbi1laXRoZXItbWFwIj4KICAgICAgICAgICAgPGcgaWQ9ImVpdGhlci1tYXAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCA4MDAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjAiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xLUNvcHktMiI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI3MjkiIGN5PSIxNDAiIHI9Ijc4Ij48L2NpcmNsZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEtQ29weS0yIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik05ODkuMzUwNjc2LDIxOC4xNTU0OTggTDk5OC43Njg3NiwxNjMuMjQzODU1IEw5OTguOTQ2NTA0LDE2Mi4yMDc1MjUgTDk5OC4xOTM1NjcsMTYxLjQ3MzU5MiBMOTU4LjI5NzkyMiwxMjIuNTg0OTUgTDEwMTMuNDMyMzUsMTE0LjU3MzQ0OSBMMTAxNC40NzI4OCwxMTQuNDIyMjUxIEwxMDE0LjkzODIyLDExMy40NzkzNjcgTDEwMzkuNTk1MDksNjMuNTE5MTAyOSBMMTA2NC4yNTE5NSwxMTMuNDc5MzY3IEwxMDY0LjcxNzI5LDExNC40MjIyNTEgTDEwNjUuNzU3ODMsMTE0LjU3MzQ0OSBMMTEyMC44OTIyNSwxMjIuNTg0OTUgTDEwODAuOTk2NjEsMTYxLjQ3MzU5MiBMMTA4MC4yNDM2NywxNjIuMjA3NTI1IEwxMDgwLjQyMTQxLDE2My4yNDM4NTUgTDEwODkuODM5NSwyMTguMTU1NDk4IEwxMDQwLjUyNTc3LDE5Mi4yMjk3MzcgTDEwMzkuNTk1MDksMTkxLjc0MDQ0OSBMMTAzOC42NjQ0LDE5Mi4yMjk3MzcgTDk4OS4zNTA2NzYsMjE4LjE1NTQ5OCBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUGF0aC0xLUNvcHktMyI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjMDAwMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNODUzLDEyMiBMODkxLDEyMiBMODkzLDEyMiBMODkzLDEyMCBMODkzLDEwNC43ODU2MTUgTDkyOC4xNzE1MTcsMTM5LjUxNTUyNSBMODkzLDE3NS4xMjg2NDkgTDg5MywxNjAgTDg5MywxNTggTDg5MSwxNTggTDg1MywxNTggTDg1MywxMjIgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTQiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMTE4MSAxMjAgMTIyMSAxMjAgMTIyMSAxMDAgMTI2MSAxMzkuNDk3NzY3IDEyMjEgMTgwIDEyMjEgMTYwIDExODEgMTYwIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iRWl0aGVyW0UsLUFdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTczLjgiIHk9IjMxNCI+RWl0aGVyW0UsIEFdPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJtYXAtY29weS0yIiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjY0IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjQ5OC40IiB5PSIxNTYiPm1hcDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iRWl0aGVyW0UsLUJdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTMwNS44IiB5PSIzMTQiPkVpdGhlcltFLCBCXTwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1CLUNvcHktMiIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjgyNS40IiB5PSIzMTQiPkEgPSZndDsgQjwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MC4wMDAwMDAsIDU1LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODUuODc3MTMzLCAyMC4zMjI3ODUpIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNCI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZWxsaXBzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjYzLjU2MTQzMzQiIGN5PSI2My42NDI0MDUxIiByeD0iNjEuNTYxNDMzNCIgcnk9IjYxLjY0MjQwNTEiPjwvZWxsaXBzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbi0yIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgcG9pbnRzPSI2Mi42MjkyMzkxIDIwLjMyMjc4NDggMTI0Ljk4NjM0OCA2NS42ODU1OTExIDEwMS4xNjgwNTIgMTM5LjA4NDE1MyAyNC4wOTA0MjY0IDEzOS4wODQxNTMgMC4yNzIxMzAxNzYgNjUuNjg1NTkxMSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xODEuMDY5OTY2LDAuNTM0ODEwMTI3IEwxMjIuMzE1NywxNjguNDY1MTkiIGlkPSJMaW5lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTExIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzAwLjAwMDAwMCwgNTkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik0yMDguMjYzMDYyLDE0NS45OTI1MTcgTDIxNS45MzMxOTUsMTAxLjI1NjMzOCBMMjE2LjExMDgyNywxMDAuMjIwMjk1IEwyMTUuMzU4MjM2LDk5LjQ4NjQzOTYgTDE4Mi44NjYzNzgsNjcuODAzNDY1OSBMMjI3Ljc2ODM1Nyw2MS4yNzY1MTA5IEwyMjguODA4OTk4LDYxLjEyNTI0MzIgTDIyOS4yNzQyNTcsNjAuMTgyMTkwMiBMMjQ5LjM1NDM4LDE5LjQ4MDk3NzUgTDI2OS40MzQ1MDMsNjAuMTgyMTkwMiBMMjY5Ljg5OTc2Miw2MS4xMjUyNDMyIEwyNzAuOTQwNDAzLDYxLjI3NjUxMDkgTDMxNS44NDIzODIsNjcuODAzNDY1OSBMMjgzLjM1MDUyNCw5OS40ODY0Mzk2IEwyODIuNTk3OTMzLDEwMC4yMjAyOTUgTDI4Mi43NzU1NjUsMTAxLjI1NjMzOCBMMjkwLjQ0NTY5OCwxNDUuOTkyNTE3IEwyNTAuMjg1MzIxLDEyNC44NzE0NjQgTDI0OS4zNTQzOCwxMjQuMzgxODY1IEwyNDguNDIzNDM5LDEyNC44NzE0NjQgTDIwOC4yNjMwNjIsMTQ1Ljk5MjUxNyBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQb2x5Z29uLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBwb2ludHM9IjYyLjA0NTA3OTMgMjAuMjAyNTMxNiAxMjQuMDkwMTU5IDY1LjI5NjkxODkgMTAwLjM5MTA0NyAxMzguMjYxMTcgMjMuNjk5MTExNSAxMzguMjYxMTcgOS40NTkxMDAxN2UtMTQgNjUuMjk2OTE4OSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNzkuMTAwOTkzLDAuNTMxNjQ1NTcgTDEyMC42NDA3MjgsMTY3LjQ2ODM1NCIgaWQ9IkxpbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Im9wdGlvbi1tYXAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuMDAwMDAwLCA0MDMuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjAiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjc5LjAwMDAwMCwgMzguMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBpZD0iQ29tYmluZWQtU2hhcGUiIHN0cm9rZT0iIzlCOUI5QiIgbWFzaz0idXJsKCNtYXNrLTcpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1kYXNoYXJyYXk9IjEwLDUiIHhsaW5rOmhyZWY9IiNwYXRoLTYiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDb21iaW5lZC1TaGFwZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC04Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik0yMy45MzE0MjQ4LDE1NS4yMjQ5OTYgQzkuOTY4NTY3MTYsMTQwLjc5NDc4NyAyLDEyMS41MzI0MDQgMiwxMDEgQzIsNTcuOTIxNzg5NSAzNi45MjE3ODk1LDIzIDgwLDIzIEMxMDAuNTMyNDA0LDIzIDExOS43OTQ3ODcsMzAuOTY4NTY3MiAxMzQuMjI0OTk2LDQ0LjkzMTQyNDggTDIzLjkzMTQyNDgsMTU1LjIyNDk5NiBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjEwMjIiIHk9IjIiIHdpZHRoPSIxOTYiIGhlaWdodD0iMTk2IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1OS4wMDAwMDAsIDM4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgaWQ9IkNvbWJpbmVkLVNoYXBlIiBzdHJva2U9IiM5QjlCOUIiIG1hc2s9InVybCgjbWFzay0xMCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgc3Ryb2tlLWRhc2hhcnJheT0iMTAsNSIgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IkNvbWJpbmVkLVNoYXBlIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik0xMDk1LjAxMjYzLDE0NS4xNDM3OTUgTDEwOTguNzY4NzYsMTIzLjI0Mzg1NSBMMTA5OC45NDY1LDEyMi4yMDc1MjUgTDEwOTguMTkzNTcsMTIxLjQ3MzU5MiBMMTA1OC4yOTc5Miw4Mi41ODQ5NTAxIEwxMTEzLjQzMjM1LDc0LjU3MzQ0OTMgTDExMTQuNDcyODgsNzQuNDIyMjUwOCBMMTExNC45MzgyMiw3My40NzkzNjY3IEwxMTM5LjU5NTA5LDIzLjUxOTEwMjkgTDExNjQuMjUxOTUsNzMuNDc5MzY2NyBMMTE2NC43MTcyOSw3NC40MjIyNTA4IEwxMTY1LjYwNTE2LDc0LjU1MTI2NSBMMTA5NS4wMTI2MywxNDUuMTQzNzk1IFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iMiIgeT0iMiIgd2lkdGg9IjE5NiIgaGVpZ2h0PSIxOTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTIiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI3MjkiIGN5PSIxNDAiIHI9Ijc4Ij48L2NpcmNsZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik05ODkuMzUwNjc2LDIxOC4xNTU0OTggTDk5OC43Njg3NiwxNjMuMjQzODU1IEw5OTguOTQ2NTA0LDE2Mi4yMDc1MjUgTDk5OC4xOTM1NjcsMTYxLjQ3MzU5MiBMOTU4LjI5NzkyMiwxMjIuNTg0OTUgTDEwMTMuNDMyMzUsMTE0LjU3MzQ0OSBMMTAxNC40NzI4OCwxMTQuNDIyMjUxIEwxMDE0LjkzODIyLDExMy40NzkzNjcgTDEwMzkuNTk1MDksNjMuNTE5MTAyOSBMMTA2NC4yNTE5NSwxMTMuNDc5MzY3IEwxMDY0LjcxNzI5LDExNC40MjIyNTEgTDEwNjUuNzU3ODMsMTE0LjU3MzQ0OSBMMTEyMC44OTIyNSwxMjIuNTg0OTUgTDEwODAuOTk2NjEsMTYxLjQ3MzU5MiBMMTA4MC4yNDM2NywxNjIuMjA3NTI1IEwxMDgwLjQyMTQxLDE2My4yNDM4NTUgTDEwODkuODM5NSwyMTguMTU1NDk4IEwxMDQwLjUyNTc3LDE5Mi4yMjk3MzcgTDEwMzkuNTk1MDksMTkxLjc0MDQ0OSBMMTAzOC42NjQ0LDE5Mi4yMjk3MzcgTDk4OS4zNTA2NzYsMjE4LjE1NTQ5OCBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUGF0aC0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiMwMDAwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTQiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNODUzLDEyMiBMODkxLDEyMiBMODkzLDEyMiBMODkzLDEyMCBMODkzLDEwNC43ODU2MTUgTDkyOC4xNzE1MTcsMTM5LjUxNTUyNSBMODkzLDE3NS4xMjg2NDkgTDg5MywxNjAgTDg5MywxNTggTDg5MSwxNTggTDg1MywxNTggTDg1MywxMjIgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIxMTgxIDEyMCAxMjIxIDEyMCAxMjIxIDEwMCAxMjYxIDEzOS40OTc3NjcgMTIyMSAxODAgMTIyMSAxNjAgMTE4MSAxNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJPcHRpb25bQV0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyNTUuNiIgeT0iMzE0Ij5PcHRpb25bQV08L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9Im1hcCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI2NCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI0OTguNCIgeT0iMTU2Ij5tYXA8L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9Ik9wdGlvbltCXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEyNzkuNiIgeT0iMzE0Ij5PcHRpb25bQl08L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstQiIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjgyNS40IiB5PSIzMTQiPkEgPSZndDsgQjwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Imxpc3QtbWFwIj4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJCYWNrZ3JvdW5kIiBmaWxsPSIjRkZGRkZGIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTc2MSIgaGVpZ2h0PSIzNjAiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1OS4wMDAwMDAsIDQwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iODAiIGN5PSI4MCIgcj0iNzgiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTE2Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjEwMCIgY3k9IjEwMCIgcj0iNzgiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTE3Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjEyMCIgY3k9IjEyMCIgcj0iNzgiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEtQ29weSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTE4Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNzI3IiBjeT0iMTQzIiByPSI3OCI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iU3Rhci0xLUNvcHkiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik05ODcuMzUwNjc2LDIyMS4xNTU0OTggTDk5Ni43Njg3NiwxNjYuMjQzODU1IEw5OTYuOTQ2NTA0LDE2NS4yMDc1MjUgTDk5Ni4xOTM1NjcsMTY0LjQ3MzU5MiBMOTU2LjI5NzkyMiwxMjUuNTg0OTUgTDEwMTEuNDMyMzUsMTE3LjU3MzQ0OSBMMTAxMi40NzI4OCwxMTcuNDIyMjUxIEwxMDEyLjkzODIyLDExNi40NzkzNjcgTDEwMzcuNTk1MDksNjYuNTE5MTAyOSBMMTA2Mi4yNTE5NSwxMTYuNDc5MzY3IEwxMDYyLjcxNzI5LDExNy40MjIyNTEgTDEwNjMuNzU3ODMsMTE3LjU3MzQ0OSBMMTExOC44OTIyNSwxMjUuNTg0OTUgTDEwNzguOTk2NjEsMTY0LjQ3MzU5MiBMMTA3OC4yNDM2NywxNjUuMjA3NTI1IEwxMDc4LjQyMTQxLDE2Ni4yNDM4NTUgTDEwODcuODM5NSwyMjEuMTU1NDk4IEwxMDM4LjUyNTc3LDE5NS4yMjk3MzcgTDEwMzcuNTk1MDksMTk0Ljc0MDQ0OSBMMTAzNi42NjQ0LDE5NS4yMjk3MzcgTDk4Ny4zNTA2NzYsMjIxLjE1NTQ5OCBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtQ29weSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTI5OS4wMDAwMDAsIDQwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMjAiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTM1LjM1MDY3NTgsMTU5LjE1NTQ5OCBMNDQuNzY4NzU5OSwxMDQuMjQzODU1IEw0NC45NDY1MDQ0LDEwMy4yMDc1MjUgTDQ0LjE5MzU2NjYsMTAyLjQ3MzU5MiBMNC4yOTc5MjIyOCw2My41ODQ5NTAxIEw1OS40MzIzNDY3LDU1LjU3MzQ0OTMgTDYwLjQ3Mjg4MTEsNTUuNDIyMjUwOCBMNjAuOTM4MjIyMyw1NC40NzkzNjY3IEw4NS41OTUwODY1LDQuNTE5MTAyOTIgTDExMC4yNTE5NTEsNTQuNDc5MzY2NyBMMTEwLjcxNzI5Miw1NS40MjIyNTA4IEwxMTEuNzU3ODI2LDU1LjU3MzQ0OTMgTDE2Ni44OTIyNTEsNjMuNTg0OTUwMSBMMTI2Ljk5NjYwNiwxMDIuNDczNTkyIEwxMjYuMjQzNjY5LDEwMy4yMDc1MjUgTDEyNi40MjE0MTMsMTA0LjI0Mzg1NSBMMTM1LjgzOTQ5NywxNTkuMTU1NDk4IEw4Ni41MjU3Njg3LDEzMy4yMjk3MzcgTDg1LjU5NTA4NjUsMTMyLjc0MDQ0OSBMODQuNjY0NDA0MiwxMzMuMjI5NzM3IEwzNS4zNTA2NzU4LDE1OS4xNTU0OTggWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iU3Rhci0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik01MS4zNTA2NzU4LDE3OS4xNTU0OTggTDYwLjc2ODc1OTksMTI0LjI0Mzg1NSBMNjAuOTQ2NTA0NCwxMjMuMjA3NTI1IEw2MC4xOTM1NjY2LDEyMi40NzM1OTIgTDIwLjI5NzkyMjMsODMuNTg0OTUwMSBMNzUuNDMyMzQ2Nyw3NS41NzM0NDkzIEw3Ni40NzI4ODExLDc1LjQyMjI1MDggTDc2LjkzODIyMjMsNzQuNDc5MzY2NyBMMTAxLjU5NTA4NiwyNC41MTkxMDI5IEwxMjYuMjUxOTUxLDc0LjQ3OTM2NjcgTDEyNi43MTcyOTIsNzUuNDIyMjUwOCBMMTI3Ljc1NzgyNiw3NS41NzM0NDkzIEwxODIuODkyMjUxLDgzLjU4NDk1MDEgTDE0Mi45OTY2MDYsMTIyLjQ3MzU5MiBMMTQyLjI0MzY2OSwxMjMuMjA3NTI1IEwxNDIuNDIxNDEzLDEyNC4yNDM4NTUgTDE1MS44Mzk0OTcsMTc5LjE1NTQ5OCBMMTAyLjUyNTc2OSwxNTMuMjI5NzM3IEwxMDEuNTk1MDg2LDE1Mi43NDA0NDkgTDEwMC42NjQ0MDQsMTUzLjIyOTczNyBMNTEuMzUwNjc1OCwxNzkuMTU1NDk4IFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0yMiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNNjkuMzUwNjc1OCwyMDIuMTU1NDk4IEw3OC43Njg3NTk5LDE0Ny4yNDM4NTUgTDc4Ljk0NjUwNDQsMTQ2LjIwNzUyNSBMNzguMTkzNTY2NiwxNDUuNDczNTkyIEwzOC4yOTc5MjIzLDEwNi41ODQ5NSBMOTMuNDMyMzQ2Nyw5OC41NzM0NDkzIEw5NC40NzI4ODExLDk4LjQyMjI1MDggTDk0LjkzODIyMjMsOTcuNDc5MzY2NyBMMTE5LjU5NTA4Niw0Ny41MTkxMDI5IEwxNDQuMjUxOTUxLDk3LjQ3OTM2NjcgTDE0NC43MTcyOTIsOTguNDIyMjUwOCBMMTQ1Ljc1NzgyNiw5OC41NzM0NDkzIEwyMDAuODkyMjUxLDEwNi41ODQ5NSBMMTYwLjk5NjYwNiwxNDUuNDczNTkyIEwxNjAuMjQzNjY5LDE0Ni4yMDc1MjUgTDE2MC40MjE0MTMsMTQ3LjI0Mzg1NSBMMTY5LjgzOTQ5NywyMDIuMTU1NDk4IEwxMjAuNTI1NzY5LDE3Ni4yMjk3MzcgTDExOS41OTUwODYsMTc1Ljc0MDQ0OSBMMTE4LjY2NDQwNCwxNzYuMjI5NzM3IEw2OS4zNTA2NzU4LDIwMi4xNTU0OTggWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJQYXRoLTEtQ29weSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjMDAwMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIzIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTg1MSwxMjUgTDg4OSwxMjUgTDg5MSwxMjUgTDg5MSwxMjMgTDg5MSwxMDcuNzg1NjE1IEw5MjYuMTcxNTE3LDE0Mi41MTU1MjUgTDg5MSwxNzguMTI4NjQ5IEw4OTEsMTYzIEw4OTEsMTYxIEw4ODksMTYxIEw4NTEsMTYxIEw4NTEsMTI1IFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjExNzkgMTIzIDEyMTkgMTIzIDEyMTkgMTAzIDEyNTkgMTQyLjQ5Nzc2NyAxMjE5IDE4MyAxMjE5IDE2MyAxMTc5IDE2MyI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHRleHQgaWQ9Ikxpc3RbQV0tQ29weSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjI3MC44IiB5PSIzMTciPkxpc3RbQV08L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9Im1hcC1jb3B5IiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjY0IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjQ5Ni40IiB5PSIxNTkiPm1hcDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iTGlzdFtCXS1Db3B5IiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTMxNC44IiB5PSIzMTciPkxpc3RbQl08L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstQi1Db3B5IiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iODIzLjQiIHk9IjMxNyI+QSA9Jmd0OyBCPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+" style="width: 80%">
      <figcaption>Figure 1: Type chart: mapping over List, Option, and Either</figcaption>
    </figure>
    <p>Because <code>map</code> leaves the structure of the context unchanged, we can call it repeatedly to sequence multiple computations on the contents of an initial data structure:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).<br>  map(n <span style="color: #d73948">=></span> n + <span style="color: #b60157">1</span>).<br>  map(n <span style="color: #d73948">=></span> n * <span style="color: #b60157">2</span>).<br>  map(n <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>n<span style="color: #198810">}</span><span style="color: #198810">!</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: List[String] = List("4!", "6!", "8!")</span></code></pre>
    <p>We should think of <code>map</code> not as an iteration pattern, but as a way of sequencing computations on values ignoring some complication dictated by the relevant data type:</p>
    <ul>
      <li><code>Option</code>—the value may or may not be present;</li>
      <li><code>Either</code>—there may be a value or an error;</li>
      <li><code>List</code>—there may be zero or more values.</li>
    </ul>
    <h3 id="loc-190">9.2. More Examples of Functors</h3>
    <p>The <code>map</code> methods of <code>List</code>, <code>Option</code>, and <code>Either</code> apply functions eagerly. However, the idea of sequencing computations is more general than this. Let’s investigate the behaviour of some other functors that apply the pattern in different ways.</p>
    <h4 id="loc-191">9.2.1. Futures</h4>
    <p><code>Future</code> is a functor that sequences asynchronous computations by queueing them and applying them as their predecessors complete. The type signature of its <code>map</code> method, shown in <a href="#loc-192">Figure 2</a>, has the same shape as the signatures above. However, the behaviour is very different.</p>
    <figure id="loc-192">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1NjVweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE1NjUgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MCAoMzM3NjIpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPmZ1dHVyZS1tYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xIiBjeD0iODAiIGN5PSI4MCIgcng9IjgwIiByeT0iODAiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE2MCIgaGVpZ2h0PSIxNjAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMyIgY3g9IjYzOCIgY3k9IjE0MyIgcng9IjgwIiByeT0iODAiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay00IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE2MCIgaGVpZ2h0PSIxNjAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNSIgcG9pbnRzPSI5NDIuNTk1MDg2IDE5NyA4ODkuNjk0NDE0IDIyNC44MTE1MjkgODk5Ljc5NzU0MyAxNjUuOTA1NzY1IDg1NyAxMjQuMTg4NDcxIDkxNi4xNDQ3NSAxMTUuNTk0MjM1IDk0Mi41OTUwODYgNjIgOTY5LjA0NTQyMyAxMTUuNTk0MjM1IDEwMjguMTkwMTcgMTI0LjE4ODQ3MSA5ODUuMzkyNjMgMTY1LjkwNTc2NSA5OTUuNDk1NzU5IDIyNC44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay02IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MS4xOTAxNzMiIGhlaWdodD0iMTYyLjgxMTUyOSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC03IiBwb2ludHM9Ijg1LjU5NTA4NjUgMTM1IDMyLjY5NDQxMzggMTYyLjgxMTUyOSA0Mi43OTc1NDMyIDEwMy45MDU3NjUgNS4zMjkwNzA1MmUtMTQgNjIuMTg4NDcwNSA1OS4xNDQ3NTAxIDUzLjU5NDIzNTMgODUuNTk1MDg2NSAwIDExMi4wNDU0MjMgNTMuNTk0MjM1MyAxNzEuMTkwMTczIDYyLjE4ODQ3MDUgMTI4LjM5MjYzIDEwMy45MDU3NjUgMTM4LjQ5NTc1OSAxNjIuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stOCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzEuMTkwMTczIiBoZWlnaHQ9IjE2Mi44MTE1MjkiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC03Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtOSIgcG9pbnRzPSI3NTYgMTIzIDc5NiAxMjMgNzk2IDEwMyA4MzYgMTQyLjQ5Nzc2NyA3OTYgMTgzIDc5NiAxNjMgNzU2IDE2MyI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTEwIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgPC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImZ1dHVyZS1tYXAiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE1NjUiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODYuMDAwMDAwLCA2MC4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEiIG1hc2s9InVybCgjbWFzay0yKSIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay00KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay02KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjIyLjAwMDAwMCwgNjAuMDAwMDAwKSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stOCkiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiMwMDAwMDAiIHhsaW5rOmhyZWY9IiNwYXRoLTkiPjwvdXNlPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjEwNjAgMTIzIDExMDAgMTIzIDExMDAgMTAzIDExNDAgMTQyLjQ5Nzc2NyAxMTAwIDE4MyAxMTAwIDE2MyAxMDYwIDE2MyI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iRnV0dXJlW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxNTIuNiIgeT0iMzE3Ij5GdXR1cmVbQV08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJGdXR1cmVbQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjExOTYuNiIgeT0iMzE3Ij5GdXR1cmVbQl08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjczMC40IiB5PSIzMTciPkEgPSZndDsgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHBhdGggZD0iTTM2My4zMTUzNjEsMjEwLjQ2NzcyMSBDMzg1LjAwNjE2OSwxOTkuOTkyNDcxIDM5NiwxODMuOTYxMjE0IDM5NiwxNjEuOCBDMzk2LDEzNS43NTAyMzIgMzgwLjgwOTU4MywxMTguMTcwMzU5IDM1MC45MTA4ODksMTA4LjEyODE5IEMzNTQuOTA3Mjg4LDEwMS4wNzgxMDQgMzU3LjEzMjkyNCw5My4yNDcyNTE1IDM1Ny4xMzI5MjQsODUgQzM1Ny4xMzI5MjQsNTQuMDcyMDU0IDMyNS44MzM0LDI5IDI4Ny4yMjM0ODIsMjkgQzI2OC4xNzQyMzMsMjkgMjUwLjkwNDQ4OCwzNS4xMDMwNjI4IDIzOC4yOTUyOTksNDUuMDAxMzYgQzIzMy44ODc4NzIsNDMuOTU0ODc1NiAyMjkuMjgxNzcxLDQzLjQgMjI0LjU0MjE2OSw0My40IEMxOTIuNjgyNjU4LDQzLjQgMTY2Ljg1NTQyMiw2OC40NzIwNTQgMTY2Ljg1NTQyMiw5OS40IEMxNjYuODU1NDIyLDEwMy45MDkyIDE2Ny40MDQ0MjUsMTA4LjI5MzkyMyAxNjguNDQxMDgzLDExMi40OTQ2MTUgQzE0My42ODAwMDksMTIyLjk1MjM3MyAxMzAsMTM5LjE4NDE2NyAxMzAsMTYxLjggQzEzMCwxOTcuMjQ4NjI2IDE2My42MDkzNDUsMjE3LjAxMjgwOCAyMjAuODE5ODAyLDIyMy40NDE1OTQgQzIzMy43ODc2NzgsMjQxLjAzNTY5NiAyNTkuMjk0MDYxLDI1MyAyODguNjM4NTU0LDI1MyBDMzI0Ljc0MDkzNiwyNTMgMzU1LjAzMzg1NywyMzQuODkwNTIxIDM2My4zMTUzNiwyMTAuNDY3NzI1IFoiIGlkPSJDb21iaW5lZC1TaGFwZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTE0MDkuMzE1MzYsMjE5LjQ2NzcyMSBDMTQzMS4wMDYxNywyMDguOTkyNDcxIDE0NDIsMTkyLjk2MTIxNCAxNDQyLDE3MC44IEMxNDQyLDE0NC43NTAyMzIgMTQyNi44MDk1OCwxMjcuMTcwMzU5IDEzOTYuOTEwODksMTE3LjEyODE5IEMxNDAwLjkwNzI5LDExMC4wNzgxMDQgMTQwMy4xMzI5MiwxMDIuMjQ3MjUxIDE0MDMuMTMyOTIsOTQgQzE0MDMuMTMyOTIsNjMuMDcyMDU0IDEzNzEuODMzNCwzOCAxMzMzLjIyMzQ4LDM4IEMxMzE0LjE3NDIzLDM4IDEyOTYuOTA0NDksNDQuMTAzMDYyOCAxMjg0LjI5NTMsNTQuMDAxMzYgQzEyNzkuODg3ODcsNTIuOTU0ODc1NiAxMjc1LjI4MTc3LDUyLjQgMTI3MC41NDIxNyw1Mi40IEMxMjM4LjY4MjY2LDUyLjQgMTIxMi44NTU0Miw3Ny40NzIwNTQgMTIxMi44NTU0MiwxMDguNCBDMTIxMi44NTU0MiwxMTIuOTA5MiAxMjEzLjQwNDQyLDExNy4yOTM5MjMgMTIxNC40NDEwOCwxMjEuNDk0NjE1IEMxMTg5LjY4MDAxLDEzMS45NTIzNzMgMTE3NiwxNDguMTg0MTY3IDExNzYsMTcwLjggQzExNzYsMjA2LjI0ODYyNiAxMjA5LjYwOTM0LDIyNi4wMTI4MDggMTI2Ni44MTk4LDIzMi40NDE1OTQgQzEyNzkuNzg3NjgsMjUwLjAzNTY5NiAxMzA1LjI5NDA2LDI2MiAxMzM0LjYzODU1LDI2MiBDMTM3MC43NDA5NCwyNjIgMTQwMS4wMzM4NiwyNDMuODkwNTIxIDE0MDkuMzE1MzYsMjE5LjQ2NzcyNSBaIiBpZD0iQ29tYmluZWQtU2hhcGUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0Ij48L3BhdGg+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJtYXAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1Cb2xkLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjQiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjRjZBNjIzIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI0MjIuNCIgeT0iMTU4Ij5tYXA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=" style="width: 80%">
      <figcaption>Figure 2: Type chart: mapping over a Future</figcaption>
    </figure>
    <p>When we work with a <code>Future</code> we have no guarantees about its internal state. The wrapped computation may be ongoing, complete, or rejected. If the <code>Future</code> is complete, our mapping function can be called immediately. If not, some underlying thread pool queues the function call and comes back to it later. We don’t know <em>when</em> our functions will be called, but we do know <em>what order</em> they will be called in. In this way, <code>Future</code> provides the same sequencing behaviour seen in <code>List</code>, <code>Option</code>, and <code>Either</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.{Future, Await}<br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global<br><span style="color: #d73948">import</span> scala.concurrent.duration.<span style="color: #d73948">_</span><br><br><span style="color: #d73948">val</span> future: <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">String</span>] =<br>  <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">123</span>).<br>    map(n <span style="color: #d73948">=></span> n + <span style="color: #b60157">1</span>).<br>    map(n <span style="color: #d73948">=></span> n * <span style="color: #b60157">2</span>).<br>    map(n <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>n<span style="color: #198810">}</span><span style="color: #198810">!</span><span style="color: #198810">"</span>)</code></pre>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(future, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "248!"</span></code></pre>
    <div>
      <h5>Futures and Referential Transparency</h5>
      <p>Note that Scala’s <code>Futures</code> aren’t a great example of pure functional programming because they aren’t <strong>referentially transparent</strong>. <code>Future</code> always computes and caches a result and there’s no way for us to tweak this behaviour. This means we can get unpredictable results when we use <code>Future</code> to wrap side-effecting computations. For example:</p>
      <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.util.Random<br><br><span style="color: #d73948">val</span> future1 <span style="color: #d73948">=</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Initialize Random with a fixed seed:</span><br>  <span style="color: #d73948">val</span> r <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Random</span>(<span style="color: #b60157">0</span><span style="color: #d73948">L</span>)<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> nextInt has the side-effect of moving to</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> the next random number in the sequence:</span><br>  <span style="color: #d73948">val</span> x <span style="color: #d73948">=</span> <span style="color: #4b69c6">Future</span>(r.nextInt())<br><br>  <span style="color: #d73948">for</span> {<br>    a <span style="color: #d73948">&lt;-</span> x<br>    b <span style="color: #d73948">&lt;-</span> x<br>  } <span style="color: #d73948">yield</span> (a, b)<br>}<br><br><span style="color: #d73948">val</span> future2 <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> r <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Random</span>(<span style="color: #b60157">0</span><span style="color: #d73948">L</span>)<br><br>  <span style="color: #d73948">for</span> {<br>    a <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Future</span>(r.nextInt())<br>    b <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Future</span>(r.nextInt())<br>  } <span style="color: #d73948">yield</span> (a, b)<br>}</code></pre>
      <pre><code data-lang="scala"><span style="color: #d73948">val</span> result1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Await</span>.result(future1, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> result1: Tuple2[Int, Int] = (-1155484576, -1155484576)</span><br><span style="color: #d73948">val</span> result2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Await</span>.result(future2, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> result2: Tuple2[Int, Int] = (-1155484576, -723955400)</span></code></pre>
      <p>Ideally we would like <code>result1</code> and <code>result2</code> to contain the same value. However, the computation for <code>future1</code> calls <code>nextInt</code> once and the computation for <code>future2</code> calls it twice. Because <code>nextInt</code> returns a different result every time we get a different result in each case.</p>
      <p>This kind of discrepancy makes it hard to reason about programs involving <code>Futures</code> and side-effects. There also are other problematic aspects of <code>Future's</code> behaviour, such as the way it always starts computations immediately rather than allowing the user to dictate when the program should run. For more information see <a href="https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/">this excellent Reddit answer<a id="loc-193" href="#loc-627" role="doc-noteref"><sup>51</sup></a></a> by Rob Norris.</p>
      <p>When we look at Cats Effect we’ll see that the <code>IO</code> type solves these problems.</p>
    </div>
    <p>If <code>Future</code> isn’t referentially transparent, perhaps we should look at another similar data-type that is. You should recognise this one…</p>
    <h4 id="loc-194">9.2.2. Functions (?!)</h4>
    <p>It turns out that single argument functions are also functors. To see this we have to tweak the types a little. A function <code>A => B</code> has two type parameters: the parameter type <code>A</code> and the result type <code>B</code>. To coerce them to the correct shape we can fix the parameter type and let the result type vary:</p>
    <ul>
      <li>start with <code>X => A</code>;</li>
      <li>supply a function <code>A => B</code>;</li>
      <li>get back <code>X => B</code>.</li>
    </ul>
    <p>If we alias <code>X => A</code> as <code>MyFunc[A]</code>, we see the same pattern of types we saw with the other examples in this chapter. We also see this in <a href="#loc-195">Figure 3</a>:</p>
    <ul>
      <li>start with <code>MyFunc[A]</code>;</li>
      <li>supply a function <code>A => B</code>;</li>
      <li>get back <code>MyFunc[B]</code>.</li>
    </ul>
    <figure id="loc-195">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1NThweCIgaGVpZ2h0PSIzMjVweCIgdmlld0JveD0iMCAwIDE1NTggMzI1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MCAoMzM3NjIpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPmZ1bmN0aW9uLW1hcDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTEiIGN4PSIyNDguNDAzNjUzIiBjeT0iNTYuNTMzNzQyMyIgcng9IjUxLjQwMzY1MyIgcnk9IjUxLjUzMzc0MjMiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMi44MDczMDYiIGhlaWdodD0iMTAzLjA2NzQ4NSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0zIiBwb2ludHM9IjEyNC4zNzIzMDYgNDEuMjk0NDc4NSAxNTAuMDc0MTMyIDQxLjI5NDQ3ODUgMTUwLjA3NDEzMiAyOC40MTEwNDI5IDE3NS43NzU5NTkgNTMuODU0Mzg5OSAxNTAuMDc0MTMyIDc5Ljk0NDc4NTMgMTUwLjA3NDEzMiA2Ny4wNjEzNDk3IDEyNC4zNzIzMDYgNjcuMDYxMzQ5NyI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNTEuNDAzNjUzIiBoZWlnaHQ9IjUxLjUzMzc0MjMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtNSIgY3g9IjUxLjQwMzY1MyIgY3k9IjUyLjE3NzkxNDEiIHJ4PSI1MS40MDM2NTMiIHJ5PSI1MS41MzM3NDIzIj48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMDIuODA3MzA2IiBoZWlnaHQ9IjEwMy4wNjc0ODUiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNyIgcG9pbnRzPSIyNDUuNDgwODk4IDg2Ljk2MzE5MDIgMjExLjQ4OTggMTA0Ljg3ODU5MyAyMTcuOTgxNTIyIDY2LjkzMzE2MTMgMTkwLjQ4MjE0NiA0MC4wNjAwNTc3IDIyOC40ODUzNDkgMzQuNTIzODkzOSAyNDUuNDgwODk4IDAgMjYyLjQ3NjQ0NyAzNC41MjM4OTM5IDMwMC40Nzk2NDkgNDAuMDYwMDU3NyAyNzIuOTgwMjczIDY2LjkzMzE2MTMgMjc5LjQ3MTk5NSAxMDQuODc4NTkzIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stOCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMDkuOTk3NTAzIiBoZWlnaHQ9IjEwNC44Nzg1OTMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC03Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtOSIgcG9pbnRzPSIxMjIuMzcyMzA2IDM5LjI5NDQ3ODUgMTQ4LjA3NDEzMiAzOS4yOTQ0Nzg1IDE0OC4wNzQxMzIgMjYuNDExMDQyOSAxNzMuNzc1OTU5IDUxLjg1NDM4OTkgMTQ4LjA3NDEzMiA3Ny45NDQ3ODUzIDE0OC4wNzQxMzIgNjUuMDYxMzQ5NyAxMjIuMzcyMzA2IDY1LjA2MTM0OTciPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI1MS40MDM2NTMiIGhlaWdodD0iNTEuNTMzNzQyMyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTkiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0xMSIgcG9pbnRzPSIyNTQuNDgwODk4IDg3Ljk2MzE5MDIgMjIwLjQ4OTggMTA1Ljg3ODU5MyAyMjYuOTgxNTIyIDY3LjkzMzE2MTMgMTk5LjQ4MjE0NiA0MS4wNjAwNTc3IDIzNy40ODUzNDkgMzUuNTIzODkzOSAyNTQuNDgwODk4IDEgMjcxLjQ3NjQ0NyAzNS41MjM4OTM5IDMwOS40Nzk2NDkgNDEuMDYwMDU3NyAyODEuOTgwMjczIDY3LjkzMzE2MTMgMjg4LjQ3MTk5NSAxMDUuODc4NTkzIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTIiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTA5Ljk5NzUwMyIgaGVpZ2h0PSIxMDQuODc4NTkzIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0xMyIgcG9pbnRzPSIxMzEuMzcyMzA2IDQwLjI5NDQ3ODUgMTU3LjA3NDEzMiA0MC4yOTQ0Nzg1IDE1Ny4wNzQxMzIgMjcuNDExMDQyOSAxODIuNzc1OTU5IDUyLjg1NDM4OTkgMTU3LjA3NDEzMiA3OC45NDQ3ODUzIDE1Ny4wNzQxMzIgNjYuMDYxMzQ5NyAxMzEuMzcyMzA2IDY2LjA2MTM0OTciPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI1MS40MDM2NTMiIGhlaWdodD0iNTEuNTMzNzQyMyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iZnVuY3Rpb24tbWFwIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNTU4IiBoZWlnaHQ9IjMyNSI+PC9yZWN0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU2LjAwMDAwMCwgNTEuMDAwMDAwKSIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgbWFzaz0idXJsKCNtYXNrLTIpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUGF0aC0xIiBtYXNrPSJ1cmwoI21hc2stNCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iIzAwMDAwMCIgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbiIgc3Ryb2tlLXdpZHRoPSI0IiBwb2ludHM9IjUzIDAuMDY1ODYxNzQyNCAxMDUuMzM5MjYzIDM4LjA5MjU2MjIgODUuMzQ3NDQzNSA5OS42MjEwNTYgMjAuNjUyNTU2NSA5OS42MjEwNTYgMC42NjA3MzcwMyAzOC4wOTI1NjIyIj48L3BvbHlnb24+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDY0Ny4wMDAwMDAsIDUzLjAwMDAwMCkiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4Ij4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgbWFzaz0idXJsKCNtYXNrLTYpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMSIgbWFzaz0idXJsKCNtYXNrLTgpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC03Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgbWFzaz0idXJsKCNtYXNrLTEwKSIgZmlsbD0iIzAwMDAwMCIgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwODguMDAwMDAwLCA1Mi4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stMTIpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgbWFzaz0idXJsKCNtYXNrLTE0KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjMDAwMDAwIiB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbiIgc3Ryb2tlLXdpZHRoPSI0IiBwb2ludHM9IjUyLjY3ODUyNTkgMC44NTMxNjk1NDkgMTA1LjM1NzA1MiAzOS4xMjYzNTkgODUuMjM1NjQ1NCAxMDEuMDUzNjggMjAuMTIxNDA2NCAxMDEuMDUzNjggLTYuMzk0ODg0NjJlLTE0IDM5LjEyNjM1OSI+PC9wb2x5Z29uPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iOTg0IDg1IDEwMjQgODUgMTAyNCA2NSAxMDY0IDEwNC40OTc3NjcgMTAyNCAxNDUgMTAyNCAxMjUgOTg0IDEyNSI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iWC09Jmd0Oy1BIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyMjUuNCIgeT0iMjgyIj5YID0mZ3Q7IEE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJYLT0mZ3Q7LUIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjExNzMuNCIgeT0iMjgyIj5YID0mZ3Q7IEI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjcyMC40IiB5PSIyODIiPkEgPSZndDsgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Im1hcCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI2NCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjQ5NS40IiB5PSIxMjMiPm1hcDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==" style="width: 80%">
      <figcaption>Figure 3: Type chart: mapping over a Function1</figcaption>
    </figure>
    <p>In other words, “mapping” over a <code>Function1</code> is function composition:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*     <span style="color: #74747c">//</span><span style="color: #74747c"> for map</span><br><br><span style="color: #d73948">val</span> func1: <span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span> =<br>  (x: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> x.toDouble<br><br><span style="color: #d73948">val</span> func2: <span style="color: #d73948">Double</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span> =<br>  (y: <span style="color: #d73948">Double</span>) <span style="color: #d73948">=></span> y * <span style="color: #b60157">2</span></code></pre>
    <pre><code data-lang="scala">(func1.map(func2))(<span style="color: #b60157">1</span>)     <span style="color: #74747c">//</span><span style="color: #74747c"> composition using map</span><br>(func1.andThen(func2))(<span style="color: #b60157">1</span>) <span style="color: #74747c">//</span><span style="color: #74747c"> composition using andThen</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Double = 2.0</span><br>func2(func1(<span style="color: #b60157">1</span>))           <span style="color: #74747c">//</span><span style="color: #74747c"> composition written out by hand</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Double = 2.0</span></code></pre>
    <p>How does this relate to our general pattern of sequencing operations? If we think about it, function composition <em>is</em> sequencing. We start with a function that performs a single operation and every time we use <code>map</code> we append another operation to the chain. Calling <code>map</code> doesn’t actually <em>run</em> any of the operations, but if we can pass an argument to the final function all of the operations are run in sequence. We can think of this as lazily queueing up operations similar to <code>Future</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func <span style="color: #d73948">=</span><br>  ((x: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> x.toDouble).<br>    map(x <span style="color: #d73948">=></span> x + <span style="color: #b60157">1</span>).<br>    map(x <span style="color: #d73948">=></span> x * <span style="color: #b60157">2</span>).<br>    map(x <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>x<span style="color: #198810">}</span><span style="color: #198810">!</span><span style="color: #198810">"</span>)</code></pre>
    <pre><code data-lang="scala">func(<span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: String = "248.0!"</span></code></pre>
    <div>
      <h5>Partial Unification</h5>
      <p>For the above examples to work, in versions of Scala before 2.13, we need to add the following compiler option to <code>build.sbt</code>:</p>
      <pre><code data-lang="scala">scalacOptions += <span style="color: #198810">"</span><span style="color: #198810">-Ypartial-unification</span><span style="color: #198810">"</span></code></pre>
      <p>otherwise we’ll get a compiler error:</p>
      <pre><code data-lang="scala">func1.map(func2)<br><span style="color: #74747c">//</span><span style="color: #74747c"> &lt;console>: error: value map is not a member of Int => Double</span><br><span style="color: #74747c">//</span><span style="color: #74747c">        func1.map(func2)</span><br>                ^</code></pre>
      <p>We’ll look at why this happens in detail in <a href="#loc-221">Section 9.8</a>.</p>
    </div>
    <h3 id="loc-196">9.3. Definition of a Functor</h3>
    <p>Every example we’ve looked at so far is a functor: a class that encapsulates sequencing computations. Formally, a functor is a type <code>F[A]</code> with an operation <code>map</code> with type <code>(A => B) => F[B]</code>. The general type chart is shown in <a href="#loc-197">Figure 4</a>.</p>
    <figure id="loc-197">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1NjdweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE1NjcgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MCAoMzM3NjIpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPmdlbmVyaWMtbWFwPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMSIgY3g9IjgwIiBjeT0iODAiIHJ4PSI4MCIgcnk9IjgwIj48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxNjAiIGhlaWdodD0iMTYwIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTMiIGN4PSI2MzIiIGN5PSIxNDAiIHJ4PSI4MCIgcnk9IjgwIj48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxNjAiIGhlaWdodD0iMTYwIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTUiIHBvaW50cz0iOTQ1LjU5NTA4NiAxOTQgODkyLjY5NDQxNCAyMjEuODExNTI5IDkwMi43OTc1NDMgMTYyLjkwNTc2NSA4NjAgMTIxLjE4ODQ3MSA5MTkuMTQ0NzUgMTEyLjU5NDIzNSA5NDUuNTk1MDg2IDU5IDk3Mi4wNDU0MjMgMTEyLjU5NDIzNSAxMDMxLjE5MDE3IDEyMS4xODg0NzEgOTg4LjM5MjYzIDE2Mi45MDU3NjUgOTk4LjQ5NTc1OSAyMjEuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzEuMTkwMTczIiBoZWlnaHQ9IjE2Mi44MTE1MjkiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNyIgcG9pbnRzPSI4NS41OTUwODY1IDEzNSAzMi42OTQ0MTM4IDE2Mi44MTE1MjkgNDIuNzk3NTQzMiAxMDMuOTA1NzY1IC0xLjE3MjM5NTUxZS0xMyA2Mi4xODg0NzA1IDU5LjE0NDc1MDEgNTMuNTk0MjM1MyA4NS41OTUwODY1IDAgMTEyLjA0NTQyMyA1My41OTQyMzUzIDE3MS4xOTAxNzMgNjIuMTg4NDcwNSAxMjguMzkyNjMgMTAzLjkwNTc2NSAxMzguNDk1NzU5IDE2Mi44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay04IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MS4xOTAxNzMiIGhlaWdodD0iMTYyLjgxMTUyOSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC05IiBwb2ludHM9Ijc1NCAxMjAgNzk0IDEyMCA3OTQgMTAwIDgzNCAxMzkuNDk3NzY3IDc5NCAxODAgNzk0IDE2MCA3NTQgMTYwIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTAiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODAiIGhlaWdodD0iODAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTEiIHg9IjE2NCIgeT0iMzciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiByeD0iOCI+PC9yZWN0PgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTEyIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xMSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEzIiB4PSIxMjA0IiB5PSIzNyIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iZ2VuZXJpYy1tYXAiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE1NjciIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODQuMDAwMDAwLCA1Ny4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEiIG1hc2s9InVybCgjbWFzay0yKSIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay00KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay02KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjIwLjAwMDAwMCwgNTcuMDAwMDAwKSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stOCkiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiMwMDAwMDAiIHhsaW5rOmhyZWY9IiNwYXRoLTkiPjwvdXNlPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjEwODQgMTIwIDExMjQgMTIwIDExMjQgMTAwIDExNjQgMTM5LjQ5Nzc2NyAxMTI0IDE4MCAxMTI0IDE2MCAxMDg0IDE2MCI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iRltBXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjEzLjYiIHk9IjMxNCI+RltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkZbQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEyNTcuNiIgeT0iMzE0Ij5GW0JdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1CIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI3MjguNCIgeT0iMzE0Ij5BID0mZ3Q7IEI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx1c2UgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xMikiIHN0cm9rZS13aWR0aD0iOCIgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgICAgICA8dXNlIGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTQpIiBzdHJva2Utd2lkdGg9IjgiIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICAgICAgPHRleHQgaWQ9Im1hcCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI2NCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjQwNC40IiB5PSIxNTUiPm1hcDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==" style="width: 80%">
      <figcaption>Figure 4: Type chart: generalised functor map</figcaption>
    </figure>
    <p>Cats encodes <code>Functor</code> as a type class, <a href="http://typelevel.org/cats/api/cats/Functor.html"><code>cats.Functor</code><a id="loc-198" href="#loc-628" role="doc-noteref"><sup>52</sup></a></a>, so the method looks a little different. It accepts the initial <code>F[A]</code> as a parameter alongside the transformation function. Here’s a simplified version of the definition:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Functor</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br>}</code></pre>
    <p>If you haven’t seen syntax like <code>F[_]</code> before, it’s time to take a brief detour to discuss <strong>type constructors</strong> and <strong>higher kinded types</strong>.</p>
    <div>
      <h5>Functor Laws</h5>
      <p>Functors guarantee the same semantics whether we sequence many small operations one by one, or combine them into a larger function before <code>mapping</code>. To ensure this is the case the following laws must hold:</p>
      <p><strong>Identity</strong>: calling <code>map</code> with the identity function is the same as doing nothing:</p>
      <pre><code data-lang="scala">fa.map(a <span style="color: #d73948">=></span> a) <span style="color: #d73948">==</span> fa</code></pre>
      <p><strong>Composition</strong>: <code>mapping</code> with two functions <code>f</code> and <code>g</code> is the same as <code>mapping</code> with <code>f</code> and then <code>mapping</code> with <code>g</code>:</p>
      <pre><code data-lang="scala">fa.map(g(f(<span style="color: #d73948">_</span>))) <span style="color: #d73948">==</span> fa.map(f).map(g)</code></pre>
    </div>
    <h3 id="loc-199">9.4. Higher Kinds and Type Constructors</h3>
    <p>Kinds are like types for types. They describe the number of “holes” in a type. We distinguish between regular types that have no holes and <strong>type constructors</strong> that have holes we can fill to produce types.</p>
    <p>For example, <code>List</code> is a type constructor with one hole. We fill that hole with a type to produce a regular type like <code>List[Int]</code> or <code>List[A]</code>. The trick is not to confuse type constructors with generic types. <code>List</code> is a type constructor, <code>List[A]</code> is a type:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>    <span style="color: #74747c">//</span><span style="color: #74747c"> type constructor, takes one parameter</span><br><span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] <span style="color: #74747c">//</span><span style="color: #74747c"> type, produced by applying a type parameter</span></code></pre>
    <p>There’s a close analogy here with functions and values. Functions are “value constructors”—they produce values when we supply parameters:</p>
    <pre><code data-lang="scala">math.abs    <span style="color: #74747c">//</span><span style="color: #74747c"> function, takes one parameter</span><br>math.abs(x) <span style="color: #74747c">//</span><span style="color: #74747c"> value, produced by applying a value parameter</span></code></pre>
    <p>In Scala we declare type constructors using underscores. This specifies how many “holes” the type constructor has. However, to use them we refer to just the name.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Declare F using underscores:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">myMethod</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] <span style="color: #d73948">=</span> {<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Reference F without underscores:</span><br>  <span style="color: #d73948">val</span> functor <span style="color: #d73948">=</span> <span style="color: #4b69c6">Functor</span>.apply[<span style="color: #4b69c6">F</span>]<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> ...</span><br>}</code></pre>
    <p>This is analogous to specifying function parameter types. When we declare a parameter we also give its type. However, to use them we refer to just the name.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Declare f specifying parameter types</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">f</span>(x: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Reference x without type</span><br>  x * <span style="color: #b60157">2</span></code></pre>
    <p>Armed with this knowledge of type constructors, we can see that the Cats definition of <code>Functor</code> allows us to create instances for any single-parameter type constructor, such as <code>List</code>, <code>Option</code>, <code>Future</code>, or a type alias such as <code>MyFunc</code>.</p>
    <div>
      <h5>Language Feature Imports</h5>
      <p>In versions of Scala before 2.13 we need to “enable” the higher kinded type language feature, to suppress warnings from the compiler, whenever we declare a type constructor with <code>A[_]</code> syntax. We can either do this with a “language import” as above:</p>
      <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.language.higherKinds</code></pre>
      <p>or by adding the following to <code>scalacOptions</code> in <code>build.sbt</code>:</p>
      <pre><code data-lang="scala">scalacOptions += <span style="color: #198810">"</span><span style="color: #198810">-language:higherKinds</span><span style="color: #198810">"</span></code></pre>
      <p>In practice we find the <code>scalacOptions</code> flag to be the simpler of the two options.</p>
    </div>
    <h3 id="loc-200">9.5. Functors in Cats</h3>
    <p>Let’s look at the implementation of functors in Cats. We’ll examine the same aspects we did for monoids: the <em>type class</em>, the <em>instances</em>, and the <em>syntax</em>.</p>
    <h4 id="loc-201">9.5.1. The Functor Type Class and Instances</h4>
    <p>The functor type class is <a href="http://typelevel.org/cats/api/cats/Functor.html"><code>cats.Functor</code><a id="loc-202" href="#loc-629" role="doc-noteref"><sup>53</sup></a></a>. We obtain instances using the standard <code>Functor.apply</code> method on the companion object. As usual, default instances are found on companion objects and do not have to be explicity imported:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*<br><span style="color: #d73948">import</span> cats.syntax.all.*</code></pre>
    <p>Once we have the imports we use the <code>map</code> method defined by <code>Functor</code>. In the examples below we are explicitly summoning the type class instances to avoid using the built-ins that are defined on <code>List</code> and <code>Option</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> list1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> list1: List[Int] = List(1, 2, 3)</span><br><span style="color: #d73948">val</span> list2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">List</span>].map(list1)(<span style="color: #d73948">_</span> * <span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> list2: List[Int] = List(2, 4, 6)</span><br><br><span style="color: #d73948">val</span> option1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> option1: Option[Int] = Some(value = 123)</span><br><span style="color: #d73948">val</span> option2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Option</span>].map(option1)(<span style="color: #d73948">_</span>.toString)<br><span style="color: #74747c">//</span><span style="color: #74747c"> option2: Option[String] = Some(value = "123")</span></code></pre>
    <p><code>Functor</code> provides a method called <code>lift</code>, which converts a function of type <code>A => B</code> to one that operates over a functor and has type <code>F[A] => F[B]</code>: Let’s lift a function into the <code>Option</code> functor.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func <span style="color: #d73948">=</span> (x: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> x + <span style="color: #b60157">1</span><br><br><span style="color: #d73948">val</span> liftedFunc <span style="color: #d73948">=</span> <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Option</span>].lift(func)</code></pre>
    <p>Now we can directly apply it to an <code>Option</code>.</p>
    <pre><code data-lang="scala">liftedFunc(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Option[Int] = Some(value = 2)</span></code></pre>
    <p>The <code>as</code> method is the other method you are likely to use. It replaces the value inside the <code>Functor</code> with the given value.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">List</span>].as(list1, <span style="color: #198810">"</span><span style="color: #198810">As</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: List[String] = List("As", "As", "As")</span></code></pre>
    <h4 id="loc-203">9.5.2. Functor Syntax</h4>
    <p>The main method provided by the syntax for <code>Functor</code> is <code>map</code>. It’s difficult to demonstrate this with <code>Options</code> and <code>Lists</code> as they have their own built-in <code>map</code> methods and the Scala compiler will always prefer a built-in method over an extension method. We’ll work around this with two examples.</p>
    <p>First let’s look at mapping over functions. Scala’s <code>Function1</code> type doesn’t have a <code>map</code> method (it’s called <code>andThen</code> instead) so there are no naming conflicts:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func1 <span style="color: #d73948">=</span> (a: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> a + <span style="color: #b60157">1</span><br><span style="color: #d73948">val</span> func2 <span style="color: #d73948">=</span> (a: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> a * <span style="color: #b60157">2</span><br><span style="color: #d73948">val</span> func3 <span style="color: #d73948">=</span> (a: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>a<span style="color: #198810">}</span><span style="color: #198810">!</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> func4 <span style="color: #d73948">=</span> func1.map(func2).map(func3)</code></pre>
    <p>Once we’ve constructed a function using <code>map</code> we can apply it.</p>
    <pre><code data-lang="scala">func4(<span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "248!"</span></code></pre>
    <p>Let’s look at another example. This time we’ll abstract over functors so we’re not working with any particular concrete type. We can write a method that applies an equation to a number no matter what functor context it’s in:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">doMath</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]](start: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>])<br>    (using functor: <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">F</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  start.map(n <span style="color: #d73948">=></span> <span style="color: #b60157">2</span> * n + <span style="color: #b60157">1</span>)</code></pre>
    <p>We can write this more compactly with a context bound.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">doMath</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Functor</span>](start: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  start.map(n <span style="color: #d73948">=></span> <span style="color: #b60157">2</span> * n + <span style="color: #b60157">1</span>)</code></pre>
    <p>It works as expected, using whatever <code>Functor</code> instance we pass it.</p>
    <pre><code data-lang="scala">doMath(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">20</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Option[Int] = Some(value = 41)</span><br>doMath(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: List[Int] = List(3, 5, 7)</span></code></pre>
    <p>To illustrate how this works, let’s take a look at the definition of the <code>map</code> method in <code>cats.syntax.functor</code>. Here’s a simplified version of the code:</p>
    <pre><code data-lang="scala">extension [<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>], <span style="color: #4b69c6">A</span>](src: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">B</span>](func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>)<br>      (using functor: <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">F</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    functor.map(src)(func)<br>}</code></pre>
    <p>The compiler can use this extension method to insert a <code>map</code> method wherever no built-in <code>map</code> is available. If we have the code</p>
    <pre><code data-lang="scala">foo.map(value <span style="color: #d73948">=></span> value + <span style="color: #b60157">1</span>)</code></pre>
    <p>and assume <code>foo</code> has no built-in <code>map</code> method, the compiler detects the potential error and uses the extension method to fix it. The <code>map</code> extension method requires a given <code>Functor</code> as a parameter. This means this code will only compile if we have a <code>Functor</code> for <code>F</code> in scope. If we don’t, we get a compiler error.</p>
    <p>Here’s an example of the error. First we define a new type that has no <code>Functor</code> instance.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Box</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>)<br><br><span style="color: #d73948">val</span> box <span style="color: #d73948">=</span> <span style="color: #4b69c6">Box</span>[<span style="color: #d73948">Int</span>](<span style="color: #b60157">123</span>)</code></pre>
    <p>Now attempting to call <code>map</code> fails. Notice the error message gives us a hint as to what went wrong.</p>
    <pre><code data-lang="scala">box.map(value <span style="color: #d73948">=></span> value + <span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type cats.Functor[Box] was found for parameter functor of method map</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> box.map(value => value + 1)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                           ^</span></code></pre>
    <p>The <code>as</code> method is also available as syntax, and works in the same way.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).as(<span style="color: #198810">"</span><span style="color: #198810">As</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: List[String] = List("As", "As", "As")</span></code></pre>
    <h4 id="loc-204">9.5.3. Instances for Custom Types</h4>
    <p>We can define a functor simply by defining its map method. Here’s an example of a <code>Functor</code> for <code>Option</code>, even though such a thing already exists in <a href="http://typelevel.org/cats/api/cats/instances/"><code>cats.instances</code><a id="loc-205" href="#loc-630" role="doc-noteref"><sup>54</sup></a></a>. The implementation is trivial—we simply call <code>Option's</code> <code>map</code> method:</p>
    <pre><code data-lang="scala">given optionFunctor: <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Option</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Option</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](value: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>      value.map(func)<br>  }</code></pre>
    <p>Sometimes we need to inject dependencies into our instances. For example, if we had to define a custom <code>Functor</code> for <code>Future</code> (another hypothetical example—Cats provides one in <code>cats.instances.future</code>) we would need to account for the given <code>ExecutionContext</code> parameter on <code>future.map</code>. We can’t add extra parameters to <code>functor.map</code> so we have to account for the dependency when we create the instance:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.{Future, ExecutionContext}<br><br>given futureFunctor(using ec: <span style="color: #4b69c6">ExecutionContext</span>): <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Future</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Future</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](value: <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>      value.map(func)<br>  }</code></pre>
    <p>Whenever we summon a <code>Functor</code> for <code>Future</code>, either directly using <code>Functor.apply</code> or indirectly via the <code>map</code> extension method, the compiler will locate <code>futureFunctor</code> by implicit resolution and recursively search for an <code>ExecutionContext</code> at the call site. This is what the expansion might look like:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> We write this:</span><br><span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Future</span>]<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> The compiler expands to this first:</span><br><span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Future</span>](futureFunctor)<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> And then to this:</span><br><span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">Future</span>](futureFunctor(executionContext))</code></pre>
    <h5>Exercise: Branching out with Functors</h5>
    <p>Write a <code>Functor</code> for the following binary tree data type. Verify that the code works as expected on instances of <code>Branch</code> and <code>Leaf</code>:</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">+</span><span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Branch</span>[<span style="color: #4b69c6">A</span>](left: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>])<br>    extends <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Leaf</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>) extends <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <h3 id="loc-206">9.6. Contravariant and Invariant Functors</h3>
    <p>As we have seen, we can think of <code>Functor's</code> <code>map</code> method as “appending” a transformation to a chain. We’re now going to look at two other type classes, one representing <em>prepending</em> operations to a chain, and one representing building a <em>bidirectional</em> chain of operations. These are called <em>contravariant</em> and <em>invariant functors</em> respectively.</p>
    <div>
      <h5>This Section is Optional!</h5>
      <p>You don’t need to know about contravariant and invariant functors to understand monads, which are the most important type class in this book and the focus of the next chapter. However, contravariant and invariant do come in handy in our discussion of <code>Semigroupal</code> and <code>Applicative</code> in <a href="#loc-295">Chapter 12</a>.</p>
      <p>If you want to move on to monads now, feel free to skip straight to <a href="#loc-228">Chapter 10</a>. Come back here before you read <a href="#loc-295">Chapter 12</a>.</p>
    </div>
    <h4 id="loc-207">9.6.1. Contravariant Functors and the <strong>contramap</strong> Method</h4>
    <p>The first of our type classes, the <em>contravariant functor</em>, provides an operation called <code>contramap</code> that represents “prepending” an operation to a chain. The general type signature is shown in <a href="#loc-208">Figure 5</a>.</p>
    <figure id="loc-208">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE3NjJweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE3NjIgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Z2VuZXJpYy1jb250cmFtYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xIiBjeD0iNjQiIGN5PSI2My45MDI0MzkiIHJ4PSI2NCIgcnk9IjYzLjkwMjQzOSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTIiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyNy44MDQ4NzgiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMyIgcG9pbnRzPSIzMTQuODc2MDY5IDEwOC42MzQxNDYgMjcyLjU1NTUzMSAxMzAuODQ5NDUzIDI4MC42MzgwMzUgODMuNzk2Njc3OSAyNDYuNCA1MC40NzM3MTczIDI5My43MTU4IDQzLjYwODgwOTkgMzE0Ljg3NjA2OSAwLjc5ODc4MDQ4OCAzMzYuMDM2MzM4IDQzLjYwODgwOTkgMzgzLjM1MjEzOCA1MC40NzM3MTczIDM0OS4xMTQxMDQgODMuNzk2Njc3OSAzNTcuMTk2NjA3IDEzMC44NDk0NTMiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay00IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjEzNi45NTIxMzgiIGhlaWdodD0iMTMwLjA1MDY3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC01IiBwb2ludHM9IjE2MS42IDQ3LjkyNjgyOTMgMTkzLjYgNDcuOTI2ODI5MyAxOTMuNiAzMS45NTEyMTk1IDIyNS42IDYzLjUwMTI2NTIgMTkzLjYgOTUuODUzNjU4NSAxOTMuNiA3OS44NzgwNDg4IDE2MS42IDc5Ljg3ODA0ODgiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay02IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjY0IiBoZWlnaHQ9IjYzLjkwMjQzOSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC03IiBwb2ludHM9IjY4LjQ3NjA2OTIgMTA4IDI2LjE1NTUzMSAxMzAuMjQ5MjI0IDM0LjIzODAzNDYgODMuMTI0NjExOCAtOS40MTQ2OTEyNWUtMTQgNDkuNzUwNzc2NCA0Ny4zMTU4MDAxIDQyLjg3NTM4ODIgNjguNDc2MDY5MiAwIDg5LjYzNjMzODMgNDIuODc1Mzg4MiAxMzYuOTUyMTM4IDQ5Ljc1MDc3NjQgMTAyLjcxNDEwNCA4My4xMjQ2MTE4IDExMC43OTY2MDcgMTMwLjI0OTIyNCI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTgiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTM2Ljk1MjEzOCIgaGVpZ2h0PSIxMzAuMjQ5MjI0IiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTkiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNjAiIGhlaWdodD0iMTYwIiByeD0iNi40Ij48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTAiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTkiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xMSIgY3g9IjY0IiBjeT0iNjQiIHJ4PSI2NCIgcnk9IjY0Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTIiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTMiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNjAiIGhlaWdodD0iMTYwIiByeD0iNi40Ij48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iZ2VuZXJpYy1jb250cmFtYXAiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjIiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC03IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3ODcuMDAwMDAwLCA3NS4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNi40Ij4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgbWFzaz0idXJsKCNtYXNrLTIpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMSIgbWFzaz0idXJsKCNtYXNrLTQpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgbWFzaz0idXJsKCNtYXNrLTYpIiBmaWxsPSIjMDAwMDAwIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjEyMTMgMTIzIDEyNDUgMTIzIDEyNDUgMTA3IDEyNzcgMTM4LjU5ODIxNCAxMjQ1IDE3MSAxMjQ1IDE1NSAxMjEzIDE1NSI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iRltCXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzEyLjYiIHk9IjMxNCI+RltCXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkZbQV0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEzNTYuNiIgeT0iMzE0Ij5GW0FdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1CIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI5MDAuNCIgeT0iMzE0Ij5BID0mZ3Q7IEI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC05IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyODAuMDAwMDAwLCA1Ny4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNi40Ij4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTEuMjAwMDAwLCAxNS4yMDAwMDApIiBmaWxsPSIjRkZGRkZGIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEiIG1hc2s9InVybCgjbWFzay04KSIgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJSZWN0YW5nbGUtMSIgbWFzaz0idXJsKCNtYXNrLTEwKSIgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMjAuMDAwMDAwLCA1Ny4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNi40Ij4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNi4wMDAwMDAsIDE5LjIwMDAwMCkiIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgbWFzaz0idXJsKCNtYXNrLTEyKSIgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlLTEiIG1hc2s9InVybCgjbWFzay0xNCkiIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iY29udHJhbWFwIiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjUxLjIiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjRjZBNjIzIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI0NzQuMjYiIHk9IjE1MSI+Y29udHJhbWFwPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 5: Type chart: the contramap method</figcaption>
    </figure>
    <p>The <code>contramap</code> method only makes sense for data types that represent <em>transformations</em>. For example, we can’t define <code>contramap</code> for an <code>Option</code> because there is no way of feeding a value in an <code>Option[B]</code> backwards through a function <code>A => B</code>. However, we can define <code>contramap</code> for the <code>Display</code> type class we discussed in <a href="#loc-108">Section 5.5</a>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Display</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">display</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">String</span><br>}</code></pre>
    <p>A <code>Display[A]</code> represents a transformation from <code>A</code> to <code>String</code>. Its <code>contramap</code> method accepts a function <code>func</code> of type <code>B => A</code> and creates a new <code>Display[B]</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Display</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">display</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">String</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contramap</span>[<span style="color: #4b69c6">B</span>](func: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Display</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">display</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>)(using p: <span style="color: #4b69c6">Display</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>  p.display(value)</code></pre>
    <h5>Exercise: Showing Off with Contramap</h5>
    <p>Implement the <code>contramap</code> method for <code>Display</code> above. Start with the following code template and replace the <code>???</code> with a working method body:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Display</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">display</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">String</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contramap</span>[<span style="color: #4b69c6">B</span>](func: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Display</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Display</span>[<span style="color: #4b69c6">B</span>] {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">display</span>(value: <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>        <span style="color: #d73948">???</span><br>    }<br>}</code></pre>
    <p>If you get stuck, think about the types. You need to turn <code>value</code>, which is of type <code>B</code>, into a <code>String</code>. What functions and methods do you have available and in what order do they need to be combined?</p>
    <p>For testing purposes, let’s define some instances of <code>Display</code> for <code>String</code> and <code>Boolean</code>:</p>
    <pre><code data-lang="scala">given stringDisplay: <span style="color: #4b69c6">Display</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">with</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">display</span>(value: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> =<br>    s"'${value}'<span style="color: #198810">"</span><br><span style="color: #198810">}</span><br><br><span style="color: #198810">given booleanDisplay: Display[Boolean] with {</span><br><span style="color: #198810">  def display(value: Boolean): String =</span><br><span style="color: #198810">    if value then </span><span style="color: #198810">"</span><span style="color: #4b69c6">yes</span><span style="color: #198810">"</span><span style="color: #198810"> else </span><span style="color: #198810">"</span><span style="color: #4b69c6">no</span><span style="color: #198810">"</span><br><span style="color: #198810">}</span></code></pre>
    <pre><code data-lang="scala">display(<span style="color: #198810">"</span><span style="color: #198810">hello</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "'hello'"</span><br>display(<span style="color: #d73948">true</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "yes"</span></code></pre>
    <p>Now define an instance of <code>Display</code> for the following <code>Box</code> case class. This is an example of type class composotion as described in <a href="#loc-104">Section 5.3</a>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Box</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>)</code></pre>
    <p>Rather than writing out the complete definition from scratch (<code>new Display[Box]</code> etc…), create your instance from an existing instance using <code>contramap</code>.</p>
    <p>Your instance should work as follows:</p>
    <pre><code data-lang="scala">display(<span style="color: #4b69c6">Box</span>(<span style="color: #198810">"</span><span style="color: #198810">hello world</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: String = "'hello world'"</span><br>display(<span style="color: #4b69c6">Box</span>(<span style="color: #d73948">true</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: String = "yes"</span></code></pre>
    <p>If we don’t have a <code>Display</code> for the type inside the <code>Box</code>, calls to <code>display</code> should fail to compile:</p>
    <pre><code data-lang="scala">display(<span style="color: #4b69c6">Box</span>(<span style="color: #b60157">123</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type repl.MdocSession.MdocApp1.Display[repl.MdocSession.MdocApp1.Box[Int]] was found for parameter p of method display in object MdocApp1.</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> I found:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> </span><br><span style="color: #74747c">//</span><span style="color: #74747c">     repl.MdocSession.MdocApp1.boxDisplay[Int](</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       /* missing */summon[repl.MdocSession.MdocApp1.Display[Int]])</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> But no implicit values were found that match type repl.MdocSession.MdocApp1.Display[Int].</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> display(Box(123))</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                 ^</span></code></pre>
    <h4 id="loc-209">9.6.2. Invariant functors and the <strong>imap</strong> method</h4>
    <p><strong>Invariant functors</strong> implement a method called <code>imap</code> that is informally equivalent to a combination of <code>map</code> and <code>contramap</code>. If <code>map</code> generates new type class instances by appending a function to a chain, and <code>contramap</code> generates them by prepending an operation to a chain, <code>imap</code> generates them via a pair of bidirectional transformations.</p>
    <p>The most intuitive examples of this are a type class that represents encoding and decoding as some data type, such as Circe’s <a href="https://github.com/circe/circe/blob/series/0.14.x/modules/core/shared/src/main/scala/io/circe/Codec.scala"><code>Codec</code><a id="loc-210" href="#loc-631" role="doc-noteref"><sup>55</sup></a></a> and Play JSON’s <a href="https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators#Format"><code>Format</code><a id="loc-211" href="#loc-632" role="doc-noteref"><sup>56</sup></a></a>. We can build our own <code>Codec</code> by enhancing <code>Display</code> to support encoding and decoding to and from a <code>String</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Codec</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">encode</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">String</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">decode</span>(value: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">imap</span>[<span style="color: #4b69c6">B</span>](dec: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>, enc: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Codec</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>}</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">encode</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>)(using c: <span style="color: #4b69c6">Codec</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>  c.encode(value)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">decode</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">String</span>)(using c: <span style="color: #4b69c6">Codec</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>  c.decode(value)</code></pre>
    <p>The type chart for <code>imap</code> is shown in <a href="#loc-212">Figure 6</a>. If we have a <code>Codec[A]</code> and a pair of functions <code>A => B</code> and <code>B => A</code>, the <code>imap</code> method creates a <code>Codec[B]</code>:</p>
    <figure id="loc-212">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE3NjNweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE3NjMgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Z2VuZXJpYy1pbWFwPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMSIgY3g9IjQzLjc5MjQ3MzEiIGN5PSI0NC40MTQ2MzQxIiByeD0iNDMuNzkyNDczMSIgcnk9IjQzLjQxNDYzNDEiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg3LjU4NDk0NjIiIGhlaWdodD0iODYuODI5MjY4MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0zIiBwb2ludHM9IjIxNS40NTYyNzggNzMuODA0ODc4IDE4Ni40OTgxMzcgODguODk3NzIwMyAxOTIuMDI4NjUgNTYuOTMwNTY3NSAxNjguNjAxMDIyIDM0LjI5MTMwNDEgMjAwLjk3NzIwNyAyOS42MjczNTk0IDIxNS40NTYyNzggMC41NDI2ODI5MjcgMjI5LjkzNTM0OSAyOS42MjczNTk0IDI2Mi4zMTE1MzUgMzQuMjkxMzA0MSAyMzguODgzOTA2IDU2LjkzMDU2NzUgMjQ0LjQxNDQxOSA4OC44OTc3MjAzIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI5My43MTA1MTMxIiBoZWlnaHQ9Ijg4LjM1NTAzNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNSIgcG9pbnRzPSIxMTAuNTc1OTk1IDMzLjU2MDk3NTYgMTMyLjQ3MjIzMSAzMy41NjA5NzU2IDEzMi40NzIyMzEgMjIuNzA3MzE3MSAxNTQuMzY4NDY4IDQ0LjE0MjA4MDkgMTMyLjQ3MjIzMSA2Ni4xMjE5NTEyIDEzMi40NzIyMzEgNTUuMjY4MjkyNyAxMTAuNTc1OTk1IDU1LjI2ODI5MjciPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay02IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjQzLjc5MjQ3MzEiIGhlaWdodD0iNDMuNDE0NjM0MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC03IiBjeD0iMjE0Ljc5MjQ3MyIgY3k9IjQ3LjQxNDYzNDEiIHJ4PSI0My43OTI0NzMxIiByeT0iNDMuNDE0NjM0MSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTgiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODcuNTg0OTQ2MiIgaGVpZ2h0PSI4Ni44MjkyNjgzIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTkiIHBvaW50cz0iNDcuMDg5MjA1OCA3My4yNjIxOTUxIDE4LjEzMTA2NDcgODguMzU1MDM3MyAyMy42NjE1Nzc2IDU2LjM4Nzg4NDUgMC4yMzM5NDkyODcgMzMuNzQ4NjIxMiAzMi42MTAxMzUzIDI5LjA4NDY3NjQgNDcuMDg5MjA1OCA2LjMyMzgzMDM1ZS0xNSA2MS41NjgyNzY0IDI5LjA4NDY3NjQgOTMuOTQ0NDYyNCAzMy43NDg2MjEyIDcwLjUxNjgzNDEgNTYuMzg3ODg0NSA3Ni4wNDczNDY5IDg4LjM1NTAzNzMiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI5My43MTA1MTMxIiBoZWlnaHQ9Ijg4LjM1NTAzNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMTEiIHBvaW50cz0iMTEwLjU3NTk5NSAzMi41NjA5NzU2IDEzMi40NzIyMzEgMzIuNTYwOTc1NiAxMzIuNDcyMjMxIDIxLjcwNzMxNzEgMTU0LjM2ODQ2OCA0My4xNDIwODA5IDEzMi40NzIyMzEgNjUuMTIxOTUxMiAxMzIuNDcyMjMxIDU0LjI2ODI5MjcgMTEwLjU3NTk5NSA1NC4yNjgyOTI3Ij48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTIiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNDMuNzkyNDczMSIgaGVpZ2h0PSI0My40MTQ2MzQxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0xMyIgcG9pbnRzPSI0NC41MDk0NDUgNzAuMiAxNy4wMDEwOTUyIDg0LjY2MTk5NTMgMjIuMjU0NzIyNSA1NC4wMzA5OTc3IC0xLjE1MDE5MTA1ZS0xMyAzMi4zMzgwMDQ3IDMwLjc1NTI3MDEgMjcuODY5MDAyMyA0NC41MDk0NDUgMCA1OC4yNjM2MTk5IDI3Ljg2OTAwMjMgODkuMDE4ODg5OSAzMi4zMzgwMDQ3IDY2Ljc2NDE2NzQgNTQuMDMwOTk3NyA3Mi4wMTc3OTQ4IDg0LjY2MTk5NTMiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4OS4wMTg4ODk5IiBoZWlnaHQ9Ijg0LjY2MTk5NTMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTE1IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTA0IiBoZWlnaHQ9IjEwNCIgcng9IjYuNCI+PC9yZWN0PgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE2IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwNCIgaGVpZ2h0PSIxMDQiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTE3IiBjeD0iNDEuNiIgY3k9IjQxLjYiIHJ4PSI0MS42IiByeT0iNDEuNiI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE4IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjgzLjIiIGhlaWdodD0iODMuMiIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTE3Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTkiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMDQiIGhlaWdodD0iMTA0IiByeD0iNi40Ij48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMjAiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTA0IiBoZWlnaHQ9IjEwNCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTE5Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iZ2VuZXJpYy1pbWFwIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzYzIiBoZWlnaHQ9IjM2MCI+PC9yZWN0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtNyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjA2LjAwMDAwMCwgOTIuMDAwMDAwKSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjYuNCI+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEiIG1hc2s9InVybCgjbWFzay0yKSIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEiIG1hc2s9InVybCgjbWFzay00KSIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJQYXRoLTEiIG1hc2s9InVybCgjbWFzay02KSIgZmlsbD0iIzAwMDAwMCIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkzOC4wMDAwMDAsIDkzLjAwMDAwMCkiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI2LjQiPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xIiBtYXNrPSJ1cmwoI21hc2stOCkiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stMTApIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgbWFzaz0idXJsKCNtYXNrLTEyKSIgZmlsbD0iIzAwMDAwMCIgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMTI0MSAxMjEgMTI3MyAxMjEgMTI3MyAxMDUgMTMwNSAxMzYuNTk4MjE0IDEyNzMgMTY5IDEyNzMgMTUzIDEyNDEgMTUzIj48L3BvbHlnb24+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJGW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIzMTIuNiIgeT0iMzE0Ij5GW0FdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iRltCXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTM1Ni42IiB5PSIzMTQiPkZbQl08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjY4My40IiB5PSIzMTQiPkEgPSZndDsgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IiwiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijg4Ni40IiB5PSIxODUiPiw8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJCLT0mZ3Q7LUEiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijk4My40IiB5PSIzMTQiPkIgPSZndDsgQTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNDcuMDAwMDAwLCA4NS4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNi40Ij4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNy4xNTAwMDAsIDkuNzUwMDAwKSIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stMTQpIiB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJSZWN0YW5nbGUtMSIgbWFzaz0idXJsKCNtYXNrLTE2KSIgeGxpbms6aHJlZj0iI3BhdGgtMTUiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC04IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMDcuMDAwMDAwLCA4NS4wMDAwMDApIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNi40Ij4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMC40MDAwMDAsIDEyLjQ4MDAwMCkiIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgbWFzaz0idXJsKCNtYXNrLTE4KSIgeGxpbms6aHJlZj0iI3BhdGgtMTciPjwvdXNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlLTEiIG1hc2s9InVybCgjbWFzay0yMCkiIHhsaW5rOmhyZWY9IiNwYXRoLTE5Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iaW1hcCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI1MS4yIiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNDQ3LjA2IiB5PSIxNDgiPmltYXA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
      <figcaption>Figure 6: Type chart: the imap method</figcaption>
    </figure>
    <p>As an example use case, imagine we have a basic <code>Codec[String]</code>, whose <code>encode</code> and <code>decode</code> methods both simply return the value they are passed:</p>
    <pre><code data-lang="scala">given stringCodec: <span style="color: #4b69c6">Codec</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">with</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">encode</span>(value: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> = value<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">decode</span>(value: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> = value<br>}</code></pre>
    <p>We can construct many useful <code>Codecs</code> for other types by building off of <code>stringCodec</code> using <code>imap</code>:</p>
    <pre><code data-lang="scala">given intCodec: <span style="color: #4b69c6">Codec</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  stringCodec.imap(<span style="color: #d73948">_</span>.toInt, <span style="color: #d73948">_</span>.toString)<br><br>given booleanCodec: <span style="color: #4b69c6">Codec</span>[<span style="color: #d73948">Boolean</span>] <span style="color: #d73948">=</span><br>  stringCodec.imap(<span style="color: #d73948">_</span>.toBoolean, <span style="color: #d73948">_</span>.toString)</code></pre>
    <div>
      <h5>Coping with Failure</h5>
      <p>Note that the <code>decode</code> method of our <code>Codec</code> type class doesn’t account for failures. If we want to model more sophisticated relationships we can move beyond functors to look at <em>lenses</em> and <em>optics</em>.</p>
      <p>Optics are beyond the scope of this book. However, the <a href="https://github.com/optics-dev/Monocle">Monocle<a id="loc-213" href="#loc-633" role="doc-noteref"><sup>57</sup></a></a> provides a great starting point for further investigation.</p>
    </div>
    <h5>9.6.2.1. Transformative Thinking with <strong>imap</strong></h5>
    <p>Implement the <code>imap</code> method for <code>Codec</code> above.</p>
    <p>Demonstrate your <code>imap</code> method works by creating a <code>Codec</code> for <code>Double</code>.</p>
    <p>Finally, implement a <code>Codec</code> for the following <code>Box</code> type:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Box</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>)</code></pre>
    <p>Your instances should work as follows:</p>
    <pre><code data-lang="scala">encode(<span style="color: #b60157">123</span><span style="color: #b60157">.</span><span style="color: #b60157">4</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: String = "123.4"</span><br>decode[<span style="color: #d73948">Double</span>](<span style="color: #198810">"</span><span style="color: #198810">123.4</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Double = 123.4</span><br><br>encode(<span style="color: #4b69c6">Box</span>(<span style="color: #b60157">123</span><span style="color: #b60157">.</span><span style="color: #b60157">4</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: String = "123.4"</span><br>decode[<span style="color: #4b69c6">Box</span>[<span style="color: #d73948">Double</span>]](<span style="color: #198810">"</span><span style="color: #198810">123.4</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: Box[Double] = Box(value = 123.4)</span></code></pre>
    <div>
      <h5>What’s With the Names?</h5>
      <p>What’s the relationship between the terms “contravariance”, “invariance”, and “covariance” and these different kinds of functor?</p>
      <p>As we discussed in <a href="#loc-112">Section 5.6.1</a>, variance affects subtyping, which is essentially our ability to use a value of one type in place of a value of another type without breaking the code.</p>
      <p>Subtyping can be viewed as a conversion. If <code>B</code> is a subtype of <code>A</code>, we can always convert a <code>B</code> to an <code>A</code>.</p>
      <p>Equivalently we could say that <code>B</code> is a subtype of <code>A</code> if there exists a function <code>B => A</code>. A standard covariant functor captures exactly this. If <code>F</code> is a covariant functor, wherever we have an <code>F[B]</code> and a conversion <code>B => A</code> we can always convert to an <code>F[A]</code>.</p>
      <p>A contravariant functor captures the opposite case. If <code>F</code> is a contravariant functor, whenever we have a <code>F[A]</code> and a conversion <code>B => A</code> we can convert to an <code>F[B]</code>.</p>
      <p>Finally, invariant functors capture the case where we can convert from <code>F[A]</code> to <code>F[B]</code> via a function <code>A => B</code> and vice versa via a function <code>B => A</code>.</p>
    </div>
    <h3 id="loc-214">9.7. Contravariant and Invariant in Cats</h3>
    <p>Let’s look at the implementation of contravariant and invariant functors in Cats, provided by the <a href="http://typelevel.org/cats/api/cats/Contravariant.html"><code>cats.Contravariant</code><a id="loc-215" href="#loc-634" role="doc-noteref"><sup>58</sup></a></a> and <a href="http://typelevel.org/cats/api/cats/Invariant.html"><code>cats.Invariant</code><a id="loc-216" href="#loc-635" role="doc-noteref"><sup>59</sup></a></a> type classes respectively. Here’s a simplified version of the code:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Contravariant</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">contramap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(f: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Invariant</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">imap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>)(g: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br>}</code></pre>
    <h4 id="loc-217">9.7.1. Contravariant in Cats</h4>
    <p>We can summon instances of <code>Contravariant</code> using the <code>Contravariant.apply</code> method. Cats provides instances for data types that consume parameters, including <code>Eq</code>, <code>Show</code>, and <code>Function1</code>. Here’s an example:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*<br><br><span style="color: #d73948">val</span> showString <span style="color: #d73948">=</span> <span style="color: #4b69c6">Show</span>[<span style="color: #4b69c6">String</span>]<br><br><span style="color: #d73948">val</span> showSymbol <span style="color: #d73948">=</span> <span style="color: #4b69c6">Contravariant</span>[<span style="color: #4b69c6">Show</span>].<br>  contramap(showString)((sym: <span style="color: #4b69c6">Symbol</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">'</span><span style="color: #198810">${</span>sym.name<span style="color: #198810">}</span><span style="color: #198810">"</span>)</code></pre>
    <pre><code data-lang="scala">showSymbol.show(<span style="color: #4b69c6">Symbol</span>(<span style="color: #198810">"</span><span style="color: #198810">dave</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "'dave"</span></code></pre>
    <p>More conveniently, we can use <a href="http://typelevel.org/cats/api/cats/syntax/package$$contravariant$"><code>cats.syntax.contravariant</code><a id="loc-218" href="#loc-636" role="doc-noteref"><sup>60</sup></a></a>, which provides a <code>contramap</code> extension method:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.contravariant.* <span style="color: #74747c">//</span><span style="color: #74747c"> for contramap</span></code></pre>
    <pre><code data-lang="scala">showString<br>  .contramap[<span style="color: #4b69c6">Symbol</span>](sym <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">'</span><span style="color: #198810">${</span>sym.name<span style="color: #198810">}</span><span style="color: #198810">"</span>)<br>  .show(<span style="color: #4b69c6">Symbol</span>(<span style="color: #198810">"</span><span style="color: #198810">dave</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "'dave"</span></code></pre>
    <h4 id="loc-219">9.7.2. Invariant in Cats</h4>
    <p>Among other types, Cats provides an instance of <code>Invariant</code> for <code>Monoid</code>. This is a little different from the <code>Codec</code> example we introduced in <a href="#loc-209">Section 9.6.2</a>. If you recall, this is what <code>Monoid</code> looks like:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Monoid</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>: <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">combine</span>(x: <span style="color: #4b69c6">A</span>, y: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span><br>}</code></pre>
    <p>Imagine we want to produce a <code>Monoid</code> for Scala’s <a href="https://www.scala-lang.org/api/3.3.3/scala/Symbol.html#"><code>Symbol</code><a id="loc-220" href="#loc-637" role="doc-noteref"><sup>61</sup></a></a> type. Cats doesn’t provide a <code>Monoid</code> for <code>Symbol</code> but it does provide a <code>Monoid</code> for a similar type: <code>String</code>. We can write our new semigroup with an <code>empty</code> method that relies on the empty <code>String</code>, and a <code>combine</code> method that works as follows:</p>
    <ol>
      <li>accept two <code>Symbols</code> as parameters;</li>
      <li>convert the <code>Symbols</code> to <code>Strings</code>;</li>
      <li>combine the <code>Strings</code> using <code>Monoid[String]</code>;</li>
      <li>convert the result back to a <code>Symbol</code>.</li>
    </ol>
    <p>We can implement <code>combine</code> using <code>imap</code>, passing functions of type <code>String => Symbol</code> and <code>Symbol => String</code> as parameters. Here’ the code, written out using the <code>imap</code> extension method provided by <code>cats.syntax.invariant</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*<br><span style="color: #d73948">import</span> cats.syntax.invariant.* <span style="color: #74747c">//</span><span style="color: #74747c"> for imap</span><br><span style="color: #d73948">import</span> cats.syntax.semigroup.* <span style="color: #74747c">//</span><span style="color: #74747c"> for |+|</span><br><br>given symbolMonoid: <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">Symbol</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">String</span>].imap(<span style="color: #4b69c6">Symbol</span>.apply)(<span style="color: #d73948">_</span>.name)</code></pre>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">Symbol</span>].empty<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Symbol = '</span><br><br><span style="color: #4b69c6">Symbol</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span>) |+| <span style="color: #4b69c6">Symbol</span>(<span style="color: #198810">"</span><span style="color: #198810">few</span><span style="color: #198810">"</span>) |+| <span style="color: #4b69c6">Symbol</span>(<span style="color: #198810">"</span><span style="color: #198810">words</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Symbol = 'afewwords</span></code></pre>
    <h3 id="loc-221">9.8. Aside: Partial Unification</h3>
    <p>In <a href="#loc-190">Section 9.2</a> we saw a functor instance for <code>Function1</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.*<br><span style="color: #d73948">import</span> cats.syntax.functor.*     <span style="color: #74747c">//</span><span style="color: #74747c"> for map</span><br><br><span style="color: #d73948">val</span> func1 <span style="color: #d73948">=</span> (x: <span style="color: #d73948">Int</span>)    <span style="color: #d73948">=></span> x.toDouble<br><span style="color: #d73948">val</span> func2 <span style="color: #d73948">=</span> (y: <span style="color: #d73948">Double</span>) <span style="color: #d73948">=></span> y * <span style="color: #b60157">2</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func3 <span style="color: #d73948">=</span> func1.map(func2)<br><span style="color: #74747c">//</span><span style="color: #74747c"> func3: Function1[Int, Double] = cats.instances.Function1Instances0$$anon$11$$Lambda/0x00000000600ae0f0@2e734c34</span></code></pre>
    <p><code>Function1</code> has two type parameters (the function argument and the result type):</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Function1</span>[<span style="color: #d73948">-</span><span style="color: #4b69c6">A</span>, <span style="color: #d73948">+</span><span style="color: #4b69c6">B</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(arg: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">B</span><br>}</code></pre>
    <p>However, <code>Functor</code> accepts a type constructor with one parameter:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Functor</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br>}</code></pre>
    <p>The compiler has to fix one of the two parameters of <code>Function1</code> to create a type constructor of the correct kind to pass to <code>Functor</code>. It has two options to choose from:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span></code></pre>
    <p><em>We</em> know that the first one is the correct choice. However the compiler doesn’t understand what the code means. Instead it relies on a simple rule, implementing what is called “partial unification”.</p>
    <p>The partial unification in the Scala compiler works by fixing type parameters from left to right. In the above example, the compiler fixes the <code>Int</code> in <code>Int => Double</code> and looks for a <code>Functor</code> for functions of type <code>Int => ?</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span><br><br><span style="color: #d73948">val</span> functor <span style="color: #d73948">=</span> <span style="color: #4b69c6">Functor</span>[<span style="color: #4b69c6">F</span>]</code></pre>
    <p>This left-to-right elimination works for a wide variety of common scenarios, including <code>Functors</code> for types such as <code>Function1</code> and <code>Either</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> either: <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Right</span>(<span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> either: Either[String, Int] = Right(value = 123)</span><br><br>either.map(<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Either[String, Int] = Right(value = 124)</span></code></pre>
    <div>
      <p>Partial unification is the default behaviour in Scala 2.13. In earlier versions of Scala we need to add the <code>-Ypartial-unification</code> compiler flag. In sbt we would add the compiler flag in <code>build.sbt</code>:</p>
      <pre><code data-lang="scala">scalacOptions += <span style="color: #198810">"</span><span style="color: #198810">-Ypartial-unification</span><span style="color: #198810">"</span></code></pre>
      <p>The rationale behind this change is discussed in <a href="https://issues.scala-lang.org/browse/SI-2712">SI-2712<a id="loc-222" href="#loc-638" role="doc-noteref"><sup>62</sup></a></a>.</p>
    </div>
    <h4 id="loc-223">9.8.1. Limitations of Partial Unification</h4>
    <p>There are situations where left-to-right elimination is not the correct choice. One example is the <code>Or</code> type in <a href="http://scalactic.org">Scalactic<a id="loc-224" href="#loc-639" role="doc-noteref"><sup>63</sup></a></a>, which is a conventionally left-biased equivalent of <code>Either</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">PossibleResult</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">ActualResult</span> <span style="color: #4b69c6">Or</span> <span style="color: #4b69c6">Error</span></code></pre>
    <p>Another example is the <code>Contravariant</code> functor for <code>Function1</code>.</p>
    <p>While the covariant <code>Functor</code> for <code>Function1</code> implements <code>andThen</code>-style left-to-right function composition, the <code>Contravariant</code> functor implements <code>compose</code>-style right-to-left composition. In other words, the following expressions are all equivalent:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func3a: <span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span> =<br>  a <span style="color: #d73948">=></span> func2(func1(a))<br><br><span style="color: #d73948">val</span> func3b: <span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span> =<br>  func2.compose(func1)</code></pre>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Hypothetical example. This won't actually compile:</span><br><span style="color: #d73948">val</span> func3c: <span style="color: #d73948">Int</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span> =<br>  func2.contramap(func1)</code></pre>
    <p>If we try this for real, however, our code won’t compile:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.contravariant.* <span style="color: #74747c">//</span><span style="color: #74747c"> for contramap</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func3c <span style="color: #d73948">=</span> func2.contramap(func1)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> value contramap is not a member of Double => Double.</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> An extension method was tried, but could not be fully constructed:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> </span><br><span style="color: #74747c">//</span><span style="color: #74747c">     cats.syntax.contravariant.toContravariantOps[[R] =>> Double => R, A](</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       repl.MdocSession.MdocApp.func2)(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       cats.Invariant.catsContravariantForFunction1[R])</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> val func3c = func2.contramap(func1)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">              ^^^^^^^^^^^^^^^</span></code></pre>
    <p>The problem here is that the <code>Contravariant</code> for <code>Function1</code> fixes the return type and leaves the parameter type varying, requiring the compiler to eliminate type parameters from right to left, as shown below and in <a href="#loc-225">Figure 7</a>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Double</span></code></pre>
    <figure id="loc-225">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjMyNXB4IiB2aWV3Qm94PSIwIDAgMTc2MSAzMjUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5mdW5jdGlvbi1jb250cmFtYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xIiBjeD0iMjQ4LjQwMzY1MyIgY3k9IjU2LjUzMzc0MjMiIHJ4PSI1MS40MDM2NTMiIHJ5PSI1MS41MzM3NDIzIj48L2VsbGlwc2U+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMiIgcG9pbnRzPSIxMjQuMzcyMzA2IDQxLjI5NDQ3ODUgMTUwLjA3NDEzMiA0MS4yOTQ0Nzg1IDE1MC4wNzQxMzIgMjguNDExMDQyOSAxNzUuNzc1OTU5IDUzLjg1NDM4OTkgMTUwLjA3NDEzMiA3OS45NDQ3ODUzIDE1MC4wNzQxMzIgNjcuMDYxMzQ5NyAxMjQuMzcyMzA2IDY3LjA2MTM0OTciPjwvcG9seWdvbj4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0zIiBjeD0iNTEuNDAzNjUzIiBjeT0iNTIuMTc3OTE0MSIgcng9IjUxLjQwMzY1MyIgcnk9IjUxLjUzMzc0MjMiPjwvZWxsaXBzZT4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC00IiBwb2ludHM9IjI0NS40ODA4OTggODYuOTYzMTkwMiAyMTEuNDg5OCAxMDQuODc4NTkzIDIxNy45ODE1MjIgNjYuOTMzMTYxMyAxOTAuNDgyMTQ2IDQwLjA2MDA1NzcgMjI4LjQ4NTM0OSAzNC41MjM4OTM5IDI0NS40ODA4OTggMCAyNjIuNDc2NDQ3IDM0LjUyMzg5MzkgMzAwLjQ3OTY0OSA0MC4wNjAwNTc3IDI3Mi45ODAyNzMgNjYuOTMzMTYxMyAyNzkuNDcxOTk1IDEwNC44Nzg1OTMiPjwvcG9seWdvbj4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC01IiBwb2ludHM9IjEyMi4zNzIzMDYgMzkuMjk0NDc4NSAxNDguMDc0MTMyIDM5LjI5NDQ3ODUgMTQ4LjA3NDEzMiAyNi40MTEwNDI5IDE3My43NzU5NTkgNTEuODU0Mzg5OSAxNDguMDc0MTMyIDc3Ljk0NDc4NTMgMTQ4LjA3NDEzMiA2NS4wNjEzNDk3IDEyMi4zNzIzMDYgNjUuMDYxMzQ5NyI+PC9wb2x5Z29uPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTYiIHBvaW50cz0iMjU0LjQ4MDg5OCA4Ny45NjMxOTAyIDIyMC40ODk4IDEwNS44Nzg1OTMgMjI2Ljk4MTUyMiA2Ny45MzMxNjEzIDE5OS40ODIxNDYgNDEuMDYwMDU3NyAyMzcuNDg1MzQ5IDM1LjUyMzg5MzkgMjU0LjQ4MDg5OCAxIDI3MS40NzY0NDcgMzUuNTIzODkzOSAzMDkuNDc5NjQ5IDQxLjA2MDA1NzcgMjgxLjk4MDI3MyA2Ny45MzMxNjEzIDI4OC40NzE5OTUgMTA1Ljg3ODU5MyI+PC9wb2x5Z29uPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTciIHBvaW50cz0iMTMxLjM3MjMwNiA0MC4yOTQ0Nzg1IDE1Ny4wNzQxMzIgNDAuMjk0NDc4NSAxNTcuMDc0MTMyIDI3LjQxMTA0MjkgMTgyLjc3NTk1OSA1Mi44NTQzODk5IDE1Ny4wNzQxMzIgNzguOTQ0Nzg1MyAxNTcuMDc0MTMyIDY2LjA2MTM0OTcgMTMxLjM3MjMwNiA2Ni4wNjEzNDk3Ij48L3BvbHlnb24+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iZnVuY3Rpb24tY29udHJhbWFwIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzYxIiBoZWlnaHQ9IjMyNSI+PC9yZWN0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAzLjAwMDAwMCwgNTEuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSIyNDguNDAzNjUzIiBjeT0iNTYuNTMzNzQyMyIgcng9IjQ5LjQwMzY1MyIgcnk9IjQ5LjUzMzc0MjMiPjwvZWxsaXBzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJQYXRoLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iIzAwMDAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0yIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTEyNi4zNzIzMDYsNDMuMjk0NDc4NSBMMTUwLjA3NDEzMiw0My4yOTQ0Nzg1IEwxNTIuMDc0MTMyLDQzLjI5NDQ3ODUgTDE1Mi4wNzQxMzIsNDEuMjk0NDc4NSBMMTUyLjA3NDEzMiwzMy4yMDUxNjk4IEwxNzIuOTUxMDQ0LDUzLjg3MjEyNTEgTDE1Mi4wNzQxMzIsNzUuMDY0NjYwNyBMMTUyLjA3NDEzMiw2Ny4wNjEzNDk3IEwxNTIuMDc0MTMyLDY1LjA2MTM0OTcgTDE1MC4wNzQxMzIsNjUuMDYxMzQ5NyBMMTI2LjM3MjMwNiw2NS4wNjEzNDk3IEwxMjYuMzcyMzA2LDQzLjI5NDQ3ODUgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24iIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBwb2ludHM9IjUzIDAuMDY1ODYxNzQyNCAxMDUuMzM5MjYzIDM4LjA5MjU2MjIgODUuMzQ3NDQzNSA5OS42MjEwNTYgMjAuNjUyNTU2NSA5OS42MjEwNTYgMC42NjA3MzcwMyAzOC4wOTI1NjIyIj48L3BvbHlnb24+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxNy4wMDAwMDAsIDUzLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNTEuNDAzNjUzIiBjeT0iNTIuMTc3OTE0MSIgcng9IjQ5LjQwMzY1MyIgcnk9IjQ5LjUzMzc0MjMiPjwvZWxsaXBzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC00Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTIxNC4xNDUwNTksMTAxLjIxODMxNyBMMjE5Ljk1Mjg4MSw2Ny4yNzA0MjIzIEwyMjAuMTI5ODI3LDY2LjIzNjEzNTUgTDIxOS4zNzkzNTQsNjUuNTAyNzUzNSBMMTk0Ljc3MjM4Miw0MS40NTYxODI0IEwyMjguNzczNjU4LDM2LjUwMzAwNDIgTDIyOS44MTQ5NDksMzYuMzUxMzEyOCBMMjMwLjI3OTcwNywzNS40MDcyMjcyIEwyNDUuNDgwODk4LDQuNTI4MzAxODQgTDI2MC42ODIwODgsMzUuNDA3MjI3MiBMMjYxLjE0Njg0NiwzNi4zNTEzMTI4IEwyNjIuMTg4MTM3LDM2LjUwMzAwNDIgTDI5Ni4xODk0MTMsNDEuNDU2MTgyNCBMMjcxLjU4MjQ0Miw2NS41MDI3NTM1IEwyNzAuODMxOTY4LDY2LjIzNjEzNTUgTDI3MS4wMDg5MTUsNjcuMjcwNDIyMyBMMjc2LjgxNjczNiwxMDEuMjE4MzE3IEwyNDYuNDEzNDI0LDg1LjE5Mzg5NzkgTDI0NS40ODA4OTgsODQuNzAyMzk5MiBMMjQ0LjU0ODM3Miw4NS4xOTM4OTc5IEwyMTQuMTQ1MDU5LDEwMS4yMTgzMTcgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IlBhdGgtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjMDAwMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMTI0LjM3MjMwNiw0MS4yOTQ0Nzg1IEwxNDguMDc0MTMyLDQxLjI5NDQ3ODUgTDE1MC4wNzQxMzIsNDEuMjk0NDc4NSBMMTUwLjA3NDEzMiwzOS4yOTQ0Nzg1IEwxNTAuMDc0MTMyLDMxLjIwNTE2OTggTDE3MC45NTEwNDQsNTEuODcyMTI1MSBMMTUwLjA3NDEzMiw3My4wNjQ2NjA3IEwxNTAuMDc0MTMyLDY1LjA2MTM0OTcgTDE1MC4wNzQxMzIsNjMuMDYxMzQ5NyBMMTQ4LjA3NDEzMiw2My4wNjEzNDk3IEwxMjQuMzcyMzA2LDYzLjA2MTM0OTcgTDEyNC4zNzIzMDYsNDEuMjk0NDc4NSBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyNTguMDAwMDAwLCA1Mi4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC02Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTIyMy4xNDUwNTksMTAyLjIxODMxNyBMMjI4Ljk1Mjg4MSw2OC4yNzA0MjIzIEwyMjkuMTI5ODI3LDY3LjIzNjEzNTUgTDIyOC4zNzkzNTQsNjYuNTAyNzUzNSBMMjAzLjc3MjM4Miw0Mi40NTYxODI0IEwyMzcuNzczNjU4LDM3LjUwMzAwNDIgTDIzOC44MTQ5NDksMzcuMzUxMzEyOCBMMjM5LjI3OTcwNywzNi40MDcyMjcyIEwyNTQuNDgwODk4LDUuNTI4MzAxODQgTDI2OS42ODIwODgsMzYuNDA3MjI3MiBMMjcwLjE0Njg0NiwzNy4zNTEzMTI4IEwyNzEuMTg4MTM3LDM3LjUwMzAwNDIgTDMwNS4xODk0MTMsNDIuNDU2MTgyNCBMMjgwLjU4MjQ0Miw2Ni41MDI3NTM1IEwyNzkuODMxOTY4LDY3LjIzNjEzNTUgTDI4MC4wMDg5MTUsNjguMjcwNDIyMyBMMjg1LjgxNjczNiwxMDIuMjE4MzE3IEwyNTUuNDEzNDI0LDg2LjE5Mzg5NzkgTDI1NC40ODA4OTgsODUuNzAyMzk5MiBMMjUzLjU0ODM3Miw4Ni4xOTM4OTc5IEwyMjMuMTQ1MDU5LDEwMi4yMTgzMTcgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IlBhdGgtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjMDAwMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMTMzLjM3MjMwNiw0Mi4yOTQ0Nzg1IEwxNTcuMDc0MTMyLDQyLjI5NDQ3ODUgTDE1OS4wNzQxMzIsNDIuMjk0NDc4NSBMMTU5LjA3NDEzMiw0MC4yOTQ0Nzg1IEwxNTkuMDc0MTMyLDMyLjIwNTE2OTggTDE3OS45NTEwNDQsNTIuODcyMTI1MSBMMTU5LjA3NDEzMiw3NC4wNjQ2NjA3IEwxNTkuMDc0MTMyLDY2LjA2MTM0OTcgTDE1OS4wNzQxMzIsNjQuMDYxMzQ5NyBMMTU3LjA3NDEzMiw2NC4wNjEzNDk3IEwxMzMuMzcyMzA2LDY0LjA2MTM0OTcgTDEzMy4zNzIzMDYsNDIuMjk0NDc4NSBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHBvaW50cz0iNTIuNjc4NTI1OSAwLjg1MzE2OTU0OSAxMDUuMzU3MDUyIDM5LjEyNjM1OSA4NS4yMzU2NDU0IDEwMS4wNTM2OCAyMC4xMjE0MDY0IDEwMS4wNTM2OCAtNi4zOTQ4ODQ2MmUtMTQgMzkuMTI2MzU5Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIxMTU0IDg1IDExOTQgODUgMTE5NCA2NSAxMjM0IDEwNC40OTc3NjcgMTE5NCAxNDUgMTE5NCAxMjUgMTE1NCAxMjUiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstWCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjcyLjQiIHk9IjI4MiI+QSA9Jmd0OyBYPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iQi09Jmd0Oy1YIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMzQzLjQiIHk9IjI4MiI+QiA9Jmd0OyBYPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iQi09Jmd0Oy1BIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI4OTAuNCIgeT0iMjgyIj5CID0mZ3Q7IEE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJjb250cmFtYXAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1Cb2xkLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTEuMjAwMDAwOCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjUxNy43NTk5OTgiIHk9IjEyMyI+Y29udHJhbWFwPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 7: Type chart: contramapping over a Function1</figcaption>
    </figure>
    <p>The compiler fails simply because of its left-to-right bias. We can prove this by creating a type alias that flips the parameters on Function1:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">&lt;=</span>[<span style="color: #4b69c6">B</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span></code></pre>
    <pre><code>scala<br>type F[A] = Double &lt;= A</code></pre>
    <p>If we re-type <code>func2</code> as an instance of <code>&lt;=</code>, we reset the required order of elimination and we can call <code>contramap</code> as desired:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func2b: <span style="color: #d73948">Double</span> <span style="color: #4b69c6">&lt;=</span> <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> func2</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> func3c <span style="color: #d73948">=</span> func2b.contramap(func1)<br><span style="color: #74747c">//</span><span style="color: #74747c"> func3c: Function1[Int, Double] = scala.Function1$$Lambda/0x000000006002f1a8@703e5ea8</span></code></pre>
    <p>The difference between <code>func2</code> and <code>func2b</code> is purely syntactic—both refer to the same value and the type aliases are otherwise completely compatible. Incredibly, however, this simple rephrasing is enough to give the compiler the hint it needs to solve the problem.</p>
    <p>It is rare that we have to do this kind of right-to-left elimination. Most multi-parameter type constructors are designed to be right-biased, requiring the left-to-right elimination that is supported by the compiler out of the box. However, it is useful to know about this quirk of elimination order in case you ever come across an odd scenario like the one above.</p>
    <h3 id="loc-226">9.9. Conclusions</h3>
    <p>Functors represent sequencing behaviours. We covered three types of functor in this chapter:</p>
    <ul>
      <li>
        <p>Regular covariant <code>Functors</code>, with their <code>map</code> method, represent the ability to apply functions to a value in some context. Successive calls to <code>map</code> apply these functions in <em>sequence</em>, each accepting the result of its predecessor as a parameter.</p>
      </li>
      <li>
        <p><code>Contravariant</code> functors, with their <code>contramap</code> method, represent the ability to “prepend” functions to a function-like context. Successive calls to <code>contramap</code> sequence these functions in the opposite order to <code>map</code>.</p>
      </li>
      <li>
        <p><code>Invariant</code> functors, with their <code>imap</code> method, represent bidirectional transformations.</p>
      </li>
    </ul>
    <p>Regular <code>Functors</code> are by far the most common of these type classes, but even then it is rare to use them on their own. Functors form a foundational building block of several more interesting abstractions that we use all the time. In the following chapters we will look at two of these abstractions: <strong>monads</strong> and <strong>applicative functors</strong>.</p>
    <p>Functors for collections are extremely important, as they transform each element independently of the rest. This allows us to parallelise or distribute transformations on large collections, a technique leveraged heavily in “map-reduce” frameworks popularized by <a href="http://hadoop.apache.org">Hadoop<a id="loc-227" href="#loc-640" role="doc-noteref"><sup>64</sup></a></a>. We will investigate this approach in more detail in the map-reduce case study later in <a href="#loc-419">Chapter 20</a>.</p>
    <p>The <code>Contravariant</code> and <code>Invariant</code> type classes are less widely applicable but are still useful for building data types that represent transformations. We will revisit them to discuss the <code>Semigroupal</code> type class later in <a href="#loc-295">Chapter 12</a>.</p>
    <h2 id="loc-228">10. Monads</h2>
    <p><strong>Monads</strong> are one of the best known abstractions in functional programming, but also the one that perhaps leads to the most confusion. Many programmers have used and are intuitively familiar with monads, even if we don’t know them by name.</p>
    <p>A monad in Scala is, informally, anything with a constructor and a <code>flatMap</code> method. All of the functors we saw in the last chapter are also monads, including <code>Option</code>, <code>List</code>, and <code>Future</code>. We even have special syntax to support monads: for comprehensions. However, despite the ubiquity of the concept, the Scala standard library lacks a concrete type to encompass “things that can be <code>flatMapped</code>”.</p>
    <p>In this chapter we will take a deep dive into monads. We will start by motivating them with a few examples. We’ll proceed to their formal definition, and see how we can create a concrete type as a type class. We’ll then look at their implementation in Cats. Finally, we’ll tour some interesting monads that you may not have seen, providing introductions and examples of their use.</p>
    <h3 id="loc-229">10.1. What is a Monad?</h3>
    <p>This is the question that has been posed in a thousand blog posts, with explanations and analogies involving concepts as diverse as cats, Mexican food, space suits full of toxic waste, and monoids in the category of endofunctors (whatever that means). We’re going to solve the problem of explaining monads once and for all by stating very simply: a monad is a mechanism for <em>sequencing computations</em>.</p>
    <p>That was easy! Problem solved, right? But then again, last chapter we said functors were a mechanism for exactly the same thing. Ok, maybe we need some more discussion…</p>
    <p>In <a href="#loc-188">Section 9.1</a> we said that functors allow us to sequence computations ignoring some complication. However, functors are limited in that they only allow this complication to occur once, at the beginning of the sequence. They don’t account for further complications at each step in the sequence.</p>
    <p>This is where monads come in. A monad’s <code>flatMap</code> method allows us to specify what happens next, taking into account an intermediate complication. The <code>flatMap</code> method of <code>Option</code> takes intermediate <code>Options</code> into account. The <code>flatMap</code> method of <code>List</code> handles intermediate <code>Lists</code>. And so on. In each case, the function passed to <code>flatMap</code> specifies the application-specific part of the computation, and <code>flatMap</code> itself takes care of the complication allowing us to <code>flatMap</code> again. Let’s ground things by looking at some examples.</p>
    <h4 id="loc-230">10.1.1. Options as Monads</h4>
    <p><code>Option</code> allows us to sequence computations that may or may not return values. Here are some examples:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">parseInt</span>(str: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  scala.util.<span style="color: #4b69c6">Try</span>(str.toInt).toOption<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">divide</span>(a: <span style="color: #d73948">Int</span>, b: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span>(b <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">None</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Some</span>(a / b)</code></pre>
    <p>Each of these methods may “fail” by returning <code>None</code>. The <code>flatMap</code> method allows us to ignore this when we sequence operations:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">stringDivideBy</span>(aStr: <span style="color: #4b69c6">String</span>, bStr: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  parseInt(aStr).flatMap { aNum <span style="color: #d73948">=</span>><br>    parseInt(bStr).flatMap { bNum <span style="color: #d73948">=</span>><br>      divide(aNum, bNum)<br>    }<br>  }</code></pre>
    <p>The semantics are:</p>
    <ul>
      <li>the first call to <code>parseInt</code> returns a <code>None</code> or a <code>Some</code>;</li>
      <li>if it returns a <code>Some</code>, the <code>flatMap</code> method calls our function and passes us the integer <code>aNum</code>;</li>
      <li>the second call to <code>parseInt</code> returns a <code>None</code> or a <code>Some</code>;</li>
      <li>if it returns a <code>Some</code>, the <code>flatMap</code> method calls our function and passes us <code>bNum</code>;</li>
      <li>the call to <code>divide</code> returns a <code>None</code> or a <code>Some</code>, which is our result.</li>
    </ul>
    <p>At each step, <code>flatMap</code> chooses whether to call our function, and our function generates the next computation in the sequence. This is shown in <a href="#loc-231">Figure 8</a>.</p>
    <figure id="loc-231">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5MTlweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE5MTkgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+b3B0aW9uLWZsYXRtYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xIiB4PSIwIiB5PSIwIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgcng9IjgiPjwvcmVjdD4KICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBhdGggZD0iTTUzLjU1ODA2MzksMTQzLjE5NDE0NiBMNDcsMTgxLjQzMDU5MyBMOTkuOTAwNjcyNywxNTMuNjE5MDY0IEwxNTIuODAxMzQ1LDE4MS40MzA1OTMgTDE0Mi42OTgyMTYsMTIyLjUyNDgyOCBMMTg1LjQ5NTc1OSw4MC44MDc1MzQgTDEyNi4zNTEwMDksNzIuMjEzMjk4OCBMMTI1Ljc1MjIxLDcxIEw1My41NTgwNjM5LDE0My4xOTQxNDYgWiIgaWQ9InBhdGgtMyI+PC9wYXRoPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTM4LjQ5NTc1OSIgaGVpZ2h0PSIxMTAuNDMwNTkzIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwYXRoIGQ9Ik01MS45Nzc3OTUsMTUxLjAwNzA1MyBMNTYuNzk3NTQzMiwxMjIuOTA1NzY1IEwxNCw4MS4xODg0NzA1IEw3My4xNDQ3NTAxLDcyLjU5NDIzNTMgTDk5LjU5NTA4NjUsMTkgTDEyNi4wNDU0MjMsNzIuNTk0MjM1MyBMMTI5LjgzOTMyNiw3My4xNDU1MjE3IEw1MS45Nzc3OTUsMTUxLjAwNzA1MyBaIiBpZD0icGF0aC01Ij48L3BhdGg+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMTUuODM5MzI2IiBoZWlnaHQ9IjEzMi4wMDcwNTMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtNyIgeD0iMCIgeT0iMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stOCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwYXRoIGQ9Ik01My41NTgwNjM5LDE0My4xOTQxNDYgTDQ3LDE4MS40MzA1OTMgTDk5LjkwMDY3MjcsMTUzLjYxOTA2NCBMMTUyLjgwMTM0NSwxODEuNDMwNTkzIEwxNDIuNjk4MjE2LDEyMi41MjQ4MjggTDE4NS40OTU3NTksODAuODA3NTM0IEwxMjYuMzUxMDA5LDcyLjIxMzI5ODggTDEyNS43NTIyMSw3MSBMNTMuNTU4MDYzOSwxNDMuMTk0MTQ2IFoiIGlkPSJwYXRoLTkiPjwvcGF0aD4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMzguNDk1NzU5IiBoZWlnaHQ9IjExMC40MzA1OTMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBhdGggZD0iTTUxLjk3Nzc5NSwxNTEuMDA3MDUzIEw1Ni43OTc1NDMyLDEyMi45MDU3NjUgTDE0LDgxLjE4ODQ3MDUgTDczLjE0NDc1MDEsNzIuNTk0MjM1MyBMOTkuNTk1MDg2NSwxOSBMMTI2LjA0NTQyMyw3Mi41OTQyMzUzIEwxMjkuODM5MzI2LDczLjE0NTUyMTcgTDUxLjk3Nzc5NSwxNTEuMDA3MDUzIFoiIGlkPSJwYXRoLTExIj48L3BhdGg+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTIiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTE1LjgzOTMyNiIgaGVpZ2h0PSIxMzIuMDA3MDUzIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cGF0aCBkPSJNMTUzLjgyMDQyMiw0Mi4wMDcxMzg5IEMxNjkuMzIxNDQ2LDU2Ljc3OTc2NDYgMTc5LDc3Ljc0NTQ4MDIgMTc5LDEwMSBDMTc5LDE0NS43MzUwNjUgMTQzLjE4Mjc4LDE4MiA5OSwxODIgQzc1LjY3NTE4OCwxODIgNTQuNjgxODIxNCwxNzEuODkzMTE5IDQwLjA1ODgwOCwxNTUuNzY4NzUzIEwxNTMuODIwNDIyLDQyLjAwNzEzODkgWiIgaWQ9InBhdGgtMTMiPjwvcGF0aD4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMzguOTQxMTkyIiBoZWlnaHQ9IjEzOS45OTI4NjEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwYXRoIGQ9Ik0xNTcuMDU4ODM3LDQ0LjkyNjAxMTUgQzE0Mi41NDQ2NDQsMzAuMTU4NTA1MiAxMjIuMzQxODY0LDIxIDEwMCwyMSBDNTUuODE3MjIsMjEgMjAsNTYuODE3MjIgMjAsMTAxIEMyMCwxMjMuMzQxODY0IDI5LjE1ODUwNTIsMTQzLjU0NDY0NCA0My45MjYwMTE1LDE1OC4wNTg4MzcgTDE1Ny4wNTg4MzcsNDQuOTI2MDExNSBaIiBpZD0icGF0aC0xNSI+PC9wYXRoPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE2IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjEzNy4wNTg4MzciIGhlaWdodD0iMTM3LjA1ODgzNyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTE1Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTciIHg9IjAiIHk9IjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiByeD0iOCI+PC9yZWN0PgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE4IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTE5IiBjeD0iODkwIiBjeT0iMTQwIiByeD0iODAiIHJ5PSI4MCI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTIwIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE2MCIgaGVpZ2h0PSIxNjAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xOSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTIxIiBwb2ludHM9Ijk5NCAxMjAgMTAzNCAxMjAgMTAzNCAxMDAgMTA3NCAxMzkuNDk3NzY3IDEwMzQgMTgwIDEwMzQgMTYwIDk5NCAxNjAiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0yMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTIxIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ib3B0aW9uLWZsYXRtYXAiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MTkiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNDYwLjAwMDAwMCwgMzguMDAwMDAwKSIgc3Ryb2tlLXdpZHRoPSI4Ij4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0yKSIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJDb21iaW5lZC1TaGFwZSIgc3Ryb2tlPSIjOUI5QjlCIiBtYXNrPSJ1cmwoI21hc2stNCkiIHN0cm9rZS1kYXNoYXJyYXk9IjEwLDUiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iQ29tYmluZWQtU2hhcGUiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTYpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTEwMC4wMDAwMDAsIDM5LjAwMDAwMCkiIHN0cm9rZS13aWR0aD0iOCI+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stOCkiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iQ29tYmluZWQtU2hhcGUiIHN0cm9rZT0iIzlCOUI5QiIgbWFzaz0idXJsKCNtYXNrLTEwKSIgc3Ryb2tlLWRhc2hhcnJheT0iMTAsNSIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJDb21iaW5lZC1TaGFwZSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTIpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xMSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1Ny4wMDAwMDAsIDM4LjAwMDAwMCkiIHN0cm9rZS13aWR0aD0iOCI+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJDb21iaW5lZC1TaGFwZSIgc3Ryb2tlPSIjOUI5QjlCIiBtYXNrPSJ1cmwoI21hc2stMTQpIiBzdHJva2UtZGFzaGFycmF5PSIxMCw1IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJDb21iaW5lZC1TaGFwZSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTYpIiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xNSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTgpIiB4bGluazpocmVmPSIjcGF0aC0xNyI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0yMCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTkiPjwvdXNlPgogICAgICAgICAgICA8dXNlIGlkPSJQYXRoLTEiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTIyKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjMDAwMDAwIiB4bGluazpocmVmPSIjcGF0aC0yMSI+PC91c2U+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMTM0MiAxMjAgMTM4MiAxMjAgMTM4MiAxMDAgMTQyMiAxMzkuNDk3NzY3IDEzODIgMTgwIDEzODIgMTYwIDEzNDIgMTYwIj48L3BvbHlnb24+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJPcHRpb25bQV0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjI0Ny4xIiB5PSIzMTQiPk9wdGlvbltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9ImZsYXRNYXAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1Cb2xkLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjQiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjRjZBNjIzIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI0OTQuMiIgeT0iMTU2Ij5mbGF0TWFwPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iT3B0aW9uW0JdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxNDQ4LjYiIHk9IjMxNCI+T3B0aW9uW0JdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1PcHRpb25bQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijg4NS42IiB5PSIzMTQiPkEgPSZndDsgT3B0aW9uW0JdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+" style="width: 80%">
      <figcaption>Figure 8: Type chart: flatMap for Option</figcaption>
    </figure>
    <p>The result of the computation is an <code>Option</code>, allowing us to call <code>flatMap</code> again and so the sequence continues. This results in the fail-fast error handling behaviour that we know and love, where a <code>None</code> at any step results in a <code>None</code> overall:</p>
    <pre><code data-lang="scala">stringDivideBy(<span style="color: #198810">"</span><span style="color: #198810">6</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">2</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Option[Int] = Some(value = 3)</span><br>stringDivideBy(<span style="color: #198810">"</span><span style="color: #198810">6</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">0</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Option[Int] = None</span><br>stringDivideBy(<span style="color: #198810">"</span><span style="color: #198810">6</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">foo</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Option[Int] = None</span><br>stringDivideBy(<span style="color: #198810">"</span><span style="color: #198810">bar</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">2</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Option[Int] = None</span></code></pre>
    <p>Every monad is also a functor (see below for proof), so we can rely on both <code>flatMap</code> and <code>map</code> to sequence computations that do and don’t introduce a new monad respectively. Plus, if we have both <code>flatMap</code> and <code>map</code> we can use for comprehensions to clarify the sequencing behaviour:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">stringDivideBy</span>(aStr: <span style="color: #4b69c6">String</span>, bStr: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">for</span> {<br>    aNum <span style="color: #d73948">&lt;-</span> parseInt(aStr)<br>    bNum <span style="color: #d73948">&lt;-</span> parseInt(bStr)<br>    ans  <span style="color: #d73948">&lt;-</span> divide(aNum, bNum)<br>  } <span style="color: #d73948">yield</span> ans</code></pre>
    <h4 id="loc-232">10.1.2. Lists as Monads</h4>
    <p>When we first encounter <code>flatMap</code> as budding Scala developers, we tend to think of it as a pattern for iterating over <code>Lists</code>. This is reinforced by the syntax of for comprehensions, which look very much like imperative for loops:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">for</span> {<br>  x <span style="color: #d73948">&lt;-</span> (<span style="color: #b60157">1</span> to <span style="color: #b60157">3</span>).toList<br>  y <span style="color: #d73948">&lt;-</span> (<span style="color: #b60157">4</span> to <span style="color: #b60157">5</span>).toList<br>} <span style="color: #d73948">yield</span> (x, y)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: List[Tuple2[Int, Int]] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   (1, 4),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   (1, 5),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   (2, 4),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   (2, 5),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   (3, 4),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   (3, 5)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>However, there is another mental model we can apply that highlights the monadic behaviour of <code>List</code>. If we think of <code>Lists</code> as sets of intermediate results, <code>flatMap</code> becomes a construct that calculates permutations and combinations.</p>
    <p>For example, in the for comprehension above there are three possible values of <code>x</code> and two possible values of <code>y</code>. This means there are six possible values of <code>(x, y)</code>. <code>flatMap</code> is generating these combinations from our code, which states the sequence of operations:</p>
    <ul>
      <li>get <code>x</code></li>
      <li>get <code>y</code></li>
      <li>create a tuple <code>(x, y)</code></li>
    </ul>
    <p>The type chart in <a href="#loc-234">Figure 9</a> illustrates this behaviour<a id="loc-233" href="#loc-641" role="doc-noteref"><sup>65</sup></a>.</p>
    <figure id="loc-234">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTkyMHB4IiBoZWlnaHQ9IjM2MHB4IiB2aWV3Qm94PSIwIDAgMTkyMCAzNjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5saXN0LWZsYXRtYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8Y2lyY2xlIGlkPSJwYXRoLTEiIGN4PSI4MCIgY3k9IjgwIiByPSI4MCI+PC9jaXJjbGU+CiAgICAgICAgPGNpcmNsZSBpZD0icGF0aC0yIiBjeD0iMTAwIiBjeT0iMTAwIiByPSI4MCI+PC9jaXJjbGU+CiAgICAgICAgPGNpcmNsZSBpZD0icGF0aC0zIiBjeD0iMTIwIiBjeT0iMTIwIiByPSI4MCI+PC9jaXJjbGU+CiAgICAgICAgPGNpcmNsZSBpZD0icGF0aC00IiBjeD0iODg3IiBjeT0iMTQzIiByPSI4MCI+PC9jaXJjbGU+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNSIgcG9pbnRzPSI4NS41OTUwODY1IDEzNSAzMi42OTQ0MTM4IDE2Mi44MTE1MjkgNDIuNzk3NTQzMiAxMDMuOTA1NzY1IDUuNDE3ODg4MzZlLTE0IDYyLjE4ODQ3MDUgNTkuMTQ0NzUwMSA1My41OTQyMzUzIDg1LjU5NTA4NjUgNC4yNjMyNTY0MWUtMTQgMTEyLjA0NTQyMyA1My41OTQyMzUzIDE3MS4xOTAxNzMgNjIuMTg4NDcwNSAxMjguMzkyNjMgMTAzLjkwNTc2NSAxMzguNDk1NzU5IDE2Mi44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC02IiBwb2ludHM9IjEwMy41OTUwODYgMTU3IDUwLjY5NDQxMzggMTg0LjgxMTUyOSA2MC43OTc1NDMyIDEyNS45MDU3NjUgMTggODQuMTg4NDcwNSA3Ny4xNDQ3NTAxIDc1LjU5NDIzNTMgMTAzLjU5NTA4NiAyMiAxMzAuMDQ1NDIzIDc1LjU5NDIzNTMgMTg5LjE5MDE3MyA4NC4xODg0NzA1IDE0Ni4zOTI2MyAxMjUuOTA1NzY1IDE1Ni40OTU3NTkgMTg0LjgxMTUyOSI+PC9wb2x5Z29uPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTciIHBvaW50cz0iMTIzLjU5NTA4NiAxNzcgNzAuNjk0NDEzOCAyMDQuODExNTI5IDgwLjc5NzU0MzIgMTQ1LjkwNTc2NSAzOCAxMDQuMTg4NDcxIDk3LjE0NDc1MDEgOTUuNTk0MjM1MyAxMjMuNTk1MDg2IDQyIDE1MC4wNDU0MjMgOTUuNTk0MjM1MyAyMDkuMTkwMTczIDEwNC4xODg0NzEgMTY2LjM5MjYzIDE0NS45MDU3NjUgMTc2LjQ5NTc1OSAyMDQuODExNTI5Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtOCIgcG9pbnRzPSI4NS41OTUwODY1IDEzNSAzMi42OTQ0MTM4IDE2Mi44MTE1MjkgNDIuNzk3NTQzMiAxMDMuOTA1NzY1IC0xLjE3MjM5NTUxZS0xMyA2Mi4xODg0NzA1IDU5LjE0NDc1MDEgNTMuNTk0MjM1MyA4NS41OTUwODY1IDAgMTEyLjA0NTQyMyA1My41OTQyMzUzIDE3MS4xOTAxNzMgNjIuMTg4NDcwNSAxMjguMzkyNjMgMTAzLjkwNTc2NSAxMzguNDk1NzU5IDE2Mi44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC05IiBwb2ludHM9IjEwMS41OTUwODYgMTU1IDQ4LjY5NDQxMzggMTgyLjgxMTUyOSA1OC43OTc1NDMyIDEyMy45MDU3NjUgMTYgODIuMTg4NDcwNSA3NS4xNDQ3NTAxIDczLjU5NDIzNTMgMTAxLjU5NTA4NiAyMCAxMjguMDQ1NDIzIDczLjU5NDIzNTMgMTg3LjE5MDE3MyA4Mi4xODg0NzA1IDE0NC4zOTI2MyAxMjMuOTA1NzY1IDE1NC40OTU3NTkgMTgyLjgxMTUyOSI+PC9wb2x5Z29uPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTEwIiBwb2ludHM9IjExOS41OTUwODYgMTc4IDY2LjY5NDQxMzggMjA1LjgxMTUyOSA3Ni43OTc1NDMyIDE0Ni45MDU3NjUgMzQgMTA1LjE4ODQ3MSA5My4xNDQ3NTAxIDk2LjU5NDIzNTMgMTE5LjU5NTA4NiA0MyAxNDYuMDQ1NDIzIDk2LjU5NDIzNTMgMjA1LjE5MDE3MyAxMDUuMTg4NDcxIDE2Mi4zOTI2MyAxNDYuOTA1NzY1IDE3Mi40OTU3NTkgMjA1LjgxMTUyOSI+PC9wb2x5Z29uPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTExIiBwb2ludHM9Ijk5OCAxMjMgMTAzOCAxMjMgMTAzOCAxMDMgMTA3OCAxNDIuNDk3NzY3IDEwMzggMTgzIDEwMzggMTYzIDk5OCAxNjMiPjwvcG9seWdvbj4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJsaXN0LWZsYXRtYXAiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjAiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1OS4wMDAwMDAsIDQwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI4MCIgY3k9IjgwIiByPSI3OCI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjEwMCIgY3k9IjEwMCIgcj0iNzgiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSIxMjAiIGN5PSIxMjAiIHI9Ijc4Ij48L2NpcmNsZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xLUNvcHkiPgogICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTQiPjwvdXNlPgogICAgICAgICAgICAgICAgPGNpcmNsZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9Ijg4NyIgY3k9IjE0MyIgcj0iNzgiPjwvY2lyY2xlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA5NS4wMDAwMDAsIDQwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMS1Db3B5Ij4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik0zNS4zNTA2NzU4LDE1OS4xNTU0OTggTDQ0Ljc2ODc1OTksMTA0LjI0Mzg1NSBMNDQuOTQ2NTA0NCwxMDMuMjA3NTI1IEw0NC4xOTM1NjY2LDEwMi40NzM1OTIgTDQuMjk3OTIyMjgsNjMuNTg0OTUwMSBMNTkuNDMyMzQ2Nyw1NS41NzM0NDkzIEw2MC40NzI4ODExLDU1LjQyMjI1MDggTDYwLjkzODIyMjMsNTQuNDc5MzY2NyBMODUuNTk1MDg2NSw0LjUxOTEwMjkyIEwxMTAuMjUxOTUxLDU0LjQ3OTM2NjcgTDExMC43MTcyOTIsNTUuNDIyMjUwOCBMMTExLjc1NzgyNiw1NS41NzM0NDkzIEwxNjYuODkyMjUxLDYzLjU4NDk1MDEgTDEyNi45OTY2MDYsMTAyLjQ3MzU5MiBMMTI2LjI0MzY2OSwxMDMuMjA3NTI1IEwxMjYuNDIxNDEzLDEwNC4yNDM4NTUgTDEzNS44Mzk0OTcsMTU5LjE1NTQ5OCBMODYuNTI1NzY4NywxMzMuMjI5NzM3IEw4NS41OTUwODY1LDEzMi43NDA0NDkgTDg0LjY2NDQwNDIsMTMzLjIyOTczNyBMMzUuMzUwNjc1OCwxNTkuMTU1NDk4IFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC02Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTUzLjM1MDY3NTgsMTgxLjE1NTQ5OCBMNjIuNzY4NzU5OSwxMjYuMjQzODU1IEw2Mi45NDY1MDQ0LDEyNS4yMDc1MjUgTDYyLjE5MzU2NjYsMTI0LjQ3MzU5MiBMMjIuMjk3OTIyMyw4NS41ODQ5NTAxIEw3Ny40MzIzNDY3LDc3LjU3MzQ0OTMgTDc4LjQ3Mjg4MTEsNzcuNDIyMjUwOCBMNzguOTM4MjIyMyw3Ni40NzkzNjY3IEwxMDMuNTk1MDg2LDI2LjUxOTEwMjkgTDEyOC4yNTE5NTEsNzYuNDc5MzY2NyBMMTI4LjcxNzI5Miw3Ny40MjIyNTA4IEwxMjkuNzU3ODI2LDc3LjU3MzQ0OTMgTDE4NC44OTIyNTEsODUuNTg0OTUwMSBMMTQ0Ljk5NjYwNiwxMjQuNDczNTkyIEwxNDQuMjQzNjY5LDEyNS4yMDc1MjUgTDE0NC40MjE0MTMsMTI2LjI0Mzg1NSBMMTUzLjgzOTQ5NywxODEuMTU1NDk4IEwxMDQuNTI1NzY5LDE1NS4yMjk3MzcgTDEwMy41OTUwODYsMTU0Ljc0MDQ0OSBMMTAyLjY2NDQwNCwxNTUuMjI5NzM3IEw1My4zNTA2NzU4LDE4MS4xNTU0OTggWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNNzMuMzUwNjc1OCwyMDEuMTU1NDk4IEw4Mi43Njg3NTk5LDE0Ni4yNDM4NTUgTDgyLjk0NjUwNDQsMTQ1LjIwNzUyNSBMODIuMTkzNTY2NiwxNDQuNDczNTkyIEw0Mi4yOTc5MjIzLDEwNS41ODQ5NSBMOTcuNDMyMzQ2Nyw5Ny41NzM0NDkzIEw5OC40NzI4ODExLDk3LjQyMjI1MDggTDk4LjkzODIyMjMsOTYuNDc5MzY2NyBMMTIzLjU5NTA4Niw0Ni41MTkxMDI5IEwxNDguMjUxOTUxLDk2LjQ3OTM2NjcgTDE0OC43MTcyOTIsOTcuNDIyMjUwOCBMMTQ5Ljc1NzgyNiw5Ny41NzM0NDkzIEwyMDQuODkyMjUxLDEwNS41ODQ5NSBMMTY0Ljk5NjYwNiwxNDQuNDczNTkyIEwxNjQuMjQzNjY5LDE0NS4yMDc1MjUgTDE2NC40MjE0MTMsMTQ2LjI0Mzg1NSBMMTczLjgzOTQ5NywyMDEuMTU1NDk4IEwxMjQuNTI1NzY5LDE3NS4yMjk3MzcgTDEyMy41OTUwODYsMTc0Ljc0MDQ0OSBMMTIyLjY2NDQwNCwxNzUuMjI5NzM3IEw3My4zNTA2NzU4LDIwMS4xNTU0OTggWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC1Db3B5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNDU3LjAwMDAwMCwgNDAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iU3Rhci0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtOCI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik0zNS4zNTA2NzU4LDE1OS4xNTU0OTggTDQ0Ljc2ODc1OTksMTA0LjI0Mzg1NSBMNDQuOTQ2NTA0NCwxMDMuMjA3NTI1IEw0NC4xOTM1NjY2LDEwMi40NzM1OTIgTDQuMjk3OTIyMjgsNjMuNTg0OTUwMSBMNTkuNDMyMzQ2Nyw1NS41NzM0NDkzIEw2MC40NzI4ODExLDU1LjQyMjI1MDggTDYwLjkzODIyMjMsNTQuNDc5MzY2NyBMODUuNTk1MDg2NSw0LjUxOTEwMjkyIEwxMTAuMjUxOTUxLDU0LjQ3OTM2NjcgTDExMC43MTcyOTIsNTUuNDIyMjUwOCBMMTExLjc1NzgyNiw1NS41NzM0NDkzIEwxNjYuODkyMjUxLDYzLjU4NDk1MDEgTDEyNi45OTY2MDYsMTAyLjQ3MzU5MiBMMTI2LjI0MzY2OSwxMDMuMjA3NTI1IEwxMjYuNDIxNDEzLDEwNC4yNDM4NTUgTDEzNS44Mzk0OTcsMTU5LjE1NTQ5OCBMODYuNTI1NzY4NywxMzMuMjI5NzM3IEw4NS41OTUwODY1LDEzMi43NDA0NDkgTDg0LjY2NDQwNDIsMTMzLjIyOTczNyBMMzUuMzUwNjc1OCwxNTkuMTU1NDk4IFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTUxLjM1MDY3NTgsMTc5LjE1NTQ5OCBMNjAuNzY4NzU5OSwxMjQuMjQzODU1IEw2MC45NDY1MDQ0LDEyMy4yMDc1MjUgTDYwLjE5MzU2NjYsMTIyLjQ3MzU5MiBMMjAuMjk3OTIyMyw4My41ODQ5NTAxIEw3NS40MzIzNDY3LDc1LjU3MzQ0OTMgTDc2LjQ3Mjg4MTEsNzUuNDIyMjUwOCBMNzYuOTM4MjIyMyw3NC40NzkzNjY3IEwxMDEuNTk1MDg2LDI0LjUxOTEwMjkgTDEyNi4yNTE5NTEsNzQuNDc5MzY2NyBMMTI2LjcxNzI5Miw3NS40MjIyNTA4IEwxMjcuNzU3ODI2LDc1LjU3MzQ0OTMgTDE4Mi44OTIyNTEsODMuNTg0OTUwMSBMMTQyLjk5NjYwNiwxMjIuNDczNTkyIEwxNDIuMjQzNjY5LDEyMy4yMDc1MjUgTDE0Mi40MjE0MTMsMTI0LjI0Mzg1NSBMMTUxLjgzOTQ5NywxNzkuMTU1NDk4IEwxMDIuNTI1NzY5LDE1My4yMjk3MzcgTDEwMS41OTUwODYsMTUyLjc0MDQ0OSBMMTAwLjY2NDQwNCwxNTMuMjI5NzM3IEw1MS4zNTA2NzU4LDE3OS4xNTU0OTggWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEwIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTY5LjM1MDY3NTgsMjAyLjE1NTQ5OCBMNzguNzY4NzU5OSwxNDcuMjQzODU1IEw3OC45NDY1MDQ0LDE0Ni4yMDc1MjUgTDc4LjE5MzU2NjYsMTQ1LjQ3MzU5MiBMMzguMjk3OTIyMywxMDYuNTg0OTUgTDkzLjQzMjM0NjcsOTguNTczNDQ5MyBMOTQuNDcyODgxMSw5OC40MjIyNTA4IEw5NC45MzgyMjIzLDk3LjQ3OTM2NjcgTDExOS41OTUwODYsNDcuNTE5MTAyOSBMMTQ0LjI1MTk1MSw5Ny40NzkzNjY3IEwxNDQuNzE3MjkyLDk4LjQyMjI1MDggTDE0NS43NTc4MjYsOTguNTczNDQ5MyBMMjAwLjg5MjI1MSwxMDYuNTg0OTUgTDE2MC45OTY2MDYsMTQ1LjQ3MzU5MiBMMTYwLjI0MzY2OSwxNDYuMjA3NTI1IEwxNjAuNDIxNDEzLDE0Ny4yNDM4NTUgTDE2OS44Mzk0OTcsMjAyLjE1NTQ5OCBMMTIwLjUyNTc2OSwxNzYuMjI5NzM3IEwxMTkuNTk1MDg2LDE3NS43NDA0NDkgTDExOC42NjQ0MDQsMTc2LjIyOTczNyBMNjkuMzUwNjc1OCwyMDIuMTU1NDk4IFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iUGF0aC0xLUNvcHkiPgogICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjMDAwMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMTAwMCwxMjUgTDEwMzgsMTI1IEwxMDQwLDEyNSBMMTA0MCwxMjMgTDEwNDAsMTA3Ljc4NTYxNSBMMTA3NS4xNzE1MiwxNDIuNTE1NTI1IEwxMDQwLDE3OC4xMjg2NDkgTDEwNDAsMTYzIEwxMDQwLDE2MSBMMTAzOCwxNjEgTDEwMDAsMTYxIEwxMDAwLDEyNSBaIj48L3BhdGg+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMTMzOSAxMjMgMTM3OSAxMjMgMTM3OSAxMDMgMTQxOSAxNDIuNDk3NzY3IDEzNzkgMTgzIDEzNzkgMTYzIDEzMzkgMTYzIj48L3BvbHlnb24+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJMaXN0W0FdLUNvcHkiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjI3MS4zIiB5PSIzMTciPkxpc3RbQV08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJmbGF0TWFwIiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjY0IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNDk1LjYiIHk9IjE1OSI+ZmxhdE1hcDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ikxpc3RbQl0tQ29weSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTQ3NC44IiB5PSIzMTciPkxpc3RbQl08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUxpc3RbQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjkwNy44IiB5PSIzMTciPkEgPSZndDsgTGlzdFtCXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==" style="width: 80%">
      <figcaption>Figure 9: Type chart: flatMap for List</figcaption>
    </figure>
    <h4 id="loc-235">10.1.3. Futures as Monads</h4>
    <p><code>Future</code> is a monad that sequences computations without worrying that they may be asynchronous:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.Future<br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">doSomethingLongRunning</span>: <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">doSomethingElseLongRunning</span>: <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">doSomethingVeryLongRunning</span>: <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">for</span> {<br>    result1 <span style="color: #d73948">&lt;-</span> doSomethingLongRunning<br>    result2 <span style="color: #d73948">&lt;-</span> doSomethingElseLongRunning<br>  } <span style="color: #d73948">yield</span> result1 + result2</code></pre>
    <p>Again, we specify the code to run at each step, and <code>flatMap</code> takes care of all the horrifying underlying complexities of thread pools and schedulers.</p>
    <p>If you’ve made extensive use of <code>Future</code>, you’ll know that the code above is running each operation <em>in sequence</em>. This becomes clearer if we expand out the for comprehension to show the nested calls to <code>flatMap</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">doSomethingVeryLongRunning</span>: <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  doSomethingLongRunning.flatMap { result1 <span style="color: #d73948">=</span>><br>    doSomethingElseLongRunning.map { result2 <span style="color: #d73948">=</span>><br>      result1 + result2<br>    }<br>  }</code></pre>
    <p>Each <code>Future</code> in our sequence is created by a function that receives the result from a previous <code>Future</code>. In other words, each step in our computation can only start once the previous step is finished. This is born out by the type chart for <code>flatMap</code> in <a href="#loc-236">Figure 10</a>, which shows the function parameter of type <code>A => Future[B]</code>.</p>
    <figure id="loc-236">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5MjJweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE5MjIgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+ZnV0dXJlLWZsYXRtYXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xIiBjeD0iODAiIGN5PSI4MCIgcng9IjgwIiByeT0iODAiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE2MCIgaGVpZ2h0PSIxNjAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMyIgY3g9Ijg0MCIgY3k9IjE0MyIgcng9IjgwIiByeT0iODAiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay00IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE2MCIgaGVpZ2h0PSIxNjAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNSIgcG9pbnRzPSIxMzUuNTk1MDg2IDE1NyA4Mi42OTQ0MTM4IDE4NC44MTE1MjkgOTIuNzk3NTQzMiAxMjUuOTA1NzY1IDUwIDg0LjE4ODQ3MDUgMTA5LjE0NDc1IDc1LjU5NDIzNTMgMTM1LjU5NTA4NiAyMiAxNjIuMDQ1NDIzIDc1LjU5NDIzNTMgMjIxLjE5MDE3MyA4NC4xODg0NzA1IDE3OC4zOTI2MyAxMjUuOTA1NzY1IDE4OC40OTU3NTkgMTg0LjgxMTUyOSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTcxLjE5MDE3MyIgaGVpZ2h0PSIxNjIuODExNTI5IiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTciIHBvaW50cz0iODUuNTk1MDg2NSAxMzUgMzIuNjk0NDEzOCAxNjIuODExNTI5IDQyLjc5NzU0MzIgMTAzLjkwNTc2NSA1LjMyOTA3MDUyZS0xNCA2Mi4xODg0NzA1IDU5LjE0NDc1MDEgNTMuNTk0MjM1MyA4NS41OTUwODY1IDAgMTEyLjA0NTQyMyA1My41OTQyMzUzIDE3MS4xOTAxNzMgNjIuMTg4NDcwNSAxMjguMzkyNjMgMTAzLjkwNTc2NSAxMzguNDk1NzU5IDE2Mi44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay04IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MS4xOTAxNzMiIGhlaWdodD0iMTYyLjgxMTUyOSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC05IiBwb2ludHM9Ijk1OCAxMjMgOTk4IDEyMyA5OTggMTAzIDEwMzggMTQyLjQ5Nzc2NyA5OTggMTgzIDk5OCAxNjMgOTU4IDE2MyI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTEwIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgPC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImZ1dHVyZS1mbGF0bWFwIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTIyIiBoZWlnaHQ9IjM2MCI+PC9yZWN0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1Ny4wMDAwMDAsIDI5LjAwMDAwMCkiIHN0cm9rZT0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjMzLjMxNTM2MSwxODEuNDY3NzIxIEMyNTUuMDA2MTY5LDE3MC45OTI0NzEgMjY2LDE1NC45NjEyMTQgMjY2LDEzMi44IEMyNjYsMTA2Ljc1MDIzMiAyNTAuODA5NTgzLDg5LjE3MDM1OSAyMjAuOTEwODg5LDc5LjEyODE4OTYgQzIyNC45MDcyODgsNzIuMDc4MTA0MyAyMjcuMTMyOTI0LDY0LjI0NzI1MTUgMjI3LjEzMjkyNCw1NiBDMjI3LjEzMjkyNCwyNS4wNzIwNTQgMTk1LjgzMzQsMCAxNTcuMjIzNDgyLDAgQzEzOC4xNzQyMzMsMCAxMjAuOTA0NDg4LDYuMTAzMDYyODUgMTA4LjI5NTI5OSwxNi4wMDEzNiBDMTAzLjg4Nzg3MiwxNC45NTQ4NzU2IDk5LjI4MTc3MTQsMTQuNCA5NC41NDIxNjg3LDE0LjQgQzYyLjY4MjY1OCwxNC40IDM2Ljg1NTQyMTcsMzkuNDcyMDU0IDM2Ljg1NTQyMTcsNzAuNCBDMzYuODU1NDIxNyw3NC45MDkyMDAyIDM3LjQwNDQyNDgsNzkuMjkzOTIzMSAzOC40NDEwODMxLDgzLjQ5NDYxNDcgQzEzLjY4MDAwOSw5My45NTIzNzMyIDAsMTEwLjE4NDE2NyAwLDEzMi44IEMwLDE2OC4yNDg2MjYgMzMuNjA5MzQ0OSwxODguMDEyODA4IDkwLjgxOTgwMjIsMTk0LjQ0MTU5NCBDMTAzLjc4NzY3OCwyMTIuMDM1Njk2IDEyOS4yOTQwNjEsMjI0IDE1OC42Mzg1NTQsMjI0IEMxOTQuNzQwOTM2LDIyNCAyMjUuMDMzODU3LDIwNS44OTA1MjEgMjMzLjMxNTM2LDE4MS40Njc3MjUgWiIgaWQ9IkNvbWJpbmVkLVNoYXBlIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1Ny4wMDAwMDAsIDMxLjAwMDAwMCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xIiBtYXNrPSJ1cmwoI21hc2stMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stNCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA3OS4wMDAwMDAsIDQwLjAwMDAwMCkiIHN0cm9rZT0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjMzLjMxNTM2MSwxODEuNDY3NzIxIEMyNTUuMDA2MTY5LDE3MC45OTI0NzEgMjY2LDE1NC45NjEyMTQgMjY2LDEzMi44IEMyNjYsMTA2Ljc1MDIzMiAyNTAuODA5NTgzLDg5LjE3MDM1OSAyMjAuOTEwODg5LDc5LjEyODE4OTYgQzIyNC45MDcyODgsNzIuMDc4MTA0MyAyMjcuMTMyOTI0LDY0LjI0NzI1MTUgMjI3LjEzMjkyNCw1NiBDMjI3LjEzMjkyNCwyNS4wNzIwNTQgMTk1LjgzMzQsMCAxNTcuMjIzNDgyLDAgQzEzOC4xNzQyMzMsMCAxMjAuOTA0NDg4LDYuMTAzMDYyODUgMTA4LjI5NTI5OSwxNi4wMDEzNiBDMTAzLjg4Nzg3MiwxNC45NTQ4NzU2IDk5LjI4MTc3MTQsMTQuNCA5NC41NDIxNjg3LDE0LjQgQzYyLjY4MjY1OCwxNC40IDM2Ljg1NTQyMTcsMzkuNDcyMDU0IDM2Ljg1NTQyMTcsNzAuNCBDMzYuODU1NDIxNyw3NC45MDkyMDAyIDM3LjQwNDQyNDgsNzkuMjkzOTIzMSAzOC40NDEwODMxLDgzLjQ5NDYxNDcgQzEzLjY4MDAwOSw5My45NTIzNzMyIDAsMTEwLjE4NDE2NyAwLDEzMi44IEMwLDE2OC4yNDg2MjYgMzMuNjA5MzQ0OSwxODguMDEyODA4IDkwLjgxOTgwMjIsMTk0LjQ0MTU5NCBDMTAzLjc4NzY3OCwyMTIuMDM1Njk2IDEyOS4yOTQwNjEsMjI0IDE1OC42Mzg1NTQsMjI0IEMxOTQuNzQwOTM2LDIyNCAyMjUuMDMzODU3LDIwNS44OTA1MjEgMjMzLjMxNTM2LDE4MS40Njc3MjUgWiIgaWQ9IkNvbWJpbmVkLVNoYXBlIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMSIgbWFzaz0idXJsKCNtYXNrLTYpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUwMi4wMDAwMDAsIDM4LjAwMDAwMCkiIHN0cm9rZT0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjMzLjMxNTM2MSwxODEuNDY3NzIxIEMyNTUuMDA2MTY5LDE3MC45OTI0NzEgMjY2LDE1NC45NjEyMTQgMjY2LDEzMi44IEMyNjYsMTA2Ljc1MDIzMiAyNTAuODA5NTgzLDg5LjE3MDM1OSAyMjAuOTEwODg5LDc5LjEyODE4OTYgQzIyNC45MDcyODgsNzIuMDc4MTA0MyAyMjcuMTMyOTI0LDY0LjI0NzI1MTUgMjI3LjEzMjkyNCw1NiBDMjI3LjEzMjkyNCwyNS4wNzIwNTQgMTk1LjgzMzQsMCAxNTcuMjIzNDgyLDAgQzEzOC4xNzQyMzMsMCAxMjAuOTA0NDg4LDYuMTAzMDYyODUgMTA4LjI5NTI5OSwxNi4wMDEzNiBDMTAzLjg4Nzg3MiwxNC45NTQ4NzU2IDk5LjI4MTc3MTQsMTQuNCA5NC41NDIxNjg3LDE0LjQgQzYyLjY4MjY1OCwxNC40IDM2Ljg1NTQyMTcsMzkuNDcyMDU0IDM2Ljg1NTQyMTcsNzAuNCBDMzYuODU1NDIxNyw3NC45MDkyMDAyIDM3LjQwNDQyNDgsNzkuMjkzOTIzMSAzOC40NDEwODMxLDgzLjQ5NDYxNDcgQzEzLjY4MDAwOSw5My45NTIzNzMyIDAsMTEwLjE4NDE2NyAwLDEzMi44IEMwLDE2OC4yNDg2MjYgMzMuNjA5MzQ0OSwxODguMDEyODA4IDkwLjgxOTgwMjIsMTk0LjQ0MTU5NCBDMTAzLjc4NzY3OCwyMTIuMDM1Njk2IDEyOS4yOTQwNjEsMjI0IDE1OC42Mzg1NTQsMjI0IEMxOTQuNzQwOTM2LDIyNCAyMjUuMDMzODU3LDIwNS44OTA1MjEgMjMzLjMxNTM2LDE4MS40Njc3MjUgWiIgaWQ9IkNvbWJpbmVkLVNoYXBlIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDguMDAwMDAwLCAyMi4wMDAwMDApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMSIgbWFzaz0idXJsKCNtYXNrLTgpIiB4bGluazpocmVmPSIjcGF0aC03Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dXNlIGlkPSJQYXRoLTEiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTEwKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjMDAwMDAwIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIxMzg4IDEyMyAxNDI4IDEyMyAxNDI4IDEwMyAxNDY4IDE0Mi40OTc3NjcgMTQyOCAxODMgMTQyOCAxNjMgMTM4OCAxNjMiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkZ1dHVyZVtBXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTg3LjYiIHk9IjMxNyI+RnV0dXJlW0FdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iRnV0dXJlW0JdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxNTExLjYiIHk9IjMxNyI+RnV0dXJlW0JdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GdXR1cmVbQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijg3NS42IiB5PSIzMTciPkEgPSZndDsgRnV0dXJlW0JdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iZmxhdE1hcCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI2NCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjQ1My4yIiB5PSIxNTgiPmZsYXRNYXA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=" style="width: 80%">
      <figcaption>Figure 10: Type chart: flatMap for Future</figcaption>
    </figure>
    <p>We <em>can</em> run futures in parallel, of course, but that is another story and shall be told another time. Monads are all about sequencing.</p>
    <h4 id="loc-237">10.1.4. Definition of a Monad</h4>
    <p>While we have only talked about <code>flatMap</code> above, monadic behaviour is formally captured in two operations:</p>
    <ul>
      <li><code>pure</code>, of type <code>A => F[A]</code>;</li>
      <li><code>flatMap</code><a id="loc-238" href="#loc-642" role="doc-noteref"><sup>66</sup></a>, of type <code>(F[A], A => F[B]) => F[B]</code>.</li>
    </ul>
    <p><code>pure</code> abstracts over constructors, providing a way to create a new monadic context from a plain value. <code>flatMap</code> provides the sequencing step we have already discussed, extracting the value from a context and generating the next context in the sequence.</p>
    <p>We can represent this as a type class. Here is a simplified version of the <code>Monad</code> type class in Cats:</p>
    <pre><code data-lang="scala"><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Monad</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](value: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br>}</code></pre>
    <div>
      <h5>Monad Laws</h5>
      <p><code>pure</code> and <code>flatMap</code> must obey a set of laws that allow us to sequence operations freely without unintended glitches and side-effects:</p>
      <p><strong>Left identity</strong>: calling <code>pure</code> and transforming the result with <code>func</code> is the same as calling <code>func</code>:</p>
      <pre><code data-lang="scala">pure(a).flatMap(func) <span style="color: #d73948">==</span> func(a)</code></pre>
      <p><strong>Right identity</strong>: passing <code>pure</code> to <code>flatMap</code> is the same as doing nothing:</p>
      <pre><code data-lang="scala">m.flatMap(pure) <span style="color: #d73948">==</span> m</code></pre>
      <p><strong>Associativity</strong>: <code>flatMapping</code> over two functions <code>f</code> and <code>g</code> is the same as <code>flatMapping</code> over <code>f</code> and then <code>flatMapping</code> over <code>g</code>:</p>
      <pre><code data-lang="scala">m.flatMap(f).flatMap(g) <span style="color: #d73948">==</span> m.flatMap(x <span style="color: #d73948">=></span> f(x).flatMap(g))</code></pre>
    </div>
    <h4 id="loc-239">10.1.5. Exercise: Getting Func-y</h4>
    <p>Every monad is also a functor. For every monad we can define <code>map</code> in the same way using the existing methods, <code>flatMap</code> and <code>pure</code>:</p>
    <pre><code data-lang="scala"><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Monad</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](a: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](value: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](value: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>Try defining <code>map</code> yourself now.</p>
    <h3 id="loc-240">10.2. Monads in Cats</h3>
    <p>It’s time to give monads our standard Cats treatment. As usual we’ll look at the type class, instances, and syntax.</p>
    <h4 id="monad-type-class">10.2.1. The Monad Type Class</h4>
    <p>The monad type class is <a href="http://typelevel.org/cats/api/cats/Monad.html"><code>cats.Monad</code><a id="loc-241" href="#loc-643" role="doc-noteref"><sup>67</sup></a></a>. <code>Monad</code> extends two other type classes: <code>FlatMap</code>, which provides the <code>flatMap</code> method, and <code>Applicative</code>, which provides <code>pure</code>. <code>Applicative</code> also extends <code>Functor</code>, which gives every <code>Monad</code> a <code>map</code> method as we saw in the exercise above. We’ll discuss <code>Applicatives</code> in <a href="#loc-295">Chapter 12</a>.</p>
    <p>Here are some examples using <code>pure</code> and <code>flatMap</code>, and <code>map</code> directly:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monad</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> opt1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Option</span>].pure(<span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> opt1: Option[Int] = Some(value = 3)</span><br><span style="color: #d73948">val</span> opt2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Option</span>].flatMap(opt1)(a <span style="color: #d73948">=></span> <span style="color: #4b69c6">Some</span>(a + <span style="color: #b60157">2</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> opt2: Option[Int] = Some(value = 5)</span><br><span style="color: #d73948">val</span> opt3 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Option</span>].map(opt2)(a <span style="color: #d73948">=></span> <span style="color: #b60157">100</span> * a)<br><span style="color: #74747c">//</span><span style="color: #74747c"> opt3: Option[Int] = Some(value = 500)</span><br><br><span style="color: #d73948">val</span> list1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">List</span>].pure(<span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> list1: List[Int] = List(3)</span><br><span style="color: #d73948">val</span> list2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">List</span>].<br>  flatMap(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))(a <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>(a, a*<span style="color: #b60157">10</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> list2: List[Int] = List(1, 10, 2, 20, 3, 30)</span><br><span style="color: #d73948">val</span> list3 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">List</span>].map(list2)(a <span style="color: #d73948">=></span> a + <span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> list3: List[Int] = List(124, 133, 125, 143, 126, 153)</span></code></pre>
    <p><code>Monad</code> provides many other methods, including all of the methods from <code>Functor</code>. See the <a href="http://typelevel.org/cats/api/cats/Monad.html">documentation<a id="loc-242" href="#loc-644" role="doc-noteref"><sup>68</sup></a></a> for more information.</p>
    <h4 id="loc-243">10.2.2. Default Instances</h4>
    <p>Cats provides instances for all the monads in the standard library (<code>Option</code>, <code>List</code>, <code>Vector</code> and so on). Cats also provides a <code>Monad</code> for <code>Future</code>. Unlike the methods on the <code>Future</code> class itself, the <code>pure</code> and <code>flatMap</code> methods on the monad can’t accept <code>ExecutionContext</code> parameters (because the parameters aren’t part of the definitions in the <code>Monad</code> trait). To work around this, Cats requires us to have an <code>ExecutionContext</code> in scope when we summon a <code>Monad</code> for <code>Future</code>.</p>
    <p>Let’s import <code>Future</code> (and some other imports we will use later.)</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.*<br><span style="color: #d73948">import</span> scala.concurrent.duration.*</code></pre>
    <p>We see that compilation fails without an <code>ExecutionContext</code> available.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> fm <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Future</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type cats.Monad[scala.concurrent.Future] was found for parameter instance of method apply in object Monad.</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> I found:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> </span><br><span style="color: #74747c">//</span><span style="color: #74747c">     cats.Invariant.catsInstancesForFuture(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       /* missing */summon[scala.concurrent.ExecutionContext])</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> But no implicit values were found that match type scala.concurrent.ExecutionContext.</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> val fm = Monad[Future]</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                      ^</span></code></pre>
    <p>Now we bring the <code>ExecutionContext</code> into scope.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global</code></pre>
    <p>This provides the given instance required to summon the <code>Monad[Future]</code> instance:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> fm <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Future</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> fm: Monad[[T >: Nothing &lt;: Any] =>> Future[T]] = cats.instances.FutureInstances$$anon$1@12605a78</span></code></pre>
    <p>The <code>Monad</code> instance uses the captured <code>ExecutionContext</code> for subsequent calls to <code>pure</code> and <code>flatMap</code>. We can construct a <code>Future</code> using calls to the monad instance we summoned above.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> future <span style="color: #d73948">=</span> fm.flatMap(fm.pure(<span style="color: #b60157">1</span>))(x <span style="color: #d73948">=></span> fm.pure(x + <span style="color: #b60157">2</span>))</code></pre>
    <p>If we await the result of the <code>Future</code> we get the expected result.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(future, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Int = 3</span></code></pre>
    <p>In addition to the above, Cats provides a host of new monads that we don’t have in the standard library. We’ll familiarise ourselves with some of these in a moment.</p>
    <h4 id="loc-244">10.2.3. Monad Syntax</h4>
    <p>The syntax for monads comes from three places:</p>
    <ul>
      <li><a href="http://typelevel.org/cats/api/cats/syntax/package$$flatMap$"><code>cats.syntax.flatMap</code><a id="loc-245" href="#loc-645" role="doc-noteref"><sup>69</sup></a></a> provides syntax for <code>flatMap</code>;</li>
      <li><a href="http://typelevel.org/cats/api/cats/syntax/package$$functor$"><code>cats.syntax.functor</code><a id="loc-246" href="#loc-646" role="doc-noteref"><sup>70</sup></a></a> provides syntax for <code>map</code>;</li>
      <li><a href="http://typelevel.org/cats/api/cats/syntax/package$$applicative$"><code>cats.syntax.applicative</code><a id="loc-247" href="#loc-647" role="doc-noteref"><sup>71</sup></a></a> provides syntax for <code>pure</code>.</li>
    </ul>
    <p>In practice it’s often easier to import everything in one go from <code>cats.syntax.all.*</code>. However, we’ll use the individual imports here for clarity.</p>
    <p>We can use <code>pure</code> to construct instances of a monad. We’ll often need to specify the type parameter to disambiguate the particular instance we want.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.applicative.* <span style="color: #74747c">//</span><span style="color: #74747c"> for pure</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #b60157">1</span>.pure[<span style="color: #4b69c6">Option</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Option[Int] = Some(value = 1)</span><br><span style="color: #b60157">1</span>.pure[<span style="color: #4b69c6">List</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: List[Int] = List(1)</span></code></pre>
    <p>It’s difficult to demonstrate the <code>flatMap</code> and <code>map</code> methods directly on Scala monads like <code>Option</code> and <code>List</code>, because they define their own explicit versions of those methods. Instead we’ll write a generic function that performs a calculation on parameters that come wrapped in a monad of the user’s choice:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monad<br><span style="color: #d73948">import</span> cats.syntax.functor.* <span style="color: #74747c">//</span><span style="color: #74747c"> for map</span><br><span style="color: #d73948">import</span> cats.syntax.flatMap.* <span style="color: #74747c">//</span><span style="color: #74747c"> for flatMap</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">sumSquare</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>](a: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>], b: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  a.flatMap(x <span style="color: #d73948">=></span> b.map(y <span style="color: #d73948">=></span> x*x + y*y))</code></pre>
    <pre><code data-lang="scala">sumSquare(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">3</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">4</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Option[Int] = Some(value = 25)</span><br>sumSquare(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>), <span style="color: #4b69c6">List</span>(<span style="color: #b60157">4</span>, <span style="color: #b60157">5</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: List[Int] = List(17, 26, 20, 29, 25, 34)</span></code></pre>
    <p>We can rewrite this code using for comprehensions. The compiler will “do the right thing” by rewriting our comprehension in terms of <code>flatMap</code> and <code>map</code> and inserting the correct conversions to use our <code>Monad</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">sumSquare</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>](a: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>], b: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">for</span> {<br>    x <span style="color: #d73948">&lt;-</span> a<br>    y <span style="color: #d73948">&lt;-</span> b<br>  } <span style="color: #d73948">yield</span> x*x + y*y</code></pre>
    <pre><code data-lang="scala">sumSquare(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">3</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">4</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Option[Int] = Some(value = 25)</span><br>sumSquare(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>), <span style="color: #4b69c6">List</span>(<span style="color: #b60157">4</span>, <span style="color: #b60157">5</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: List[Int] = List(17, 26, 20, 29, 25, 34)</span></code></pre>
    <p>That’s more or less everything we need to know about the generalities of monads in Cats. Now let’s take a look at some useful monad instances that we haven’t seen in the Scala standard library.</p>
    <h3 id="loc-248">10.3. The Identity Monad</h3>
    <p>In the previous section we demonstrated Cats’ <code>flatMap</code> and <code>map</code> syntax by writing a method that abstracted over different monads:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monad<br><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">sumSquare</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>](a: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>], b: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">for</span> {<br>    x <span style="color: #d73948">&lt;-</span> a<br>    y <span style="color: #d73948">&lt;-</span> b<br>  } <span style="color: #d73948">yield</span> x*x + y*y</code></pre>
    <p>This method works well on <code>Options</code> and <code>Lists</code> but we can’t call it passing in plain values:</p>
    <pre><code data-lang="scala">sumSquare(<span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    (3 : Int)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: ([_] =>> Any)[Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Note that implicit conversions were not tried because the result of an implicit conversion</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> must be more specific than ([_] =>> Any)[Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> sumSquare(3, 4)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">           ^</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    (4 : Int)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: ([_] =>> Any)[Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Note that implicit conversions were not tried because the result of an implicit conversion</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> must be more specific than ([_] =>> Any)[Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> sumSquare(3, 4)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">              ^</span></code></pre>
    <p>It would be incredibly useful if we could use <code>sumSquare</code> with parameters that were either in a monad or not in a monad at all. This would allow us to abstract over monadic and non-monadic code. Fortunately, Cats provides the <code>Id</code> type to bridge the gap:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Id</code></pre>
    <pre><code data-lang="scala">sumSquare(<span style="color: #b60157">3</span> : <span style="color: #4b69c6">Id</span>[<span style="color: #d73948">Int</span>], <span style="color: #b60157">4</span> : <span style="color: #4b69c6">Id</span>[<span style="color: #d73948">Int</span>])<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Int = 25</span></code></pre>
    <p><code>Id</code> allows us to call our monadic method using plain values. However, the exact semantics are difficult to understand. We cast the parameters to <code>sumSquare</code> as <code>Id[Int]</code> and received an <code>Id[Int]</code> back as a result!</p>
    <p>What’s going on? Here is the definition of <code>Id</code> to explain:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Id</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span></code></pre>
    <p><code>Id</code> is actually a type alias that turns an atomic type into a single-parameter type constructor. We can cast any value of any type to a corresponding <code>Id</code>:</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">Dave</span><span style="color: #198810">"</span> : <span style="color: #4b69c6">Id</span>[<span style="color: #4b69c6">String</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "Dave"</span><br><span style="color: #b60157">123</span> : <span style="color: #4b69c6">Id</span>[<span style="color: #d73948">Int</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Int = 123</span><br><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>) : <span style="color: #4b69c6">Id</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: List[Int] = List(1, 2, 3)</span></code></pre>
    <p>Cats provides instances of various type classes for <code>Id</code>, including <code>Functor</code> and <code>Monad</code>. These let us call <code>map</code>, <code>flatMap</code>, and <code>pure</code> on plain values:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Id</span>].pure(<span style="color: #b60157">3</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> a: Int = 3</span><br><span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Id</span>].flatMap(a)(<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> b: Int = 4</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.functor.* <span style="color: #74747c">//</span><span style="color: #74747c"> for map</span><br><span style="color: #d73948">import</span> cats.syntax.flatMap.* <span style="color: #74747c">//</span><span style="color: #74747c"> for flatMap</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">for</span> {<br>  x <span style="color: #d73948">&lt;-</span> a<br>  y <span style="color: #d73948">&lt;-</span> b<br>} <span style="color: #d73948">yield</span> x + y<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Int = 7</span></code></pre>
    <p>The ability to abstract over monadic and non-monadic code is extremely powerful. For example, we can run code asynchronously in production using <code>Future</code> and synchronously in test using <code>Id</code>. We’ll see this in our first case study in <a href="#loc-414">Chapter 18</a>.</p>
    <h4 id="loc-249">10.3.1. Exercise: Monadic Secret Identities</h4>
    <p>Implement <code>pure</code>, <code>map</code>, and <code>flatMap</code> for <code>Id</code>! What interesting discoveries do you uncover about the implementation?</p>
    <p>The <code>Id</code> monad does find occasional use in highly generic code, but I think it is more useful as a tool for understanding monads in general. Remember we said a monad is a tool for sequencing computations. When we write</p>
    <pre><code data-lang="scala">a.flatMap(b)</code></pre>
    <p>we are saying that <code>b</code> occurs after <code>a</code>, subject to whatever complications the concrete monad and <code>a</code> might introduce. In other words, monads express control flow. Our programming languages already have built-in ways of expressing control flow. In Scala, like most languages, control flow goes top-to-bottom and left-to-right. We can think of this as an “ambient” monad, a monad that conceptually exists but we don’t work with directly. When we write</p>
    <pre><code data-lang="scala"><span style="color: #b60157">1</span> + <span style="color: #b60157">2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Int = 3</span></code></pre>
    <p>we can instead express it in monadic terms as</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Id</span>(<span style="color: #b60157">1</span>).flatMap(<span style="color: #d73948">_</span> + <span style="color: #b60157">2</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Int = 3</span></code></pre>
    <p>This shows us that monads are reifying control flow, making it explicit. This in turn puts the control flow under the control of the monad, which allows, for example, the error handling behaviour we saw with <code>Option</code>.</p>
    <h3 id="loc-250">10.4. Either</h3>
    <p>Let’s look at another useful monad: the <code>Either</code> type from the Scala standard library. <code>Either</code> has two cases, <code>Left</code> and <code>Right</code>. By convention <code>Right</code> represents a success case, and <code>Left</code> a failure. When we call <code>flatMap</code> on <code>Either</code>, computation continues if we have a <code>Right</code> case.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Right</span>(<span style="color: #b60157">10</span>).flatMap(a <span style="color: #d73948">=></span> <span style="color: #4b69c6">Right</span>(a + <span style="color: #b60157">32</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Either[Nothing, Int] = Right(value = 42)</span></code></pre>
    <p>A <code>Left</code>, however, stops the computation.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Right</span>(<span style="color: #b60157">10</span>).flatMap(a <span style="color: #d73948">=></span> <span style="color: #4b69c6">Left</span>(<span style="color: #198810">"</span><span style="color: #198810">Oh no!</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Either[String, Nothing] = Left(value = "Oh no!")</span></code></pre>
    <p>AS these examples suggest, <code>Either</code> is typically used to implement fail-fast error handling. We sequence computations using <code>flatMap</code> as usual. If one computation fails, the remaining computations are not run. Here’s an example where we fail if we attempt to divide by zero.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Right</span>(<span style="color: #b60157">1</span>)<br>  b <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Right</span>(<span style="color: #b60157">0</span>)<br>  c <span style="color: #d73948">&lt;-</span> <span style="color: #d73948">if</span>(b <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">Left</span>(<span style="color: #198810">"</span><span style="color: #198810">DIV0</span><span style="color: #198810">"</span>)<br>       <span style="color: #d73948">else</span> <span style="color: #4b69c6">Right</span>(a / b)<br>} <span style="color: #d73948">yield</span> c * <span style="color: #b60157">100</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Either[String, Int] = Left(value = "DIV0")</span></code></pre>
    <p>We can see <code>Either</code> as similar to <code>Option</code>, but it allows us to record some information in the case of failure, whereas <code>Option</code> represents failure by <code>None</code>. In the examples above we used strings to hold information about the cause of failure, but we can use any type we like. For example, we could use <code>Throwable</code> instead:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Result</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">Throwable</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>This gives us similar semantics to <code>scala.util.Try</code>. The problem, however, is that <code>Throwable</code> is an extremely broad type. We have (almost) no idea about what type of error occurred.</p>
    <p>Another approach is to define an algebraic data type to represent errors that may occur in our program:</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">LoginError</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">UserNotFound</span>(username: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">PasswordIncorrect</span>(username: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">UnexpectedError</span> <br>}</code></pre>
    <p>We could use the <code>LoginError</code> type along with <code>Either</code> as shown below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> User</span>(username: <span style="color: #4b69c6">String</span>, password: <span style="color: #4b69c6">String</span>)<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">LoginResult</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">LoginError</span>, <span style="color: #4b69c6">User</span>]</code></pre>
    <p>This approach solves the problems we saw with <code>Throwable</code>. It gives us a fixed set of expected error types and a catch-all for anything else that we didn’t expect. We also get the safety of exhaustivity checking on any pattern matching we do:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> LoginError.*<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Choose error-handling behaviour based on type:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">handleError</span>(error: <span style="color: #4b69c6">LoginError</span>): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  error <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">UserNotFound</span>(u) <span style="color: #d73948">=></span><br>      println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">User not found: </span>$u<span style="color: #198810">"</span>)<br><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">PasswordIncorrect</span>(u) <span style="color: #d73948">=></span><br>      println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Password incorrect: </span>$u<span style="color: #198810">"</span>)<br><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">UnexpectedError</span> <span style="color: #d73948">=></span><br>      println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Unexpected error</span><span style="color: #198810">"</span>)<br>  }</code></pre>
    <p>Here’s an example of use.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> result1: <span style="color: #4b69c6">LoginResult</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Right</span>(<span style="color: #4b69c6">User</span>(<span style="color: #198810">"</span><span style="color: #198810">dave</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">passw0rd</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> result1: Either[LoginError, User] = Right(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = User(username = "dave", password = "passw0rd")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><span style="color: #d73948">val</span> result2: <span style="color: #4b69c6">LoginResult</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">UserNotFound</span>(<span style="color: #198810">"</span><span style="color: #198810">dave</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> result2: Either[LoginError, User] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = UserNotFound(username = "dave")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br>result1.fold(handleError, println)<br><span style="color: #74747c">//</span><span style="color: #74747c"> User(dave,passw0rd)</span><br>result2.fold(handleError, println)<br><span style="color: #74747c">//</span><span style="color: #74747c"> User not found: dave</span></code></pre>
    <p>We have much more to say about error handling in <a href="#loc-418">Chapter 19</a>.</p>
    <h4 id="loc-251">10.4.1. Cats Utilities</h4>
    <p>Cats provides several utilities for working with <code>Either</code>. Here we go over the most useful of them.</p>
    <h5>10.4.1.1. Creating Instances</h5>
    <p>In addition to creating instances of <code>Left</code> and <code>Right</code> directly, we can also use the <code>asLeft</code> and <code>asRight</code> extension methods from Cats. For these methods we need to import the Cats syntax:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.* </code></pre>
    <p>Now we can construct instances using the extensions.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> <span style="color: #b60157">3</span>.asRight[<span style="color: #4b69c6">String</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> a: Either[String, Int] = Right(value = 3)</span><br><span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> <span style="color: #b60157">4</span>.asRight[<span style="color: #4b69c6">String</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> b: Either[String, Int] = Right(value = 4)</span><br><br><span style="color: #d73948">for</span> {<br>  x <span style="color: #d73948">&lt;-</span> a<br>  y <span style="color: #d73948">&lt;-</span> b<br>} <span style="color: #d73948">yield</span> x*x + y*y<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Either[String, Int] = Right(value = 25)</span></code></pre>
    <p>These “smart constructors” have advantages over <code>Left.apply</code> and <code>Right.apply</code>. They return results of type <code>Either</code> instead of <code>Left</code> and <code>Right</code>. This helps avoid type inference problems caused by over-narrowing, like the issue in the example below:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">countPositive</span>(nums: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]) <span style="color: #d73948">=</span><br>  nums.foldLeft(<span style="color: #4b69c6">Right</span>(<span style="color: #b60157">0</span>)) { (accumulator, num) <span style="color: #d73948">=</span>><br>    <span style="color: #d73948">if</span>(num > <span style="color: #b60157">0</span>) {<br>      accumulator.map(<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>)<br>    } <span style="color: #d73948">else</span> {<br>      <span style="color: #4b69c6">Left</span>(<span style="color: #198810">"</span><span style="color: #198810">Negative. Stopping!</span><span style="color: #198810">"</span>)<br>    }<br>  }<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    Either[Nothing, Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: Right[Nothing, Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       accumulator.map(_ + 1)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       ^^^^^^^^^^^^^^^^^^^^^^</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    Left[String, Any]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: Right[Nothing, Int]</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       Left("Negative. Stopping!")</span><br><span style="color: #74747c">//</span><span style="color: #74747c">       ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
    <p>This code fails to compile for two reasons:</p>
    <ol>
      <li>the compiler infers the type of the accumulator as <code>Right</code> instead of <code>Either</code>;</li>
      <li>we didn’t specify type parameters for <code>Right.apply</code> so the compiler infers the left parameter as <code>Nothing</code>.</li>
    </ol>
    <p>Switching to <code>asRight</code> avoids both of these problems. <code>asRight</code> has a return type of <code>Either</code>, and allows us to completely specify the type with only one type parameter:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">countPositive</span>(nums: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]) <span style="color: #d73948">=</span><br>  nums.foldLeft(<span style="color: #b60157">0</span>.asRight[<span style="color: #4b69c6">String</span>]) { (accumulator, num) <span style="color: #d73948">=</span>><br>    <span style="color: #d73948">if</span>(num > <span style="color: #b60157">0</span>) {<br>      accumulator.map(<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>)<br>    } <span style="color: #d73948">else</span> {<br>      <span style="color: #4b69c6">Left</span>(<span style="color: #198810">"</span><span style="color: #198810">Negative. Stopping!</span><span style="color: #198810">"</span>)<br>    }<br>  }</code></pre>
    <pre><code data-lang="scala">countPositive(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Either[String, Int] = Right(value = 3)</span><br>countPositive(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, -<span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Either[String, Int] = Left(value = "Negative. Stopping!")</span></code></pre>
    <p>The Cats syntax also adds some useful extension methods to the <code>Either</code> companion object. The <code>catchOnly</code> and <code>catchNonFatal</code> methods are great for capturing <code>Exceptions</code> as instances of <code>Either</code>:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Either</span>.catchOnly[<span style="color: #4b69c6">NumberFormatException</span>](<span style="color: #198810">"</span><span style="color: #198810">foo</span><span style="color: #198810">"</span>.toInt)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Either[NumberFormatException, Int] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = java.lang.NumberFormatException: For input string: "foo"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><span style="color: #4b69c6">Either</span>.catchNonFatal(sys.error(<span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Either[Throwable, Nothing] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = java.lang.RuntimeException: Badness</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>There are also methods for creating an <code>Either</code> from other data types:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Either</span>.fromTry(scala.util.<span style="color: #4b69c6">Try</span>(<span style="color: #198810">"</span><span style="color: #198810">foo</span><span style="color: #198810">"</span>.toInt))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Either[Throwable, Int] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = java.lang.NumberFormatException: For input string: "foo"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><span style="color: #4b69c6">Either</span>.fromOption[<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>](<span style="color: #4b69c6">None</span>, <span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Either[String, Int] = Left(value = "Badness")</span></code></pre>
    <h5>10.4.1.2. Transforming Eithers</h5>
    <p>Cats syntax also adds some useful methods for instances of <code>Either</code>.</p>
    <p>The <code>ensure</code> method allows us to check whether the right-hand value satisfies a predicate:</p>
    <pre><code data-lang="scala">-<span style="color: #b60157">1</span>.asRight[<span style="color: #4b69c6">String</span>].ensure(<span style="color: #198810">"</span><span style="color: #198810">Must be non-negative!</span><span style="color: #198810">"</span>)(<span style="color: #d73948">_</span> > <span style="color: #b60157">0</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: Either[String, Int] = Left(value = "Must be non-negative!")</span></code></pre>
    <p>The <code>recover</code> and <code>recoverWith</code> methods provide similar error handling to their namesakes on <code>Future</code>:</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">error</span><span style="color: #198810">"</span>.asLeft[<span style="color: #d73948">Int</span>].recover {<br>  <span style="color: #d73948">case</span> <span style="color: #d73948">_</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=></span> -<span style="color: #b60157">1</span><br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: Either[String, Int] = Right(value = -1)</span><br><br><span style="color: #198810">"</span><span style="color: #198810">error</span><span style="color: #198810">"</span>.asLeft[<span style="color: #d73948">Int</span>].recoverWith {<br>  <span style="color: #d73948">case</span> <span style="color: #d73948">_</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Right</span>(-<span style="color: #b60157">1</span>)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res15: Either[String, Int] = Right(value = -1)</span></code></pre>
    <p>There are <code>leftMap</code> and <code>bimap</code> methods to complement <code>map</code>:</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">foo</span><span style="color: #198810">"</span>.asLeft[<span style="color: #d73948">Int</span>].leftMap(<span style="color: #d73948">_</span>.reverse)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res16: Either[String, Int] = Left(value = "oof")</span><br><span style="color: #b60157">6</span>.asRight[<span style="color: #4b69c6">String</span>].bimap(<span style="color: #d73948">_</span>.reverse, <span style="color: #d73948">_</span> * <span style="color: #b60157">7</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res17: Either[String, Int] = Right(value = 42)</span><br><span style="color: #198810">"</span><span style="color: #198810">bar</span><span style="color: #198810">"</span>.asLeft[<span style="color: #d73948">Int</span>].bimap(<span style="color: #d73948">_</span>.reverse, <span style="color: #d73948">_</span> * <span style="color: #b60157">7</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res18: Either[String, Int] = Left(value = "rab")</span></code></pre>
    <p>The <code>swap</code> method lets us exchange left for right:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">123</span>.asRight[<span style="color: #4b69c6">String</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res19: Either[String, Int] = Right(value = 123)</span><br><span style="color: #b60157">123</span>.asRight[<span style="color: #4b69c6">String</span>].swap<br><span style="color: #74747c">//</span><span style="color: #74747c"> res20: Either[Int, String] = Left(value = 123)</span></code></pre>
    <p>Finally, Cats adds a host of conversion methods: <code>toOption</code>, <code>toList</code>, <code>toTry</code>, <code>toValidated</code>, and so on.</p>
    <h5>Exercise: What is Best?</h5>
    <p>Is the error handling strategy in the previous examples well suited for all purposes? What other features might we want from error handling?</p>
    <h3 id="loc-252">10.5. Aside: Error Handling and MonadError</h3>
    <p>Cats provides an additional type class called <code>MonadError</code> that abstracts over <code>Either</code>-like data types that are used for error handling. <code>MonadError</code> provides extra operations for raising and handling errors.</p>
    <div>
      <h5>this Section is Optional!</h5>
      <p>You won’t need to use <code>MonadError</code> unless you need to abstract over error handling monads. For example, you can use <code>MonadError</code> to abstract over <code>Future</code> and <code>Try</code>, or over <code>Either</code> and <code>EitherT</code> (which we will meet in <a href="#loc-279">Chapter 11</a>).</p>
      <p>If you don’t need this kind of abstraction right now, feel free to skip onwards to <a href="#loc-261">Section 10.6</a>.</p>
    </div>
    <h4 id="loc-253">10.5.1. The MonadError Type Class</h4>
    <p>Here is a simplified version of the definition of <code>MonadError</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> MonadError</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>], <span style="color: #4b69c6">E</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Monad</span>[<span style="color: #4b69c6">F</span>] {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Lift an error into the `F` context:</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">raiseError</span>[<span style="color: #4b69c6">A</span>](e: <span style="color: #4b69c6">E</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Handle an error, potentially recovering from it:</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">handleErrorWith</span>[<span style="color: #4b69c6">A</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(f: <span style="color: #4b69c6">E</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br>  <br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Handle all errors, recovering from them:</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">handleError</span>[<span style="color: #4b69c6">A</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(f: <span style="color: #4b69c6">E</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Test an instance of `F`,</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> failing if the predicate is not satisfied:</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">ensure</span>[<span style="color: #4b69c6">A</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(e: <span style="color: #4b69c6">E</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #d73948">Boolean</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p><code>MonadError</code> is defined in terms of two type parameters:</p>
    <ul>
      <li><code>F</code> is the type of the monad;</li>
      <li><code>E</code> is the type of error contained within <code>F</code>.</li>
    </ul>
    <p>To demonstrate how these parameters fit together, here’s an example where we instantiate the type class for <code>Either</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.MonadError<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">val</span> monadError <span style="color: #d73948">=</span> <span style="color: #4b69c6">MonadError</span>[<span style="color: #4b69c6">ErrorOr</span>, <span style="color: #4b69c6">String</span>]</code></pre>
    <div>
      <p><strong>ApplicativeError</strong></p>
      <p>In reality, <code>MonadError</code> extends another type class called <code>ApplicativeError</code>. However, we won’t encounter <code>Applicatives</code> until <a href="#loc-295">Chapter 12</a>. The semantics are the same for each type class so we can ignore this detail for now.</p>
    </div>
    <h4 id="loc-254">10.5.2. Raising and Handling Errors</h4>
    <p>The two most important methods of <code>MonadError</code> are <code>raiseError</code> and <code>handleErrorWith</code>. <code>raiseError</code> is like the <code>pure</code> method for <code>Monad</code> except that it creates an instance representing a failure:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> success <span style="color: #d73948">=</span> monadError.pure(<span style="color: #b60157">42</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> success: Either[String, Int] = Right(value = 42)</span><br><span style="color: #d73948">val</span> failure <span style="color: #d73948">=</span> monadError.raiseError(<span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> failure: Either[String, Nothing] = Left(value = "Badness")</span></code></pre>
    <p><code>handleErrorWith</code> is the complement of <code>raiseError</code>. It allows us to consume an error and (possibly) turn it into a success, similar to the <code>recover</code> method of <code>Future</code>:</p>
    <pre><code data-lang="scala">monadError.handleErrorWith(failure) {<br>  <span style="color: #d73948">case</span> <span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span> <span style="color: #d73948">=></span><br>    monadError.pure(<span style="color: #198810">"</span><span style="color: #198810">It's ok</span><span style="color: #198810">"</span>)<br><br>  <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span><br>    monadError.raiseError(<span style="color: #198810">"</span><span style="color: #198810">It's not ok</span><span style="color: #198810">"</span>)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Either[String, String] = Right(value = "It's ok")</span></code></pre>
    <p>If we know we can handle all possible errors we can use <code>handleWith</code>.</p>
    <pre><code data-lang="scala">monadError.handleError(failure) {<br>  <span style="color: #d73948">case</span> <span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span> <span style="color: #d73948">=></span> <span style="color: #b60157">42</span><br><br>  <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> -<span style="color: #b60157">1</span><br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Either[String, Int] = Right(value = 42)</span></code></pre>
    <p>There is another useful method called <code>ensure</code> that implements <code>filter</code>-like behaviour. We test the value of a successful monad with a predicate and specify an error to raise if the predicate returns <code>false</code>:</p>
    <pre><code data-lang="scala">monadError.ensure(success)(<span style="color: #198810">"</span><span style="color: #198810">Number too low!</span><span style="color: #198810">"</span>)(<span style="color: #d73948">_</span> > <span style="color: #b60157">1000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Either[String, Int] = Left(value = "Number too low!")</span></code></pre>
    <p>Cats provides syntax for <code>raiseError</code> and <code>handleErrorWith</code> via <a href="http://typelevel.org/cats/api/cats/syntax/package$$applicativeError$"><code>cats.syntax.applicativeError</code><a id="loc-255" href="#loc-648" role="doc-noteref"><sup>72</sup></a></a> and <code>ensure</code> via <a href="http://typelevel.org/cats/api/cats/syntax/package$$monadError$"><code>cats.syntax.monadError</code><a id="loc-256" href="#loc-649" role="doc-noteref"><sup>73</sup></a></a>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.applicative.*      <span style="color: #74747c">//</span><span style="color: #74747c"> for pure</span><br><span style="color: #d73948">import</span> cats.syntax.applicativeError.* <span style="color: #74747c">//</span><span style="color: #74747c"> for raiseError etc</span><br><span style="color: #d73948">import</span> cats.syntax.monadError.*       <span style="color: #74747c">//</span><span style="color: #74747c"> for ensure</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> success <span style="color: #d73948">=</span> <span style="color: #b60157">42</span>.pure[<span style="color: #4b69c6">ErrorOr</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> success: Either[String, Int] = Right(value = 42)</span><br><span style="color: #d73948">val</span> failure <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span>.raiseError[<span style="color: #4b69c6">ErrorOr</span>, <span style="color: #d73948">Int</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> failure: Either[String, Int] = Left(value = "Badness")</span><br>failure.handleErrorWith{<br>  <span style="color: #d73948">case</span> <span style="color: #198810">"</span><span style="color: #198810">Badness</span><span style="color: #198810">"</span> <span style="color: #d73948">=></span><br>    <span style="color: #b60157">256</span>.pure<br><br>  <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span><br>    (<span style="color: #198810">"</span><span style="color: #198810">It's not ok</span><span style="color: #198810">"</span>).raiseError<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Either[String, Int] = Right(value = 256)</span><br>success.ensure(<span style="color: #198810">"</span><span style="color: #198810">Number to low!</span><span style="color: #198810">"</span>)(<span style="color: #d73948">_</span> > <span style="color: #b60157">1000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Either[String, Int] = Left(value = "Number to low!")</span></code></pre>
    <p>There are other useful variants of these methods. See the source of <a href="http://typelevel.org/cats/api/cats/MonadError.html"><code>cats.MonadError</code><a id="loc-257" href="#loc-650" role="doc-noteref"><sup>74</sup></a></a> and <a href="http://typelevel.org/cats/api/cats/ApplicativeError.html"><code>cats.ApplicativeError</code><a id="loc-258" href="#loc-651" role="doc-noteref"><sup>75</sup></a></a> for more information.</p>
    <h4 id="loc-259">10.5.3. Instances of MonadError</h4>
    <p>Cats provides instances of <code>MonadError</code> for numerous data types including <code>Either</code>, <code>Future</code>, and <code>Try</code>. The instance for <code>Either</code> is customisable to any error type, whereas the instances for <code>Future</code> and <code>Try</code> always represent errors as <code>Throwables</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.util.Try<br><br><span style="color: #d73948">val</span> exn: <span style="color: #4b69c6">Throwable</span> =<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">RuntimeException</span>(<span style="color: #198810">"</span><span style="color: #198810">It's all gone wrong</span><span style="color: #198810">"</span>)</code></pre>
    <pre><code data-lang="scala">exn.raiseError[<span style="color: #4b69c6">Try</span>, <span style="color: #d73948">Int</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Try[Int] = Failure(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   exception = java.lang.RuntimeException: It's all gone wrong</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <h4 id="loc-260">10.5.4. Exercise: Abstracting</h4>
    <p>Implement a method <code>validateAdult</code> with the following signature</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">validateAdult</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]](age: <span style="color: #d73948">Int</span>)(<span style="color: #d73948">implicit</span> me: <span style="color: #4b69c6">MonadError</span>[<span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">Throwable</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>When passed an <code>age</code> greater than or equal to 18 it should return that value as a success. Otherwise it should return a error represented as an <code>IllegalArgumentException</code>.</p>
    <p>Here are some examples of use.</p>
    <pre><code data-lang="scala">validateAdult[<span style="color: #4b69c6">Try</span>](<span style="color: #b60157">18</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Try[Int] = Success(value = 18)</span><br>validateAdult[<span style="color: #4b69c6">Try</span>](<span style="color: #b60157">8</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Try[Int] = Failure(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   exception = java.lang.IllegalArgumentException: Age must be greater than or equal to 18</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ExceptionOr</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">Throwable</span>, <span style="color: #4b69c6">A</span>]<br>validateAdult[<span style="color: #4b69c6">ExceptionOr</span>](-<span style="color: #b60157">1</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Either[Throwable, Int] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = java.lang.IllegalArgumentException: Age must be greater than or equal to 18</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <h3 id="loc-261">10.6. The Eval Monad</h3>
    <p><code>cats.Eval</code> is a monad that allows us to abstract over different <strong>models of evaluation</strong>. We first met this concept, also known as evaluation strategies, in <a href="#loc-81">Section 4.3</a>. We typically talk of two such models: <strong>eager</strong> and <strong>lazy</strong>, also called <strong>call-by-value</strong> and <strong>call-by-name</strong> respectively. <code>Eval</code> also allows for a result to be <strong>memoized</strong>, which gives us <strong>call-by-need</strong> evaluation.</p>
    <p><code>Eval</code> is also <strong>stack-safe</strong>, which means we can use it in very deep recursions without blowing up the stack.</p>
    <h4 id="loc-262">10.6.1. Eager, Lazy, Memoized, Oh My!</h4>
    <p>What do these terms for models of evaluation mean? Let’s see some examples.</p>
    <p>Let’s first look at Scala <code>vals</code>. We can see the evaluation model using a computation with a visible side-effect. In the following example, the code to compute the value of <code>x</code> happens at the place where it is defined rather than on access. Accessing <code>x</code> recalls the stored value without re-running the code.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> x <span style="color: #d73948">=</span> {<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Computing X</span><span style="color: #198810">"</span>)<br>  math.random()<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing X</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> x: Double = 0.02025530372517137</span><br><br>x <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Double = 0.02025530372517137</span><br>x <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Double = 0.02025530372517137</span></code></pre>
    <p>This is an example of call-by-value evaluation:</p>
    <ul>
      <li>the computation is evaluated at the point where it is defined (eager); and</li>
      <li>the computation is evaluated once (memoized).</li>
    </ul>
    <p>Let’s look at an example using a <code>def</code>. The code to compute <code>y</code> below is not run until we use it, and is re-run on every access:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">y</span> <span style="color: #d73948">=</span> {<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Computing Y</span><span style="color: #198810">"</span>)<br>  math.random()<br>}<br><br>y <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing Y</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Double = 0.3839499108458747</span><br>y <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing Y</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Double = 0.14648596097427546</span></code></pre>
    <p>These are the properties of call-by-name evaluation:</p>
    <ul>
      <li>the computation is evaluated at the point of use (lazy); and</li>
      <li>the computation is evaluated each time it is used (not memoized).</li>
    </ul>
    <p>Last but not least, <code>lazy vals</code> are an example of call-by-need evaluation. The code to compute <code>z</code> below is not run until we use it for the first time (lazy). The result is then cached and re-used on subsequent accesses (memoized):</p>
    <pre><code data-lang="scala"><span style="color: #d73948">lazy</span> <span style="color: #d73948">val</span> z <span style="color: #d73948">=</span> {<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Computing Z</span><span style="color: #198810">"</span>)<br>  math.random()<br>}<br><br>z <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing Z</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Double = 0.6932701609648517</span><br>z <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Double = 0.6932701609648517</span></code></pre>
    <p>Let’s summarize. There are two properties of interest:</p>
    <ul>
      <li>evaluation at the point of definition (eager) versus at the point of use (lazy); and</li>
      <li>values are saved once evaluated (memoized) or not (not memoized).</li>
    </ul>
    <p>There are three possible combinations of these properties:</p>
    <ul>
      <li>call-by-value which is eager and memoized;</li>
      <li>call-by-name which is lazy and not memoized; and</li>
      <li>call-by-need which is lazy and memoized.</li>
    </ul>
    <p>The final combination, eager and not memoized, is not possible.</p>
    <h4 id="loc-263">10.6.2. Eval’s Models of Evaluation</h4>
    <p>fs <code>Eval</code> has three subtypes: <code>Now</code>, <code>Always</code>, and <code>Later</code>. They correspond to call-by-value, call-by-name, and call-by-need respectively. We construct these with three constructor methods, which create instances of the three classes and return them typed as <code>Eval</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Eval</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> now <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span>.now(math.random() + <span style="color: #b60157">1000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> now: Eval[Double] = Now(value = 1000.8502619706862)</span><br><span style="color: #d73948">val</span> always <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span>.always(math.random() + <span style="color: #b60157">3000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> always: Eval[Double] = cats.Always@3eb73079</span><br><span style="color: #d73948">val</span> later <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span>.later(math.random() + <span style="color: #b60157">2000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> later: Eval[Double] = cats.Later@666d2795</span></code></pre>
    <p>We can extract the result of an <code>Eval</code> using its <code>value</code> method:</p>
    <pre><code data-lang="scala">now.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Double = 1000.8502619706862</span><br>always.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Double = 3000.9145362891763</span><br>later.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Double = 2000.301512736889</span></code></pre>
    <p>Each type of <code>Eval</code> calculates its result using one of the evaluation models defined above. <code>Eval.now</code> captures a value <em>right now</em>. Its semantics are similar to a <code>val</code>—eager and memoized:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> x <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span>.now{<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Computing X</span><span style="color: #198810">"</span>)<br>  math.random()<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing X</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> x: Eval[Double] = Now(value = 0.2622896292744702)</span><br><br>x.value <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Double = 0.2622896292744702</span><br>x.value <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Double = 0.2622896292744702</span></code></pre>
    <p><code>Eval.always</code> captures a lazy computation, similar to a <code>def</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> y <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span>.always{<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Computing Y</span><span style="color: #198810">"</span>)<br>  math.random()<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> y: Eval[Double] = cats.Always@38cb3076</span><br><br>y.value <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing Y</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Double = 0.8304615607731096</span><br>y.value <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing Y</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: Double = 0.0817098399725964</span></code></pre>
    <p>Finally, <code>Eval.later</code> captures a lazy, memoized computation, similar to a <code>lazy val</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> z <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span>.later{<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Computing Z</span><span style="color: #198810">"</span>)<br>  math.random()<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> z: Eval[Double] = cats.Later@3645ec9f</span><br><br>z.value <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Computing Z</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: Double = 0.3572663907338067</span><br>z.value <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res15: Double = 0.3572663907338067</span></code></pre>
    <p>The three behaviours are summarized below.</p>
    <h4 id="loc-264">10.6.3. Eval as a Monad</h4>
    <p>Like all monads, <code>Eval's</code> <code>map</code> and <code>flatMap</code> methods add computations to a chain. In this case, however, the chain is stored explicitly as a list of functions. The functions aren’t run until we call <code>Eval's</code> <code>value</code> method to request a result:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> greeting <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span><br>  .always{ println(<span style="color: #198810">"</span><span style="color: #198810">Step 1</span><span style="color: #198810">"</span>); <span style="color: #198810">"</span><span style="color: #198810">Hello</span><span style="color: #198810">"</span> }<br>  .map{ str <span style="color: #d73948">=></span> println(<span style="color: #198810">"</span><span style="color: #198810">Step 2</span><span style="color: #198810">"</span>); <span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$str<span style="color: #198810"> world</span><span style="color: #198810">"</span> }<br><span style="color: #74747c">//</span><span style="color: #74747c"> greeting: Eval[String] = cats.Eval$$anon$4@465e0b6c</span><br><br>greeting.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> Step 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Step 2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res16: String = "Hello world"</span></code></pre>
    <p>Note that, while the semantics of the originating <code>Eval</code> instances are maintained, mapping functions are always called lazily on demand (<code>def</code> semantics):</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ans <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Eval</span>.now{ println(<span style="color: #198810">"</span><span style="color: #198810">Calculating A</span><span style="color: #198810">"</span>); <span style="color: #b60157">40</span> }<br>  b <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Eval</span>.always{ println(<span style="color: #198810">"</span><span style="color: #198810">Calculating B</span><span style="color: #198810">"</span>); <span style="color: #b60157">2</span> }<br>} <span style="color: #d73948">yield</span> {<br>  println(<span style="color: #198810">"</span><span style="color: #198810">Adding A and B</span><span style="color: #198810">"</span>)<br>  a + b<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> Calculating A</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> ans: Eval[Int] = cats.Eval$$anon$4@6623727c</span><br><br>ans.value <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Calculating B</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Adding A and B</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res17: Int = 42</span><br>ans.value <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Calculating B</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Adding A and B</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res18: Int = 42</span></code></pre>
    <p><code>Eval</code> has a <code>memoize</code> method that allows us to memoize a chain of computations. The result of the chain up to the call to <code>memoize</code> is cached, whereas calculations after the call retain their original semantics:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> saying <span style="color: #d73948">=</span> <span style="color: #4b69c6">Eval</span><br>  .always{ println(<span style="color: #198810">"</span><span style="color: #198810">Step 1</span><span style="color: #198810">"</span>); <span style="color: #198810">"</span><span style="color: #198810">The cat</span><span style="color: #198810">"</span> }<br>  .map{ str <span style="color: #d73948">=></span> println(<span style="color: #198810">"</span><span style="color: #198810">Step 2</span><span style="color: #198810">"</span>); <span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$str<span style="color: #198810"> sat on</span><span style="color: #198810">"</span> }<br>  .memoize<br>  .map{ str <span style="color: #d73948">=></span> println(<span style="color: #198810">"</span><span style="color: #198810">Step 3</span><span style="color: #198810">"</span>); <span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$str<span style="color: #198810"> the mat</span><span style="color: #198810">"</span> }<br><span style="color: #74747c">//</span><span style="color: #74747c"> saying: Eval[String] = cats.Eval$$anon$4@7cbcca8a</span><br><br>saying.value <span style="color: #74747c">//</span><span style="color: #74747c"> first access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Step 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Step 2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Step 3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res19: String = "The cat sat on the mat"</span><br>saying.value <span style="color: #74747c">//</span><span style="color: #74747c"> second access</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Step 3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res20: String = "The cat sat on the mat"</span></code></pre>
    <h4 id="loc-265">10.6.4. Trampolining and <strong>Eval.defer</strong></h4>
    <p>One useful property of <code>Eval</code> is that its <code>map</code> and <code>flatMap</code> methods are <em>trampolined</em>. This means we can nest calls to <code>map</code> and <code>flatMap</code> arbitrarily without consuming stack frames. We call this property <em>“stack safety”</em>.</p>
    <p>For example, consider this function for calculating factorials:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">factorial</span>(n: <span style="color: #4b69c6">BigInt</span>): <span style="color: #4b69c6">BigInt</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span>(n <span style="color: #d73948">==</span> <span style="color: #b60157">1</span>) n <span style="color: #d73948">else</span> n * factorial(n - <span style="color: #b60157">1</span>)</code></pre>
    <p>It is relatively easy to make this method stack overflow:</p>
    <pre><code data-lang="scala">factorial(<span style="color: #b60157">50000</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> java.lang.StackOverflowError</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   ...</span></code></pre>
    <p>We can rewrite the method using <code>Eval</code> to make it stack safe:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">factorial</span>(n: <span style="color: #4b69c6">BigInt</span>): <span style="color: #4b69c6">Eval</span>[<span style="color: #4b69c6">BigInt</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span>(n <span style="color: #d73948">==</span> <span style="color: #b60157">1</span>) {<br>    <span style="color: #4b69c6">Eval</span>.now(n)<br>  } <span style="color: #d73948">else</span> {<br>    factorial(n - <span style="color: #b60157">1</span>).map(<span style="color: #d73948">_</span> * n)<br>  }</code></pre>
    <pre><code data-lang="scala">factorial(<span style="color: #b60157">50000</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> java.lang.StackOverflowError</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   ...</span></code></pre>
    <p>Oops! That didn’t work—our stack still blew up! This is because we’re still making all the recursive calls to <code>factorial</code> before we start working with <code>Eval's</code> <code>map</code> method. We can work around this using <code>Eval.defer</code>, which takes an existing instance of <code>Eval</code> and defers its evaluation. The <code>defer</code> method is trampolined like <code>map</code> and <code>flatMap</code>, so we can use it as a quick way to make an existing operation stack safe:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">factorial</span>(n: <span style="color: #4b69c6">BigInt</span>): <span style="color: #4b69c6">Eval</span>[<span style="color: #4b69c6">BigInt</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span>(n <span style="color: #d73948">==</span> <span style="color: #b60157">1</span>) {<br>    <span style="color: #4b69c6">Eval</span>.now(n)<br>  } <span style="color: #d73948">else</span> {<br>    <span style="color: #4b69c6">Eval</span>.defer(factorial(n - <span style="color: #b60157">1</span>).map(<span style="color: #d73948">_</span> * n))<br>  }</code></pre>
    <pre><code data-lang="scala">factorial(<span style="color: #b60157">50000</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res: A very big value</span></code></pre>
    <p><code>Eval</code> is a useful tool to enforce stack safety when working on very large computations and data structures. However, we must bear in mind that trampolining is not free. It avoids consuming stack by creating a chain of function objects on the heap. There are still limits on how deeply we can nest computations, but they are bounded by the size of the heap rather than the stack.</p>
    <h5>Exercise: Safer Folding using Eval</h5>
    <p>The naive implementation of <code>foldRight</code> below is not stack safe. Make it so using <code>Eval</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](as: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>], acc: <span style="color: #4b69c6">B</span>)(fn: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span><br>  as <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> head :: tail <span style="color: #d73948">=></span><br>      fn(head, foldRight(tail, acc)(fn))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Nil</span> <span style="color: #d73948">=></span><br>      acc<br>  }</code></pre>
    <h3 id="writer-monad">10.7. The Writer Monad</h3>
    <p><code>cats.data.Writer</code> is a monad that lets us carry a log along with a computation. We can use it to record messages, errors, or additional data about a computation, and extract the log alongside the final result.</p>
    <p>A common use for <code>Writer</code> is recording sequences of steps in multi-threaded computations, where standard imperative logging techniques can result in interleaved messages from different contexts. With <code>Writer</code> the log for the computation is tied to the result, so we can run concurrent computations without mixing logs.</p>
    <div>
      <h5>Cats Data Types</h5>
      <p><code>Writer</code> is the first data type we’ve seen from the <code>cats.data</code> package. This package provides instances of various type classes that produce useful semantics. Other examples from <code>cats.data</code> include the monad transformers that we will see in <a href="#loc-279">Chapter 11</a>, and the <code>Validated</code> type we will encounter in <a href="#loc-295">Chapter 12</a>.</p>
    </div>
    <h4 id="loc-266">10.7.1. Creating and Unpacking Writers</h4>
    <p>A <code>Writer[W, A]</code> carries two values: a <em>log</em> of type <code>W</code> and a <em>result</em> of type <code>A</code>. We can create a <code>Writer</code> from values of each type as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.Writer<br><br><span style="color: #4b69c6">Writer</span>(<span style="color: #4b69c6">Vector</span>(<br>  <span style="color: #198810">"</span><span style="color: #198810">It was the best of times</span><span style="color: #198810">"</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">it was the worst of times</span><span style="color: #198810">"</span><br>), <span style="color: #b60157">1859</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("It was the best of times", "it was the worst of times"), 1859)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Notice that the type reported on the console is actually <code>WriterT[Id, Vector[String], Int]</code> instead of <code>Writer[Vector[String], Int]</code> as we might expect. In the spirit of code reuse, Cats implements <code>Writer</code> in terms of another type, <code>WriterT</code>. <code>WriterT</code> is an example of a new concept called a <strong>monad transformer</strong>, which we will cover in <a href="#loc-279">Chapter 11</a>.</p>
    <p>Let’s try to ignore this detail for now. <code>Writer</code> is a type alias for <code>WriterT</code>, so we can read types like <code>WriterT[Id, W, A]</code> as <code>Writer[W, A]</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Writer</span>[<span style="color: #4b69c6">W</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">WriterT</span>[<span style="color: #4b69c6">Id</span>, <span style="color: #4b69c6">W</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>For convenience, Cats provides a way of creating <code>Writers</code> specifying only the log or the result. If we only have a result we can use the standard <code>pure</code> syntax. To do this we must have a <code>Monoid[W]</code> in scope so Cats knows how to produce an empty log. In the example below we use the <code>Monoid</code> instance for <code>Vector</code>, which Scala will find on the <code>Monoid</code> companion object.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Logged</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Writer</span>[<span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">A</span>]<br><br><span style="color: #b60157">123</span>.pure[<span style="color: #4b69c6">Logged</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: WriterT[Id, Vector[String], Int] = WriterT(run = (Vector(), 123))</span></code></pre>
    <p>If we have a log and no result we can create a <code>Writer[Unit]</code> using the <code>tell</code> syntax.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">msg1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">msg2</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">msg3</span><span style="color: #198810">"</span>).tell<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: WriterT[Id, Vector[String], Unit] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("msg1", "msg2", "msg3"), ())</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>If we have both a result and a log, we can either use <code>Writer.apply</code> or we can use the <code>writer</code> syntax.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> <span style="color: #4b69c6">Writer</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">msg1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">msg2</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">msg3</span><span style="color: #198810">"</span>), <span style="color: #b60157">123</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> a: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("msg1", "msg2", "msg3"), 123)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> <span style="color: #b60157">123</span>.writer(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">msg1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">msg2</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">msg3</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> b: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("msg1", "msg2", "msg3"), 123)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>We can extract the result and log from a <code>Writer</code> using the <code>value</code> and <code>written</code> methods respectively:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> aResult: <span style="color: #d73948">Int</span> =<br>  a.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> aResult: Int = 123</span><br><span style="color: #d73948">val</span> aLog: <span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">String</span>] =<br>  a.written<br><span style="color: #74747c">//</span><span style="color: #74747c"> aLog: Vector[String] = Vector("msg1", "msg2", "msg3")</span></code></pre>
    <p>We can extract both values at the same time using the <code>run</code> method:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> (log, result) <span style="color: #d73948">=</span> b.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> log: Vector[String] = Vector("msg1", "msg2", "msg3")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> result: Int = 123</span></code></pre>
    <h4 id="loc-267">10.7.2. Composing and Transforming Writers</h4>
    <p>The log in a <code>Writer</code> is preserved when we <code>map</code> or <code>flatMap</code> over it. <code>flatMap</code> appends the logs from the source <code>Writer</code> and the result of the user’s sequencing function. For this reason it’s good practice to use a log type that has an efficient append and concatenate operations, such as a <code>Vector</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> writer1 <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> <span style="color: #b60157">10</span>.pure[<span style="color: #4b69c6">Logged</span>]<br>  <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">b</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">c</span><span style="color: #198810">"</span>).tell<br>  b <span style="color: #d73948">&lt;-</span> <span style="color: #b60157">32</span>.writer(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">x</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">y</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">z</span><span style="color: #198810">"</span>))<br>} <span style="color: #d73948">yield</span> a + b<br><span style="color: #74747c">//</span><span style="color: #74747c"> writer1: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("a", "b", "c", "x", "y", "z"), 42)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br>writer1.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Tuple2[Vector[String], Int] = (</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Vector("a", "b", "c", "x", "y", "z"),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   42</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>In addition to transforming the result with <code>map</code> and <code>flatMap</code>, we can transform the log in a <code>Writer</code> with the <code>mapWritten</code> method.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> writer2 <span style="color: #d73948">=</span> writer1.mapWritten(<span style="color: #d73948">_</span>.map(<span style="color: #d73948">_</span>.toUpperCase))<br><span style="color: #74747c">//</span><span style="color: #74747c"> writer2: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("A", "B", "C", "X", "Y", "Z"), 42)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br>writer2.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Tuple2[Vector[String], Int] = (</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Vector("A", "B", "C", "X", "Y", "Z"),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   42</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>We can transform both log and result simultaneously using <code>bimap</code> or <code>mapBoth</code>. <code>bimap</code> takes two function parameters, one for the log and one for the result. <code>mapBoth</code> takes a single function that accepts two parameters.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> writer3 <span style="color: #d73948">=</span> writer1.bimap(<br>  log <span style="color: #d73948">=></span> log.map(<span style="color: #d73948">_</span>.toUpperCase),<br>  res <span style="color: #d73948">=></span> res * <span style="color: #b60157">100</span><br>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> writer3: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("A", "B", "C", "X", "Y", "Z"), 4200)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br>writer3.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Tuple2[Vector[String], Int] = (</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Vector("A", "B", "C", "X", "Y", "Z"),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   4200</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br><span style="color: #d73948">val</span> writer4 <span style="color: #d73948">=</span> writer1.mapBoth { (log, res) <span style="color: #d73948">=</span>><br>  <span style="color: #d73948">val</span> log2 <span style="color: #d73948">=</span> log.map(<span style="color: #d73948">_</span> + <span style="color: #198810">"</span><span style="color: #198810">!</span><span style="color: #198810">"</span>)<br>  <span style="color: #d73948">val</span> res2 <span style="color: #d73948">=</span> res * <span style="color: #b60157">1000</span><br>  (log2, res2)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> writer4: WriterT[Id, Vector[String], Int] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (Vector("a!", "b!", "c!", "x!", "y!", "z!"), 42000)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br>writer4.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Tuple2[Vector[String], Int] = (</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Vector("a!", "b!", "c!", "x!", "y!", "z!"),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   42000</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Finally, we can clear the log with the <code>reset</code> method, and swap log and result with the <code>swap</code> method.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> writer5 <span style="color: #d73948">=</span> writer1.reset<br><span style="color: #74747c">//</span><span style="color: #74747c"> writer5: WriterT[Id, Vector[String], Int] = WriterT(run = (Vector(), 42))</span><br><br>writer5.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Tuple2[Vector[String], Int] = (Vector(), 42)</span><br><br><span style="color: #d73948">val</span> writer6 <span style="color: #d73948">=</span> writer1.swap<br><span style="color: #74747c">//</span><span style="color: #74747c"> writer6: WriterT[Id, Int, Vector[String]] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (42, Vector("a", "b", "c", "x", "y", "z"))</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br>writer6.run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Tuple2[Int, Vector[String]] = (</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   42,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Vector("a", "b", "c", "x", "y", "z")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <h5>Exercise: Show Your Working</h5>
    <p><code>Writers</code> are useful for logging operations in multi-threaded environments. Let’s confirm this by computing (and logging) some factorials.</p>
    <p>The <code>factorial</code> function below computes a factorial and prints out the intermediate steps as it runs. The <code>slowly</code> helper function ensures this takes a while to run, even on the very small examples below:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">slowly</span>[<span style="color: #4b69c6">A</span>](body: <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span>) <span style="color: #d73948">=</span><br>  <span style="color: #d73948">try</span> body <span style="color: #d73948">finally</span> <span style="color: #4b69c6">Thread</span>.sleep(<span style="color: #b60157">100</span>)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">factorial</span>(n: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> ans <span style="color: #d73948">=</span> slowly(<span style="color: #d73948">if</span>(n <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #b60157">1</span> <span style="color: #d73948">else</span> n * factorial(n - <span style="color: #b60157">1</span>))<br>  println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">fact </span>$n<span style="color: #198810"> </span>$ans<span style="color: #198810">"</span>)<br>  ans<br>}</code></pre>
    <p>Here’s the output—a sequence of monotonically increasing values:</p>
    <pre><code data-lang="scala">factorial(<span style="color: #b60157">5</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 0 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 1 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 2 2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 3 6</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 4 24</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 5 120</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Int = 120</span></code></pre>
    <p>If we start several factorials in parallel, the log messages can become interleaved on standard out. This makes it difficult to see which messages come from which computation:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.*<br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.*<br><span style="color: #d73948">import</span> scala.concurrent.duration.*<br><br><span style="color: #4b69c6">Await</span>.result(<span style="color: #4b69c6">Future</span>.sequence(<span style="color: #4b69c6">Vector</span>(<br>  <span style="color: #4b69c6">Future</span>(factorial(<span style="color: #b60157">5</span>)),<br>  <span style="color: #4b69c6">Future</span>(factorial(<span style="color: #b60157">5</span>))<br>)), <span style="color: #b60157">5</span>.seconds)<br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 0 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 0 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 1 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 1 1</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 2 2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 2 2</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 3 6</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 3 6</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 4 24</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 4 24</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 5 120</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> fact 5 120</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res: scala.collection.immutable.Vector[Int] =</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Vector(120, 120)</span></code></pre>
    <p>Rewrite <code>factorial</code> so it captures the log messages in a <code>Writer</code>. Demonstrate that this allows us to reliably separate the logs for concurrent computations.</p>
    <h3 id="loc-268">10.8. The Reader Monad</h3>
    <p><code>cats.data.Reader</code> is a monad that allows us to sequence operations that depend on some input. Instances of <code>Reader</code> wrap up functions of one argument, providing us with useful methods for composing them.</p>
    <p>One common use for <code>Readers</code> is dependency injection. If we have a number of operations that all depend on some external configuration, we can chain them together using a <code>Reader</code> to produce one large operation that accepts the configuration as a parameter and runs our program in the order specified.</p>
    <h4 id="loc-269">10.8.1. Creating and Unpacking Readers</h4>
    <p>We can create a <code>Reader[A, B]</code> from a function <code>A => B</code> using the <code>Reader.apply</code> constructor:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.Reader<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Cat</span>(name: <span style="color: #4b69c6">String</span>, favoriteFood: <span style="color: #4b69c6">String</span>)<br><br><span style="color: #d73948">val</span> catName: <span style="color: #4b69c6">Reader</span>[<span style="color: #4b69c6">Cat</span>, <span style="color: #4b69c6">String</span>] =<br>  <span style="color: #4b69c6">Reader</span>(cat <span style="color: #d73948">=></span> cat.name)<br><span style="color: #74747c">//</span><span style="color: #74747c"> catName: Kleisli[Id, Cat, String] = Kleisli(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = repl.MdocSession$MdocApp$$Lambda/0x00000000600e9280@4fc805cd</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>We can extract the function again using the <code>Reader's</code> <code>run</code> method and call it using <code>apply</code> as usual:</p>
    <pre><code data-lang="scala">catName.run(<span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Garfield</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">lasagne</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: String = "Garfield"</span></code></pre>
    <p>So far so simple, but what advantage do <code>Readers</code> give us over the raw functions?</p>
    <h4 id="loc-270">10.8.2. Composing Readers</h4>
    <p>The power of <code>Readers</code> comes from their <code>map</code> and <code>flatMap</code> methods, which represent different kinds of function composition. We typically create a set of <code>Readers</code> that accept the same type of configuration, combine them with <code>map</code> and <code>flatMap</code>, and then call <code>run</code> to inject the config at the end.</p>
    <p>The <code>map</code> method simply extends the computation in the <code>Reader</code> by passing its result through a function.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> greetKitty: <span style="color: #4b69c6">Reader</span>[<span style="color: #4b69c6">Cat</span>, <span style="color: #4b69c6">String</span>] =<br>  catName.map(name <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Hello </span><span style="color: #198810">${</span>name<span style="color: #198810">}</span><span style="color: #198810">"</span>)</code></pre>
    <pre><code data-lang="scala">greetKitty.run(<span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Heathcliff</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">junk food</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "Hello Heathcliff"</span></code></pre>
    <p>The <code>flatMap</code> method is more interesting. It allows us to combine readers that depend on the same input type. To illustrate this, let’s extend our greeting example to also feed the cat.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> feedKitty: <span style="color: #4b69c6">Reader</span>[<span style="color: #4b69c6">Cat</span>, <span style="color: #4b69c6">String</span>] =<br>  <span style="color: #4b69c6">Reader</span>(cat <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Have a nice bowl of </span><span style="color: #198810">${</span>cat.favoriteFood<span style="color: #198810">}</span><span style="color: #198810">"</span>)<br><br><span style="color: #d73948">val</span> greetAndFeed: <span style="color: #4b69c6">Reader</span>[<span style="color: #4b69c6">Cat</span>, <span style="color: #4b69c6">String</span>] =<br>  <span style="color: #d73948">for</span> {<br>    greet <span style="color: #d73948">&lt;-</span> greetKitty<br>    feed  <span style="color: #d73948">&lt;-</span> feedKitty<br>  } <span style="color: #d73948">yield</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$greet<span style="color: #198810">. </span>$feed<span style="color: #198810">.</span><span style="color: #198810">"</span></code></pre>
    <pre><code data-lang="scala">greetAndFeed(<span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Garfield</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">lasagne</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "Hello Garfield. Have a nice bowl of lasagne."</span><br>greetAndFeed(<span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Heathcliff</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">junk food</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "Hello Heathcliff. Have a nice bowl of junk food."</span></code></pre>
    <h5>Exercise: Hacking on Readers</h5>
    <p>The classic use of <code>Readers</code> is to build programs that accept a configuration as a parameter. Let’s ground this with a complete example of a simple login system. Our configuration will consist of two databases: a list of valid users and a list of their passwords:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Db</span>(<br>  usernames: <span style="color: #4b69c6">Map</span>[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>],<br>  passwords: <span style="color: #4b69c6">Map</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">String</span>]<br>)</code></pre>
    <p>Start by creating a type alias <code>DbReader</code> for a <code>Reader</code> that consumes a <code>Db</code> as input. This will make the rest of our code shorter.</p>
    <p>Now create methods that generate <code>DbReaders</code> to look up the username for an <code>Int</code> user ID, and look up the password for a <code>String</code> username. The type signatures should be as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">findUsername</span>(userId: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">DbReader</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">String</span>]] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">checkPassword</span>(<br>      username: <span style="color: #4b69c6">String</span>,<br>      password: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">DbReader</span>[<span style="color: #d73948">Boolean</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>Finally create a <code>checkLogin</code> method to check the password for a given user ID. The type signature should be as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">checkLogin</span>(<br>      userId: <span style="color: #d73948">Int</span>,<br>      password: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">DbReader</span>[<span style="color: #d73948">Boolean</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>You should be able to use <code>checkLogin</code> as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> users <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<br>  <span style="color: #b60157">1</span> -> <span style="color: #198810">"</span><span style="color: #198810">dade</span><span style="color: #198810">"</span>,<br>  <span style="color: #b60157">2</span> -> <span style="color: #198810">"</span><span style="color: #198810">kate</span><span style="color: #198810">"</span>,<br>  <span style="color: #b60157">3</span> -> <span style="color: #198810">"</span><span style="color: #198810">margo</span><span style="color: #198810">"</span><br>)<br><br><span style="color: #d73948">val</span> passwords <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<br>  <span style="color: #198810">"</span><span style="color: #198810">dade</span><span style="color: #198810">"</span>  -> <span style="color: #198810">"</span><span style="color: #198810">zerocool</span><span style="color: #198810">"</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">kate</span><span style="color: #198810">"</span>  -> <span style="color: #198810">"</span><span style="color: #198810">acidburn</span><span style="color: #198810">"</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">margo</span><span style="color: #198810">"</span> -> <span style="color: #198810">"</span><span style="color: #198810">secret</span><span style="color: #198810">"</span><br>)<br><br><span style="color: #d73948">val</span> db <span style="color: #d73948">=</span> <span style="color: #4b69c6">Db</span>(users, passwords)</code></pre>
    <pre><code data-lang="scala">checkLogin(<span style="color: #b60157">1</span>, <span style="color: #198810">"</span><span style="color: #198810">zerocool</span><span style="color: #198810">"</span>).run(db)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Boolean = true</span><br>checkLogin(<span style="color: #b60157">4</span>, <span style="color: #198810">"</span><span style="color: #198810">davinci</span><span style="color: #198810">"</span>).run(db)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Boolean = false</span></code></pre>
    <h4 id="loc-271">10.8.3. When to Use Readers?</h4>
    <p><code>Readers</code> provide a tool for doing dependency injection. We write steps of our program as instances of <code>Reader</code>, chain them together with <code>map</code> and <code>flatMap</code>, and build a function that accepts the dependency as input.</p>
    <p>There are many ways of implementing dependency injection in Scala, from simple techniques like methods with multiple parameter lists, through implicit parameters and type classes, to complex techniques like the cake pattern and DI frameworks.</p>
    <p><code>Readers</code> are most useful in situations where:</p>
    <ul>
      <li>
        <p>we are constructing a program that can easily be represented by a function;</p>
      </li>
      <li>
        <p>we need to defer injection of a known parameter or set of parameters;</p>
      </li>
      <li>
        <p>we want to be able to test parts of the program in isolation.</p>
      </li>
    </ul>
    <p>By representing the steps of our program as <code>Readers</code> we can test them as easily as pure functions, plus we gain access to the <code>map</code> and <code>flatMap</code> combinators.</p>
    <p>For more complicated problems where we have lots of dependencies, or where a program isn’t easily represented as a pure function, other dependency injection techniques tend to be more appropriate.</p>
    <div>
      <h5>Kleisli Arrows</h5>
      <p>You may have noticed from console output that <code>Reader</code> is implemented in terms of another type called <code>Kleisli</code>. <strong>Kleisli arrows</strong> provide a more general form of <code>Reader</code> that generalise over the type constructor of the result type. We will encounter Kleislis again in <a href="#loc-279">Chapter 11</a>.</p>
    </div>
    <h3 id="loc-272">10.9. The State Monad</h3>
    <p><code>cats.data.State</code> allows us to pass additional state around as part of a computation. We define <code>State</code> instances representing atomic state operations and thread them together using <code>map</code> and <code>flatMap</code>. In this way we can model mutable state in a purely functional way, without using actual mutation.</p>
    <h4 id="loc-273">10.9.1. Creating and Unpacking State</h4>
    <p>Boiled down to their simplest form, instances of <code>State[S, A]</code> represent functions of type <code>S => (S, A)</code>. <code>S</code> is the type of the state and <code>A</code> is the type of the result. In the example below, the state has type <code>Int</code>, and we return a <code>String</code> result computed from the state.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.State<br><br><span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> <span style="color: #4b69c6">State</span>[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>]{ state <span style="color: #d73948">=</span>><br>  (state, <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">The state is </span>$state<span style="color: #198810">"</span>)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> a: IndexedStateT[[A >: Nothing &lt;: Any] =>> Eval[A], Int, Int, String] = cats.data.IndexedStateT@7423f6ba</span></code></pre>
    <div>
      <h5>State and IndexedStateT</h5>
      <p>You may have noticed the console output reports a type of <code>IndexedStateT</code> when we create an instance of <code>State</code>. Just like with <code>Writer</code> and <code>Reader</code>, <code>State</code> is defined as a type alias of a more complicated type <code>IndexedStateT</code>:</p>
      <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">S</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">IndexedStateT</span>[<span style="color: #4b69c6">Eval</span>, <span style="color: #4b69c6">S</span>, <span style="color: #4b69c6">S</span>, <span style="color: #4b69c6">A</span>]</code></pre>
      <p>We can ignore this more complicated type.</p>
    </div>
    <p>In other words, an instance of <code>State</code> is a function that does two things:</p>
    <ul>
      <li>transforms an input state to an output state;</li>
      <li>computes a result.</li>
    </ul>
    <p>We can “run” our monad by supplying an initial state. <code>State</code> provides three methods—<code>run</code>, <code>runS</code>, and <code>runA</code>—that return different combinations of state and result. Each method returns an instance of <code>Eval</code>, which <code>State</code> uses to maintain stack safety. We call the <code>value</code> method as usual to extract the actual result:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Get the state and the result:</span><br><span style="color: #d73948">val</span> (state, result) <span style="color: #d73948">=</span> a.run(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> state: Int = 10</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> result: String = "The state is 10"</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Get the state, ignore the result:</span><br><span style="color: #d73948">val</span> justTheState <span style="color: #d73948">=</span> a.runS(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> justTheState: Int = 10</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Get the result, ignore the state:</span><br><span style="color: #d73948">val</span> justTheResult <span style="color: #d73948">=</span> a.runA(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> justTheResult: String = "The state is 10"</span></code></pre>
    <h4 id="loc-274">10.9.2. Composing and Transforming State</h4>
    <p>As we’ve seen with <code>Reader</code> and <code>Writer</code>, the power of the <code>State</code> monad comes from combining instances. The <code>map</code> and <code>flatMap</code> methods thread the state from one instance to another. Each individual instance represents an atomic state transformation, and their combination represents a complete sequence of changes:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> step1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">State</span>[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>]{ num <span style="color: #d73948">=</span>><br>  <span style="color: #d73948">val</span> ans <span style="color: #d73948">=</span> num + <span style="color: #b60157">1</span><br>  (ans, <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Result of step1: </span>$ans<span style="color: #198810">"</span>)<br>}<br><br><span style="color: #d73948">val</span> step2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">State</span>[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>]{ num <span style="color: #d73948">=</span>><br>  <span style="color: #d73948">val</span> ans <span style="color: #d73948">=</span> num * <span style="color: #b60157">2</span><br>  (ans, <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Result of step2: </span>$ans<span style="color: #198810">"</span>)<br>}<br><br><span style="color: #d73948">val</span> both <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> step1<br>  b <span style="color: #d73948">&lt;-</span> step2<br>} <span style="color: #d73948">yield</span> (a, b)</code></pre>
    <p>When we run this program we get the result of applying each step in sequence. State is threaded from step to step even though we don’t interact with it in the for comprehension.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> (state, result) <span style="color: #d73948">=</span> both.run(<span style="color: #b60157">20</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> state: Int = 42</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> result: Tuple2[String, String] = (</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   "Result of step1: 21",</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   "Result of step2: 42"</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>The general model for using the <code>State</code> monad is to represent each step of a computation as an instance and compose the steps using the standard monad operators. Cats provides several convenience constructors for creating primitive steps:</p>
    <ul>
      <li><code>get</code> extracts the state as the result;</li>
      <li><code>set</code> updates the state and returns unit as the result;</li>
      <li><code>pure</code> ignores the state and returns a supplied result;</li>
      <li><code>inspect</code> extracts the state via a transformation function;</li>
      <li><code>modify</code> updates the state using an update function.</li>
    </ul>
    <pre><code data-lang="scala"><span style="color: #4b69c6">State</span>.get[<span style="color: #d73948">Int</span>].run(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Tuple2[Int, Int] = (10, 10)</span><br><br><span style="color: #4b69c6">State</span>.set[<span style="color: #d73948">Int</span>](<span style="color: #b60157">30</span>).run(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Tuple2[Int, Unit] = (30, ())</span><br><br><span style="color: #4b69c6">State</span>.pure[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>](<span style="color: #198810">"</span><span style="color: #198810">Result</span><span style="color: #198810">"</span>).run(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Tuple2[Int, String] = (10, "Result")</span><br><br><span style="color: #4b69c6">State</span>.inspect[<span style="color: #d73948">Int</span>, <span style="color: #4b69c6">String</span>](x <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>x<span style="color: #198810">}</span><span style="color: #198810">!</span><span style="color: #198810">"</span>).run(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Tuple2[Int, String] = (10, "10!")</span><br><br><span style="color: #4b69c6">State</span>.modify[<span style="color: #d73948">Int</span>](<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>).run(<span style="color: #b60157">10</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Tuple2[Int, Unit] = (11, ())</span></code></pre>
    <p>We can assemble these building blocks using a for comprehension. We typically ignore the result of intermediate stages that only represent transformations on the state.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.State<br><span style="color: #d73948">import</span> State.*<br><br><span style="color: #d73948">val</span> program: <span style="color: #4b69c6">State</span>[<span style="color: #d73948">Int</span>, (<span style="color: #d73948">Int</span>, <span style="color: #d73948">Int</span>, <span style="color: #d73948">Int</span>)] <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> get[<span style="color: #d73948">Int</span>]<br>  <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> set[<span style="color: #d73948">Int</span>](a + <span style="color: #b60157">1</span>)<br>  b <span style="color: #d73948">&lt;-</span> get[<span style="color: #d73948">Int</span>]<br>  <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> modify[<span style="color: #d73948">Int</span>](<span style="color: #d73948">_</span> + <span style="color: #b60157">1</span>)<br>  c <span style="color: #d73948">&lt;-</span> inspect[<span style="color: #d73948">Int</span>, <span style="color: #d73948">Int</span>](<span style="color: #d73948">_</span> * <span style="color: #b60157">1000</span>)<br>} <span style="color: #d73948">yield</span> (a, b, c)</code></pre>
    <p>As we expect, the result is the composition of the individual stages.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> (state, result) <span style="color: #d73948">=</span> program.run(<span style="color: #b60157">1</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> state: Int = 3</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> result: Tuple3[Int, Int, Int] = (1, 2, 3000)</span></code></pre>
    <h5>Exercise: Post-Order Calculator</h5>
    <p>The <code>State</code> monad allows us to implement simple interpreters for complex expressions, passing the values of mutable registers along with the result. We can see a simple example of this by implementing a calculator for post-order integer arithmetic expressions.</p>
    <p>In case you haven’t heard of post-order expressions before (don’t worry if you haven’t), they are a mathematical notation where we write the operator <em>after</em> its operands. So, for example, instead of writing <code>1 + 2</code> we would write:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">1</span> <span style="color: #b60157">2</span> +</code></pre>
    <p>Although post-order expressions are difficult for humans to read, they are easy to evaluate in code. All we need to do is traverse the symbols from left to right, carrying a <em>stack</em> of operands with us as we go:</p>
    <ul>
      <li>
        <p>when we see a number, we push it onto the stack;</p>
      </li>
      <li>
        <p>when we see an operator, we pop two operands off the stack, operate on them, and push the result in their place.</p>
      </li>
    </ul>
    <p>This allows us to evaluate complex expressions without using parentheses. For example, we can evaluate <code>(1 + 2) * 3)</code> as follows:</p>
    <pre><code data-lang="scala"><span style="color: #b60157">1</span> <span style="color: #b60157">2</span> + <span style="color: #b60157">3</span> * <span style="color: #74747c">//</span><span style="color: #74747c"> see 1, push onto stack</span><br><span style="color: #b60157">2</span> + <span style="color: #b60157">3</span> *   <span style="color: #74747c">//</span><span style="color: #74747c"> see 2, push onto stack</span><br>+ <span style="color: #b60157">3</span> *     <span style="color: #74747c">//</span><span style="color: #74747c"> see +, pop 1 and 2 off of stack,</span><br>          <span style="color: #74747c">//</span><span style="color: #74747c">        push (1 + 2) = 3 in their place</span><br><span style="color: #b60157">3</span> <span style="color: #b60157">3</span> *     <span style="color: #74747c">//</span><span style="color: #74747c"> see 3, push onto stack</span><br><span style="color: #b60157">3</span> *       <span style="color: #74747c">//</span><span style="color: #74747c"> see 3, push onto stack</span><br>*         <span style="color: #74747c">//</span><span style="color: #74747c"> see *, pop 3 and 3 off of stack,</span><br>          <span style="color: #74747c">//</span><span style="color: #74747c">        push (3 * 3) = 9 in their place</span></code></pre>
    <p>Let’s write an interpreter for these expressions. We can parse each symbol into a <code>State</code> instance representing a transformation on the stack and an intermediate result. The <code>State</code> instances can be threaded together using <code>flatMap</code> to produce an interpreter for any sequence of symbols.</p>
    <p>Start by writing a function <code>evalOne</code> that parses a single symbol into an instance of <code>State</code>. Use the code below as a template. Don’t worry about error handling for now—if the stack is in the wrong configuration, it’s OK to throw an exception.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.State<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">CalcState</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>], <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">evalOne</span>(sym: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">CalcState</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span></code></pre>
    <p>If this seems difficult, think about the basic form of the <code>State</code> instances you’re returning. Each instance represents a functional transformation from a stack to a pair of a stack and a result. You can ignore any wider context and focus on just that one step:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>], <span style="color: #d73948">Int</span>] { oldStack <span style="color: #d73948">=</span>><br>  <span style="color: #d73948">val</span> newStack <span style="color: #d73948">=</span> someTransformation(oldStack)<br>  <span style="color: #d73948">val</span> result   <span style="color: #d73948">=</span> someCalculation<br>  (newStack, result)<br>}</code></pre>
    <p>Feel free to write your <code>Stack</code> instances in this form or as sequences of the convenience constructors we saw above.</p>
    <p><code>evalOne</code> allows us to evaluate single-symbol expressions as follows. We call <code>runA</code> supplying <code>Nil</code> as an initial stack, and call <code>value</code> to unpack the resulting <code>Eval</code> instance:</p>
    <pre><code data-lang="scala">evalOne(<span style="color: #198810">"</span><span style="color: #198810">42</span><span style="color: #198810">"</span>).runA(<span style="color: #4b69c6">Nil</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Int = 42</span></code></pre>
    <p>We can represent more complex programs using <code>evalOne</code>, <code>map</code>, and <code>flatMap</code>. Note that most of the work is happening on the stack, so we ignore the results of the intermediate steps for <code>evalOne("1")</code> and <code>evalOne("2")</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> program <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  <span style="color: #d73948">_</span>   <span style="color: #d73948">&lt;-</span> evalOne(<span style="color: #198810">"</span><span style="color: #198810">1</span><span style="color: #198810">"</span>)<br>  <span style="color: #d73948">_</span>   <span style="color: #d73948">&lt;-</span> evalOne(<span style="color: #198810">"</span><span style="color: #198810">2</span><span style="color: #198810">"</span>)<br>  ans <span style="color: #d73948">&lt;-</span> evalOne(<span style="color: #198810">"</span><span style="color: #198810">+</span><span style="color: #198810">"</span>)<br>} <span style="color: #d73948">yield</span> ans<br><span style="color: #74747c">//</span><span style="color: #74747c"> program: IndexedStateT[[A >: Nothing &lt;: Any] =>> Eval[A], List[Int], List[Int], Int] = cats.data.IndexedStateT@2d545736</span><br><br>program.runA(<span style="color: #4b69c6">Nil</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Int = 3</span></code></pre>
    <p>Generalise this example by writing an <code>evalAll</code> method that computes the result of a <code>List[String]</code>. Use <code>evalOne</code> to process each symbol, and thread the resulting <code>State</code> monads together using <code>flatMap</code>. Your function should have the following signature:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">evalAll</span>(input: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]): <span style="color: #4b69c6">CalcState</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>We can use <code>evalAll</code> to conveniently evaluate multi-stage expressions:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> multistageProgram <span style="color: #d73948">=</span> evalAll(<span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">2</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">+</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">3</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">*</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> multistageProgram: IndexedStateT[[A >: Nothing &lt;: Any] =>> Eval[A], List[Int], List[Int], Int] = cats.data.IndexedStateT@5d166977</span><br><br>multistageProgram.runA(<span style="color: #4b69c6">Nil</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Int = 9</span></code></pre>
    <p>Because <code>evalOne</code> and <code>evalAll</code> both return instances of <code>State</code>, we can thread these results together using <code>flatMap</code>. <code>evalOne</code> produces a simple stack transformation and <code>evalAll</code> produces a complex one, but they’re both pure functions and we can use them in any order as many times as we like:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> biggerProgram <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  <span style="color: #d73948">_</span>   <span style="color: #d73948">&lt;-</span> evalAll(<span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">2</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">+</span><span style="color: #198810">"</span>))<br>  <span style="color: #d73948">_</span>   <span style="color: #d73948">&lt;-</span> evalAll(<span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">3</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">4</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">+</span><span style="color: #198810">"</span>))<br>  ans <span style="color: #d73948">&lt;-</span> evalOne(<span style="color: #198810">"</span><span style="color: #198810">*</span><span style="color: #198810">"</span>)<br>} <span style="color: #d73948">yield</span> ans<br><span style="color: #74747c">//</span><span style="color: #74747c"> biggerProgram: IndexedStateT[[A >: Nothing &lt;: Any] =>> Eval[A], List[Int], List[Int], Int] = cats.data.IndexedStateT@64427200</span><br><br>biggerProgram.runA(<span style="color: #4b69c6">Nil</span>).value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Int = 21</span></code></pre>
    <p>Complete the exercise by implementing an <code>evalInput</code> function that splits an input <code>String</code> into symbols, calls <code>evalAll</code>, and runs the result with an initial stack.</p>
    <h3 id="loc-275">10.10. Defining Custom Monads</h3>
    <p>We can define a <code>Monad</code> for a custom type by providing implementations of three methods: <code>flatMap</code>, <code>pure</code>, and a method we haven’t seen yet called <code>tailRecM</code>. Here is an implementation of <code>Monad</code> for <code>Option</code> as an example:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monad<br><span style="color: #d73948">import</span> scala.annotation.tailrec<br><br><span style="color: #d73948">val</span> optionMonad <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Option</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](opt: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>])<br>      (fn: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    opt.flatMap(fn)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](opt: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Some</span>(opt)<br><br>  <span style="color: #301414">@</span><span style="color: #301414">tailrec</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">tailRecM</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](a: <span style="color: #4b69c6">A</span>)(fn: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>]]): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> {<br>    fn(a) <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>           <span style="color: #d73948">=></span> <span style="color: #4b69c6">None</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(<span style="color: #4b69c6">Left</span>(a1)) <span style="color: #d73948">=></span> tailRecM(a1)(fn)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(<span style="color: #4b69c6">Right</span>(b)) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Some</span>(b)<br>    }<br>  }<br>}</code></pre>
    <p>The <code>tailRecM</code> method is an optimisation used in Cats to limit the amount of stack space consumed by nested calls to <code>flatMap</code>. The technique comes from a 2015 paper by PureScript creator Phil Freeman <span id="loc-276">[</span><a href="#loc-505" role="doc-biblioref">29</a>]. The method should recursively call itself until the result of <code>fn</code> returns a <code>Right</code>.</p>
    <p>To motivate its use let’s use the following example: suppose we want to write a method that calls a function until the function indicates it should stop. The function will return a monad instance because, as we know, monads represent sequencing and many monads have some notion of stopping.</p>
    <p>We can write this method in terms of <code>flatMap</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">retry</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>, <span style="color: #4b69c6">A</span>](start: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  f(start).flatMap{ a <span style="color: #d73948">=</span>><br>    retry(a)(f)<br>  }</code></pre>
    <p>Unfortunately it is not stack-safe. It works for small input.</p>
    <pre><code data-lang="scala">retry(<span style="color: #b60157">100</span>)(a <span style="color: #d73948">=></span> <span style="color: #d73948">if</span>(a <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">None</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Some</span>(a - <span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Option[Int] = None</span></code></pre>
    <p>but if we try large input we get a <code>StackOverflowError</code>.</p>
    <pre><code data-lang="scala">retry(<span style="color: #b60157">100000</span>)(a <span style="color: #d73948">=></span> <span style="color: #d73948">if</span>(a <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">None</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Some</span>(a - <span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> KABLOOIE!!!!</span></code></pre>
    <p>We can instead rewrite this method using <code>tailRecM</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">retryTailRecM</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>, <span style="color: #4b69c6">A</span>](start: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">F</span>].tailRecM(start){ a <span style="color: #d73948">=</span>><br>    f(a).map(a2 <span style="color: #d73948">=></span> <span style="color: #4b69c6">Left</span>(a2))<br>  }</code></pre>
    <p>Now it runs successfully no matter how many time we recurse.</p>
    <pre><code data-lang="scala">retryTailRecM(<span style="color: #b60157">100000</span>)(a <span style="color: #d73948">=></span> <span style="color: #d73948">if</span>(a <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">None</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Some</span>(a - <span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Option[Int] = None</span></code></pre>
    <p>It’s important to note that we have to explicitly call <code>tailRecM</code>. There isn’t a code transformation that will convert non-tail recursive code into tail recursive code that uses <code>tailRecM</code>. However there are several utilities provided by the <code>Monad</code> type class that makes these kinds of methods easier to write. For example, we can rewrite <code>retry</code> in terms of <code>iterateWhileM</code> and we don’t have to explicitly call <code>tailRecM</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">retryM</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>, <span style="color: #4b69c6">A</span>](start: <span style="color: #4b69c6">A</span>)(f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  start.iterateWhileM(f)(a <span style="color: #d73948">=></span> <span style="color: #d73948">true</span>)</code></pre>
    <p>This implementation is stack-safe.</p>
    <pre><code data-lang="scala">retryM(<span style="color: #b60157">100000</span>)(a <span style="color: #d73948">=></span> <span style="color: #d73948">if</span>(a <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">None</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Some</span>(a - <span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Option[Int] = None</span></code></pre>
    <p>We’ll see more methods that use <code>tailRecM</code> in <a href="#loc-315">Section 13.1</a>.</p>
    <p>All of the built-in monads in Cats have tail-recursive implementations of <code>tailRecM</code>, although writing one for custom monads can be a challenge… as we shall see.</p>
    <h5>Exercise: Branching out Further with Monads</h5>
    <p>Let’s write a <code>Monad</code> for our <code>Tree</code> data type from last chapter. Here’s the type again:</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">+</span><span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Branch</span>(left: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>])<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Leaf</span>(value: <span style="color: #4b69c6">A</span>) extends <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>]<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Tree</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">branch</span>[<span style="color: #4b69c6">A</span>](left: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Branch</span>(left, right)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">leaf</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Tree</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Leaf</span>(value)<br>}</code></pre>
    <p>Verify that the code works on instances of <code>Branch</code> and <code>Leaf</code>, and that the <code>Monad</code> provides <code>Functor</code>-like behaviour for free.</p>
    <p>Also verify that having a <code>Monad</code> in scope allows us to use for comprehensions, despite the fact that we haven’t directly implemented <code>flatMap</code> or <code>map</code> on <code>Tree</code>.</p>
    <p>Don’t feel you have to make <code>tailRecM</code> tail-recursive. Doing so is quite difficult. We’ve included both tail-recursive and non-tail-recursive implementations in the solutions so you can check your work.</p>
    <h3 id="loc-277">10.11. Conclusions</h3>
    <p>In this chapter we’ve seen monads up-close. We saw that <code>flatMap</code> can be viewed as an operator for sequencing computations, dictating the order in which operations must happen. From this viewpoint, <code>Option</code> represents a computation that can fail without an error message, <code>Either</code> represents computations that can fail with a message, <code>List</code> represents multiple possible results, and <code>Future</code> represents a computation that may produce a value at some point in the future.</p>
    <p>We’ve also seen some of the custom types and data structures that Cats provides, including <code>Id</code>, <code>Reader</code>, <code>Writer</code>, and <code>State</code>. These cover a wide range of use cases.</p>
    <p>Finally, in the unlikely event that we have to implement a custom monad, we’ve learned about defining our own instance using <code>tailRecM</code>. <code>tailRecM</code> is an odd wrinkle that is a concession to building a functional programming library that is stack-safe by default. We don’t need to understand <code>tailRecM</code> to understand monads, but having it around gives us benefits of which we can be grateful when writing monadic code.</p>
    <p><a id="loc-278" href="#loc-568" role="doc-biblioref"><em>The Essence of Functional Programming</em> [92</a>] introduced monads to functional programming. It describes monads in terms of <code>bind</code> and <code>unit</code>, which in Scala we call <code>flatMap</code> and <code>pure</code> respectively. It has several examples of interpreters built using monads, and relates monads to continuation-passing style, which we first met in <a href="#loc-137">Section 6.3.3</a>.</p>
    <h2 id="loc-279">11. Monad Transformers</h2>
    <p>Monads are <a href="http://blog.plover.com/prog/burritos.html">like burritos<a id="loc-280" href="#loc-652" role="doc-noteref"><sup>76</sup></a></a>, which means that once you acquire a taste, you’ll find yourself returning to them again and again. This is not without issues. As burritos can bloat the waist, monads can bloat the code base through nested for-comprehensions.</p>
    <p>Imagine we are interacting with a database. We want to look up a user record. The user may or may not be present, so we return an <code>Option[User]</code>. Our communication with the database could fail for many reasons (network issues, authentication problems, and so on), so this result is wrapped up in an <code>Either</code>, giving us a final result of <code>Either[Error, Option[User]]</code>.</p>
    <p>To use this value we must nest <code>flatMap</code> calls (or equivalently, for-comprehensions):</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">lookupUserName</span>(id: <span style="color: #d73948">Long</span>): <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">Error</span>, <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">String</span>]] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">for</span> {<br>    optUser <span style="color: #d73948">&lt;-</span> lookupUser(id)<br>  } <span style="color: #d73948">yield</span> {<br>    <span style="color: #d73948">for</span> { user &lt;- optUser } <span style="color: #d73948">yield</span> user.name<br>  }</code></pre>
    <p>This quickly becomes very tedious.</p>
    <h3 id="loc-281">11.1. Composing Monads</h3>
    <p>A question arises. Given two arbitrary monads, can we combine them in some way to make a single monad? That is, do monads <em>compose</em>? We can try to write the code but we soon hit problems:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Hypothetical example. This won't actually compile:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">compose</span>[<span style="color: #4b69c6">M1</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>, <span style="color: #4b69c6">M2</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>] <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">type</span> <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">M1</span>[<span style="color: #4b69c6">M2</span>[<span style="color: #4b69c6">A</span>]]<br><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Composed</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](a: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>      a.pure[<span style="color: #4b69c6">M2</span>].pure[<span style="color: #4b69c6">M1</span>]<br><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">A</span>])<br>        (f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>      <span style="color: #74747c">//</span><span style="color: #74747c"> Problem! How do we write flatMap?</span><br>      <span style="color: #d73948">???</span><br>  }<br>}</code></pre>
    <p>It is impossible to write a general definition of <code>flatMap</code> without knowing something about <code>M1</code> or <code>M2</code>. However, if we <em>do</em> know something about one or other monad, we can typically complete this code. For example, if we fix <code>M2</code> above to be <code>Option</code>, a definition of <code>flatMap</code> comes to light:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">A</span>])<br>    (f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  fa.flatMap(<span style="color: #d73948">_</span>.fold[<span style="color: #4b69c6">Composed</span>[<span style="color: #4b69c6">B</span>]](<span style="color: #4b69c6">None</span>.pure[<span style="color: #4b69c6">M1</span>])(f))</code></pre>
    <p>Notice that the definition above makes use of <code>None</code>, an <code>Option</code>-specific concept that doesn’t appear in the general <code>Monad</code> interface. We need this extra detail to combine <code>Option</code> with other monads. Similarly, there are things about other monads that help us write composed <code>flatMap</code> methods for them. This is the idea behind monad transformers: Cats defines transformers for a variety of monads, each providing the extra knowledge we need to compose that monad with others. Let’s look at some examples.</p>
    <h3 id="loc-282">11.2. A Transformative Example</h3>
    <p>Cats provides transformers for many monads, each named with a <code>T</code> suffix: <code>EitherT</code> composes <code>Either</code> with other monads, <code>OptionT</code> composes <code>Option</code>, and so on.</p>
    <p>Here’s an example that uses <code>OptionT</code> to compose <code>List</code> and <code>Option</code>. We can use <code>OptionT[List, A]</code>, aliased to <code>ListOption[A]</code> for convenience, to transform a <code>List[Option[A]]</code> into a single monad:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.OptionT<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ListOption</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">OptionT</span>[<span style="color: #4b69c6">List</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>Note how we build <code>ListOption</code> from the inside out: we pass <code>List</code>, the type of the outer monad, as a parameter to <code>OptionT</code>, the transformer for the inner monad.</p>
    <p>We can create instances of <code>ListOption</code> using the <code>OptionT</code> constructor, or more conveniently using <code>pure</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">val</span> result1: <span style="color: #4b69c6">ListOption</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">OptionT</span>(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">10</span>)))<br><span style="color: #74747c">//</span><span style="color: #74747c"> result1: OptionT[List, Int] = OptionT(value = List(Some(value = 10)))</span><br><br><span style="color: #d73948">val</span> result2: <span style="color: #4b69c6">ListOption</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #b60157">32</span>.pure[<span style="color: #4b69c6">ListOption</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> result2: OptionT[List, Int] = OptionT(value = List(Some(value = 32)))</span></code></pre>
    <p>The <code>map</code> and <code>flatMap</code> methods combine the corresponding methods of <code>List</code> and <code>Option</code> into single operations:</p>
    <pre><code data-lang="scala">result1.flatMap { (x: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=</span>><br>  result2.map { (y: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=</span>><br>    x + y<br>  }<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: OptionT[List, Int] = OptionT(value = List(Some(value = 42)))</span></code></pre>
    <p>This is the basis of all monad transformers. The combined <code>map</code> and <code>flatMap</code> methods allow us to use both component monads without having to recursively unpack and repack values at each stage in the computation. Now let’s look at the API in more depth.</p>
    <h3 id="loc-283">11.3. Monad Transformers in Cats</h3>
    <p>Each monad transformer is a data type, defined in <a href="http://typelevel.org/cats/api/cats/data/"><code>cats.data</code><a id="loc-284" href="#loc-653" role="doc-noteref"><sup>77</sup></a></a>, that allows us to <em>wrap</em> stacks of monads to produce new monads. We use the monads we’ve built via the <code>Monad</code> type class. The main concepts we have to cover to understand monad transformers are:</p>
    <ul>
      <li>the available transformer classes;</li>
      <li>how to build stacks of monads using transformers;</li>
      <li>how to construct instances of a monad stack; and</li>
      <li>how to pull apart a stack to access the wrapped monads.</li>
    </ul>
    <h4 id="loc-285">11.3.1. The Monad Transformer Classes</h4>
    <p>By convention, in Cats a monad <code>Foo</code> will have a transformer class called <code>FooT</code>. In fact, many monads in Cats are defined by combining a monad transformer with the <code>Id</code> monad. Concretely, some of the available instances are:</p>
    <ul>
      <li><code>cats.data.OptionT</code> for <code>Option</code>;</li>
      <li><code>cats.data.EitherT</code> for <code>Either</code>;</li>
      <li><code>cats.data.ReaderT</code> for <code>Reader</code>;</li>
      <li><code>cats.data.WriterT</code> for <code>Writer</code>;</li>
      <li><code>cats.data.StateT</code> for <code>State</code>;</li>
      <li><code>cats.data.IdT</code> for the <code>Id</code> monad.</li>
    </ul>
    <div>
      <h5>Kleisli Arrows</h5>
      <p>In <a href="#loc-268">Section 10.8</a> we mentioned that the <code>Reader</code> monad was a specialisation of a more general concept called a “kleisli arrow”, represented in Cats as <code>cats.data.Kleisli</code>.</p>
      <p>We can now reveal that <code>Kleisli</code> and <code>ReaderT</code> are, in fact, the same thing! <code>ReaderT</code> is actually a type alias for <code>Kleisli</code>. Hence, we were creating <code>Readers</code> last chapter and seeing <code>Kleislis</code> on the console.</p>
    </div>
    <h4 id="loc-286">11.3.2. Building Monad Stacks</h4>
    <p>All of these monad transformers follow the same convention. The transformer itself represents the <em>inner</em> monad in a stack, while the first type parameter specifies the outer monad. The remaining type parameters are the types we’ve used to form the corresponding monads.</p>
    <p>For example, our <code>ListOption</code> type above is an alias for <code>OptionT[List, A]</code> but the result is effectively a <code>List[Option[A]]</code>. In other words, we build monad stacks from the inside out:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">ListOption</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">OptionT</span>[<span style="color: #4b69c6">List</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>Many monads and all transformers have at least two type parameters, so we often end up defining type aliases for intermediate stages.</p>
    <p>For example, suppose we want to wrap <code>Either</code> around <code>Option</code>. <code>Option</code> is the innermost type so we want to use the <code>OptionT</code> monad transformer. We need to use <code>Either</code> as the first type parameter. However, <code>Either</code> itself has two type parameters and monads only have one. We can use a type alias to convert the type constructor to the correct shape.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Alias Either to a type constructor with one parameter:</span><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Build our final monad stack using OptionT:</span><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorOrOption</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">OptionT</span>[<span style="color: #4b69c6">ErrorOr</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p><code>ErrorOrOption</code> is a monad, just like <code>ListOption</code>. We can use <code>pure</code>, <code>map</code>, and <code>flatMap</code> as usual to create and transform instances.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> <span style="color: #b60157">10</span>.pure[<span style="color: #4b69c6">ErrorOrOption</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> a: OptionT[ErrorOr, Int] = OptionT(value = Right(value = Some(value = 10)))</span><br><span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> <span style="color: #b60157">32</span>.pure[<span style="color: #4b69c6">ErrorOrOption</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> b: OptionT[ErrorOr, Int] = OptionT(value = Right(value = Some(value = 32)))</span><br><br><span style="color: #d73948">val</span> c <span style="color: #d73948">=</span> a.flatMap(x <span style="color: #d73948">=></span> b.map(y <span style="color: #d73948">=></span> x + y))<br><span style="color: #74747c">//</span><span style="color: #74747c"> c: OptionT[ErrorOr, Int] = OptionT(value = Right(value = Some(value = 42)))</span></code></pre>
    <p>Things become even more confusing when we want to stack three or more monads.</p>
    <p>For example, let’s create a <code>Future</code> of an <code>Either</code> of <code>Option</code>. Once again we build this from the inside out with an <code>OptionT</code> of an <code>EitherT</code> of <code>Future</code>. However, defining this in one line is harder because <code>EitherT</code> has three type parameters:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> EitherT</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>], <span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>](stack: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]]) {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br>}</code></pre>
    <p>The three type parameters are as follows:</p>
    <ul>
      <li><code>F[_]</code> is the outer monad in the stack (<code>Either</code> is the inner);</li>
      <li><code>E</code> is the error type for the <code>Either</code>;</li>
      <li><code>A</code> is the result type for the <code>Either</code>.</li>
    </ul>
    <p>The simplest approach is to create an alias for <code>EitherT</code> that fixes <code>Future</code> and <code>Error</code> but allows <code>A</code> to vary.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.Future<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">FutureEither</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">EitherT</span>[<span style="color: #4b69c6">Future</span>, <span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">FutureEitherOption</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">OptionT</span>[<span style="color: #4b69c6">FutureEither</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>Our mammoth stack now composes three monads and our <code>map</code> and <code>flatMap</code> methods cut through three layers of abstraction.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.Await<br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global<br><span style="color: #d73948">import</span> scala.concurrent.duration.*<br><br><span style="color: #d73948">val</span> futureEitherOr: <span style="color: #4b69c6">FutureEitherOption</span>[<span style="color: #d73948">Int</span>] =<br>  <span style="color: #d73948">for</span> {<br>    a <span style="color: #d73948">&lt;-</span> <span style="color: #b60157">10</span>.pure[<span style="color: #4b69c6">FutureEitherOption</span>]<br>    b <span style="color: #d73948">&lt;-</span> <span style="color: #b60157">32</span>.pure[<span style="color: #4b69c6">FutureEitherOption</span>]<br>  } <span style="color: #d73948">yield</span> a + b</code></pre>
    <div>
      <h5>Type Lambdas</h5>
      <p>If you frequently find yourself defining multiple type aliases when building monad stacks, you may want to try Scala 3′s type lambdas. In Scala 2.13 you can use the <a href="https://github.com/typelevel/kind-projector">Kind Projector<a id="loc-287" href="#loc-654" role="doc-noteref"><sup>78</sup></a></a> compiler plugin to get the same functionality with slightly different syntax.</p>
      <p>Type lambdas make it more compact to define partially applied type constructors. For example we can write</p>
      <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">FutureEitherOption</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">OptionT</span>[[<span style="color: #4b69c6">A</span>] <span style="color: #4b69c6">=>></span> <span style="color: #4b69c6">EitherT</span>[<span style="color: #4b69c6">Future</span>, <span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>], <span style="color: #4b69c6">A</span>]</code></pre>
      <p>instead of the longer (but perhaps clearer!)</p>
      <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">FutureEither</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">EitherT</span>[<span style="color: #4b69c6">Future</span>, <span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">FutureEitherOption</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">OptionT</span>[<span style="color: #4b69c6">FutureEither</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    </div>
    <h4 id="loc-288">11.3.3. Constructing and Unpacking Instances</h4>
    <p>As we saw above, we can create transformed monad stacks using the relevant monad transformer’s <code>apply</code> method or the usual <code>pure</code> syntax<a id="loc-289" href="#loc-655" role="doc-noteref"><sup>79</sup></a>.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Create using apply:</span><br><span style="color: #d73948">val</span> errorStack1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">OptionT</span>[<span style="color: #4b69c6">ErrorOr</span>, <span style="color: #d73948">Int</span>](<span style="color: #4b69c6">Right</span>(<span style="color: #4b69c6">Some</span>(<span style="color: #b60157">10</span>)))<br><span style="color: #74747c">//</span><span style="color: #74747c"> errorStack1: OptionT[ErrorOr, Int] = OptionT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Right(value = Some(value = 10))</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Create using pure:</span><br><span style="color: #d73948">val</span> errorStack2 <span style="color: #d73948">=</span> <span style="color: #b60157">32</span>.pure[<span style="color: #4b69c6">ErrorOrOption</span>]<br><span style="color: #74747c">//</span><span style="color: #74747c"> errorStack2: OptionT[ErrorOr, Int] = OptionT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Right(value = Some(value = 32))</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Once we’ve finished with a monad transformer stack, we can unpack it using its <code>value</code> method. This returns the untransformed stack. We can then manipulate the individual monads in the usual way.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Extracting the untransformed monad stack:</span><br>errorStack1.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Either[String, Option[Int]] = Right(value = Some(value = 10))</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Mapping over the Either in the stack:</span><br>errorStack2.value.map(<span style="color: #d73948">_</span>.getOrElse(-<span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Either[String, Int] = Right(value = 32)</span></code></pre>
    <p>Each call to <code>value</code> unpacks a single monad transformer. We may need more than one call to completely unpack a large stack. For example, to <code>Await</code> the <code>FutureEitherOption</code> stack above, we need to call <code>value</code> twice.</p>
    <pre><code data-lang="scala">futureEitherOr<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: OptionT[FutureEither, Int] = OptionT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = EitherT(value = Future(Success(Right(Some(42)))))</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br><span style="color: #d73948">val</span> intermediate <span style="color: #d73948">=</span> futureEitherOr.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> intermediate: EitherT[[T >: Nothing &lt;: Any] =>> Future[T], String, Option[Int]] = EitherT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Future(Success(Right(Some(42))))</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><br><span style="color: #d73948">val</span> stack <span style="color: #d73948">=</span> intermediate.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> stack: Future[Either[String, Option[Int]]] = Future(Success(Right(Some(42))))</span><br><br><span style="color: #4b69c6">Await</span>.result(stack, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Either[String, Option[Int]] = Right(value = Some(value = 42))</span></code></pre>
    <h4 id="loc-290">11.3.4. Default Instances</h4>
    <p>Many monads in Cats are defined using the corresponding transformer and the <code>Id</code> monad. This is reassuring as it confirms that the APIs for monads and transformers are identical. <code>Reader</code>, <code>Writer</code>, and <code>State</code> are all defined in this way:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Reader</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">ReaderT</span>[<span style="color: #4b69c6">Id</span>, <span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #74747c">//</span><span style="color: #74747c"> = Kleisli[Id, E, A]</span><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Writer</span>[<span style="color: #4b69c6">W</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">WriterT</span>[<span style="color: #4b69c6">Id</span>, <span style="color: #4b69c6">W</span>, <span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">type</span> <span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">S</span>, <span style="color: #4b69c6">A</span>]  <span style="color: #d73948">= </span><span style="color: #4b69c6">StateT</span>[<span style="color: #4b69c6">Id</span>, <span style="color: #4b69c6">S</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>In other cases monad transformers are defined separately to their corresponding monads. In these cases, the methods of the transformer tend to mirror the methods on the monad. For example, <code>OptionT</code> defines <code>getOrElse</code>, and <code>EitherT</code> defines <code>fold</code>, <code>bimap</code>, <code>swap</code>, and other useful methods.</p>
    <h4 id="loc-291">11.3.5. Usage Patterns</h4>
    <p>Widespread use of monad transformers is sometimes difficult because they fuse monads together in predefined ways. Without careful thought, we can end up having to unpack and repack monads in different configurations to operate on them in different contexts.</p>
    <p>The most practical solution is to forego monad transformers entirely, and use a single “super-monad” that combines several useful monads into one. This is the approach taken by so-called IO monads, such as <a href="https://typelevel.org/cats-effect/">Cats Effect<a id="loc-292" href="#loc-656" role="doc-noteref"><sup>80</sup></a></a>. These monad types usually provide asynchronicity, error-handling, and more in one type.</p>
    <p>A similar approach is to create a single “super stack” and sticking to it throughout our code base. This works if the code is simple and largely uniform in nature. For example, in a web application, we could decide that all request handlers are asynchronous and all can fail with the same set of HTTP error codes. We could design a custom ADT representing the errors and use a fusion <code>Future</code> and <code>Either</code> everywhere in our code:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">abstract</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> HttpError</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> NotFound</span>(item: <span style="color: #4b69c6">String</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">HttpError</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> BadRequest</span>(msg: <span style="color: #4b69c6">String</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">HttpError</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">FutureEither</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">EitherT</span>[<span style="color: #4b69c6">Future</span>, <span style="color: #4b69c6">HttpError</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>The “super stack” approach starts to fail in larger, more heterogeneous code bases where different stacks make sense in different contexts. Another design pattern that makes more sense in these contexts uses monad transformers as local “glue code”. We expose untransformed stacks at module boundaries, transform them to operate on them locally, and untransform them before passing them on. This allows each module of code to make its own decisions about which transformers to use:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.Writer<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Logged</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Writer</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">A</span>]<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Methods generally return untransformed stacks:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">parseNumber</span>(str: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Logged</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]] <span style="color: #d73948">=</span><br>  util.<span style="color: #4b69c6">Try</span>(str.toInt).toOption <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(num) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Writer</span>(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Read </span>$str<span style="color: #198810">"</span>), <span style="color: #4b69c6">Some</span>(num))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>      <span style="color: #d73948">=></span> <span style="color: #4b69c6">Writer</span>(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Failed on </span>$str<span style="color: #198810">"</span>), <span style="color: #4b69c6">None</span>)<br>  }<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Consumers use monad transformers locally to simplify composition:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">addAll</span>(a: <span style="color: #4b69c6">String</span>, b: <span style="color: #4b69c6">String</span>, c: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Logged</span>[<span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]] <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">import</span> cats.data.OptionT<br><br>  <span style="color: #d73948">val</span> result <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>    a <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">OptionT</span>(parseNumber(a))<br>    b <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">OptionT</span>(parseNumber(b))<br>    c <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">OptionT</span>(parseNumber(c))<br>  } <span style="color: #d73948">yield</span> a + b + c<br><br>  result.value<br>}</code></pre>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> This approach doesn't force OptionT on other users' code:</span><br><span style="color: #d73948">val</span> result1 <span style="color: #d73948">=</span> addAll(<span style="color: #198810">"</span><span style="color: #198810">1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">2</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">3</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> result1: WriterT[Id, List[String], Option[Int]] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (List("Read 1", "Read 2", "Read 3"), Some(value = 6))</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span><br><span style="color: #d73948">val</span> result2 <span style="color: #d73948">=</span> addAll(<span style="color: #198810">"</span><span style="color: #198810">1</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">3</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> result2: WriterT[Id, List[String], Option[Int]] = WriterT(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   run = (List("Read 1", "Failed on a"), None)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Unfortunately, there aren’t one-size-fits-all approaches to working with monad transformers. The best approach for you may depend on a lot of factors: the size and experience of your team, the complexity of your code base, and so on. You may need to experiment and gather feedback from colleagues to determine whether monad transformers are a good fit.</p>
    <h5>Exercise: Monads: Transform and Roll Out</h5>
    <p>The Autobots, well-known robots in disguise, frequently send messages during battle requesting the power levels of their team mates. This helps them coordinate strategies and launch devastating attacks. The message sending method looks like this:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">getPowerLevel</span>(autobot: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Response</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>Transmissions take time in Earth’s viscous atmosphere, and messages are occasionally lost due to satellite malfunction or sabotage by pesky Decepticons<a id="loc-293" href="#loc-657" role="doc-noteref"><sup>81</sup></a>. <code>Responses</code> are therefore represented as a stack of monads:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Response</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]]</code></pre>
    <p>Optimus Prime is getting tired of the nested for comprehensions in his neural matrix. Help him by rewriting <code>Response</code> using a monad transformer.</p>
    <p>Now test the code by implementing <code>getPowerLevel</code> to retrieve data from a set of imaginary allies. Here’s the data we’ll use:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> powerLevels <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<br>  <span style="color: #198810">"</span><span style="color: #198810">Jazz</span><span style="color: #198810">"</span>      -> <span style="color: #b60157">6</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">Bumblebee</span><span style="color: #198810">"</span> -> <span style="color: #b60157">8</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">Hot Rod</span><span style="color: #198810">"</span>   -> <span style="color: #b60157">10</span><br>)</code></pre>
    <p>If an Autobot isn’t in the <code>powerLevels</code> map, return an error message reporting that they were unreachable. Include the <code>name</code> in the message for good effect.</p>
    <p>Two autobots can perform a special move if their combined power level is greater than 15. Write a second method, <code>canSpecialMove</code>, that accepts the names of two allies and checks whether a special move is possible. If either ally is unavailable, fail with an appropriate error message:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">canSpecialMove</span>(ally1: <span style="color: #4b69c6">String</span>, ally2: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Response</span>[<span style="color: #d73948">Boolean</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>Finally, write a method <code>tacticalReport</code> that takes two ally names and prints a message saying whether they can perform a special move:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">tacticalReport</span>(ally1: <span style="color: #4b69c6">String</span>, ally2: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">???</span></code></pre>
    <p>You should be able to use <code>report</code> as follows:</p>
    <pre><code data-lang="scala">tacticalReport(<span style="color: #198810">"</span><span style="color: #198810">Jazz</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">Bumblebee</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: String = "Jazz and Bumblebee need a recharge."</span><br>tacticalReport(<span style="color: #198810">"</span><span style="color: #198810">Bumblebee</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">Hot Rod</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res13: String = "Bumblebee and Hot Rod are ready to roll out!"</span><br>tacticalReport(<span style="color: #198810">"</span><span style="color: #198810">Jazz</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">Ironhide</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res14: String = "Comms error: Ironhide unreachable"</span></code></pre>
    <h3 id="loc-294">11.4. Conclusions</h3>
    <p>In this chapter we introduced monad transformers, which eliminate the need for nested for comprehensions and pattern matching when working with “stacks” of nested monads.</p>
    <p>Each monad transformer, such as <code>FutureT</code>, <code>OptionT</code> or <code>EitherT</code>, provides the code needed to merge its related monad with other monads. The transformer is a data structure that wraps a monad stack, equipping it with <code>map</code> and <code>flatMap</code> methods that unpack and repack the whole stack.</p>
    <p>The type signatures of monad transformers are written from the inside out, so an <code>EitherT[Option, String, A]</code> is a wrapper for an <code>Option[Either[String, A]]</code>. It is often useful to use type aliases when writing transformer types for deeply nested monads.</p>
    <p>With this look at monad transformers, we have now covered everything we need to know about monads and the sequencing of computations using <code>flatMap</code>. In the next chapter we will switch tack and discuss two new type classes, <code>Semigroupal</code> and <code>Applicative</code>, that support new kinds of operation such as <code>zipping</code> independent values within a context.</p>
    <h2 id="loc-295">12. Semigroupal and Applicative</h2>
    <p>In previous chapters we saw how functors and monads let us sequence operations using <code>map</code> and <code>flatMap</code>. While functors and monads are both immensely useful abstractions, there are certain types of program flow that they cannot represent.</p>
    <p>One such example is form validation. When we validate a form we want to return <em>all</em> the errors to the user, not stop on the first error we encounter. If we model this with a monad like <code>Either</code>, we fail fast and lose errors. For example, consider <code>parseInt</code> below that represents errors with <code>Either</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">parseInt</span>(str: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Either</span>.catchOnly[<span style="color: #4b69c6">NumberFormatException</span>](str.toInt).<br>    leftMap(<span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Couldn't read </span>$str<span style="color: #198810">"</span>)</code></pre>
    <p>Uses of <code>parseInt</code> fail on the first call and don’t go any further.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> parseInt(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span>)<br>  b <span style="color: #d73948">&lt;-</span> parseInt(<span style="color: #198810">"</span><span style="color: #198810">b</span><span style="color: #198810">"</span>)<br>  c <span style="color: #d73948">&lt;-</span> parseInt(<span style="color: #198810">"</span><span style="color: #198810">c</span><span style="color: #198810">"</span>)<br>} <span style="color: #d73948">yield</span> (a + b + c)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Either[String, Int] = Left(value = "Couldn't read a")</span></code></pre>
    <p>Another example is the concurrent evaluation of <code>Futures</code>. If we have several long-running independent tasks, it makes sense to execute them concurrently. However, monadic comprehension only allows us to run them in sequence. <code>map</code> and <code>flatMap</code> aren’t quite capable of capturing what we want because they make the assumption that each computation is <em>dependent</em> on the previous one:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> context2 is dependent on value1:</span><br>context1.flatMap(value1 <span style="color: #d73948">=></span> context2)</code></pre>
    <p>The calls to <code>parseInt</code> and <code>Future.apply</code> above are <em>independent</em> of one another, but <code>map</code> and <code>flatMap</code> can’t exploit this. We need a weaker construct—one that doesn’t guarantee sequencing—to achieve the result we want. In this chapter we will look at three type classes that support this pattern:</p>
    <ul>
      <li>
        <p><code>Semigroupal</code> encompasses the notion of composing pairs of contexts. Cats provides syntax that makes use of <code>Semigroupal</code> and <code>Functor</code> to allow users to sequence functions with multiple arguments.</p>
      </li>
      <li>
        <p><code>Parallel</code> converts types with a <code>Monad</code> instance to a related type with a <code>Semigroupal</code> instance.</p>
      </li>
      <li>
        <p><code>Applicative</code> extends <code>Semigroupal</code> and <code>Functor</code>. It provides a way of applying functions to parameters within a context. <code>Applicative</code> is the source of the <code>pure</code> method we introduced in <a href="#loc-228">Chapter 10</a>.</p>
      </li>
    </ul>
    <p>Applicatives are often formulated in terms of function application, instead of the semigroupal formulation that is emphasised in Cats. This alternative formulation provides a link to much of the published research, and to other languages such as Haskell. We’ll take a look at different formulations of Applicative, as well as the relationships between <code>Semigroupal</code>, <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>, towards the end of the chapter.</p>
    <h3 id="loc-296">12.1. Semigroupal</h3>
    <p><code>cats.Semigroupal</code> is a type class that allows us to combine contexts. If we have two objects of type <code>F[A]</code> and <code>F[B]</code>, a <code>Semigroupal[F]</code> allows us to combine them to form an <code>F[(A, B)]</code>. Its definition in Cats is</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Semigroupal</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">product</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>], fb: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">F</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>}</code></pre>
    <p>The parameters <code>fa</code> and <code>fb</code> are independent of one another: we can compute them in either order before passing them to <code>product</code>. This is in contrast to <code>flatMap</code>, which imposes a strict order on its parameters. This gives us more freedom when defining instances of <code>Semigroupal</code> than we get when defining <code>Monads</code>.</p>
    <h4 id="loc-297">12.1.1. Joining Two Contexts</h4>
    <p>While <code>Semigroup</code> allows us to join values, <code>Semigroupal</code> allows us to join contexts. Let’s join some <code>Options</code> as an example:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Semigroupal<br><br><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">Option</span>].product(<span style="color: #4b69c6">Some</span>(<span style="color: #b60157">123</span>), <span style="color: #4b69c6">Some</span>(<span style="color: #198810">"</span><span style="color: #198810">abc</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Option[Tuple2[Int, String]] = Some(value = (123, "abc"))</span></code></pre>
    <p>If both parameters are instances of <code>Some</code>, we end up with a tuple of the values within. If either parameter evaluates to <code>None</code>, the entire result is <code>None</code>:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">Option</span>].product(<span style="color: #4b69c6">None</span>, <span style="color: #4b69c6">Some</span>(<span style="color: #198810">"</span><span style="color: #198810">abc</span><span style="color: #198810">"</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Option[Tuple2[Nothing, String]] = None</span><br><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">Option</span>].product(<span style="color: #4b69c6">Some</span>(<span style="color: #b60157">123</span>), <span style="color: #4b69c6">None</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Option[Tuple2[Int, Nothing]] = None</span></code></pre>
    <h4 id="loc-298">12.1.2. Joining Three or More Contexts</h4>
    <p>The companion object for <code>Semigroupal</code> defines a set of methods on top of <code>product</code>. For example, the methods <code>tuple2</code> through <code>tuple22</code> generalise <code>product</code> to different arities:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Semigroupal</span>.tuple3(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">2</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Option[Tuple3[Int, Int, Int]] = Some(value = (1, 2, 3))</span><br><span style="color: #4b69c6">Semigroupal</span>.tuple3(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">2</span>), <span style="color: #4b69c6">Option</span>.empty[<span style="color: #d73948">Int</span>])<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Option[Tuple3[Int, Int, Int]] = None</span></code></pre>
    <p>The methods <code>map2</code> through <code>map22</code> apply a user-specified function to the values inside 2 to 22 contexts:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Semigroupal</span>.map3(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">2</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">3</span>))(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Option[Int] = Some(value = 6)</span><br><br><span style="color: #4b69c6">Semigroupal</span>.map2(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Option</span>.empty[<span style="color: #d73948">Int</span>])(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Option[Int] = None</span></code></pre>
    <p>There are also methods <code>contramap2</code> through <code>contramap22</code> and <code>imap2</code> through <code>imap22</code>, that require instances of <code>Contravariant</code> and <code>Invariant</code> respectively.</p>
    <h4 id="loc-299">12.1.3. Semigroupal Laws</h4>
    <p>There is only one law for <code>Semigroupal</code>: the <code>product</code> method must be associative.</p>
    <pre><code data-lang="scala">product(a, product(b, c)) <span style="color: #d73948">==</span> product(product(a, b), c)</code></pre>
    <h3 id="loc-300">12.2. Semigroupal Syntax</h3>
    <p>Cats’ syntax provides shorthands for the methods described above.<a id="loc-301" href="#loc-658" role="doc-noteref"><sup>82</sup></a></p>
    <p>Below is an example of the <code>tupled</code> syntax method applied to a tuple of <code>Options</code>. It uses the <code>Semigroupal</code> for <code>Option</code> to zip the values inside the <code>Options</code>, creating a single <code>Option</code> of a tuple.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br>(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">123</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">abc</span><span style="color: #198810">"</span>)).tupled<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Option[Tuple2[Int, String]] = Some(value = (123, "abc"))</span></code></pre>
    <p>We can use the same trick on tuples of up to 22 values. Cats defines a separate <code>tupled</code> method for each arity.</p>
    <pre><code data-lang="scala">(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">123</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">abc</span><span style="color: #198810">"</span>), <span style="color: #4b69c6">Option</span>(<span style="color: #d73948">true</span>)).tupled<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Option[Tuple3[Int, String, Boolean]] = Some(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = (123, "abc", true)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>In addition to <code>tupled</code>, Cats’ provides a method called <code>mapN</code> that accepts an implicit <code>Functor</code> and a function of the correct arity to combine the values. Let’s start with the following case class.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Cat</span>(name: <span style="color: #4b69c6">String</span>, born: <span style="color: #d73948">Int</span>, color: <span style="color: #4b69c6">String</span>)</code></pre>
    <p>We can use <code>mapN</code> to convert optional values into an instance of the case class as shown below.</p>
    <pre><code data-lang="scala">(<br>  <span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">Garfield</span><span style="color: #198810">"</span>),<br>  <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">1978</span>),<br>  <span style="color: #4b69c6">Option</span>(<span style="color: #198810">"</span><span style="color: #198810">Orange &amp; black</span><span style="color: #198810">"</span>)<br>).mapN(<span style="color: #4b69c6">Cat</span>.apply)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Option[Cat] = Some(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Cat(name = "Garfield", born = 1978, color = "Orange &amp; black")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Of all the methods mentioned here, it is most common to use <code>mapN</code>.</p>
    <p>Internally <code>mapN</code> uses the <code>Semigroupal</code> to extract the values from the <code>Option</code> and the <code>Functor</code> to apply the values to the function.</p>
    <h4 id="loc-302">12.2.1. Fancy Functors and Apply Syntax</h4>
    <p>Cats’ syntax also has <code>contramapN</code> and <code>imapN</code> methods that accept Contravariant and Invariant functors (see <a href="#loc-206">Section 9.6</a>). For example, we can combine <code>Monoids</code> using <code>Invariant</code>. Here’s an example:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monoid<br><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Cat</span>(<br>  name: <span style="color: #4b69c6">String</span>,<br>  yearOfBirth: <span style="color: #d73948">Int</span>,<br>  favoriteFoods: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]<br>)<br><br><span style="color: #d73948">val</span> tupleToCat: (<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>, <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Cat</span> =<br>  <span style="color: #4b69c6">Cat</span>.apply<br><br><span style="color: #d73948">val</span> catToTuple: <span style="color: #4b69c6">Cat</span> <span style="color: #d73948">=></span> (<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>, <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]) =<br>  cat <span style="color: #d73948">=></span> (cat.name, cat.yearOfBirth, cat.favoriteFoods)<br><br>given catMonoid: <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">Cat</span>] <span style="color: #d73948">=</span> (<br>  <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">String</span>],<br>  <span style="color: #4b69c6">Monoid</span>[<span style="color: #d73948">Int</span>],<br>  <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]]<br>).imapN(tupleToCat)(catToTuple)</code></pre>
    <p>Let’s define some Cats.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> garfield   <span style="color: #d73948">=</span> <span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Garfield</span><span style="color: #198810">"</span>, <span style="color: #b60157">1978</span>, <span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">Lasagne</span><span style="color: #198810">"</span>))<br><span style="color: #d73948">val</span> heathcliff <span style="color: #d73948">=</span> <span style="color: #4b69c6">Cat</span>(<span style="color: #198810">"</span><span style="color: #198810">Heathcliff</span><span style="color: #198810">"</span>, <span style="color: #b60157">1988</span>, <span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">Junk Food</span><span style="color: #198810">"</span>))</code></pre>
    <p>Now our <code>Monoid</code> allows us to create “empty” <code>Cats</code>, and add <code>Cats</code> together using the syntax we first saw in <a href="#loc-163">Chapter 8</a>.</p>
    <pre><code data-lang="scala">garfield |+| heathcliff<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Cat = Cat(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   name = "GarfieldHeathcliff",</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   yearOfBirth = 3966,</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   favoriteFoods = List("Lasagne", "Junk Food")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <h3 id="loc-303">12.3. Semigroupal Applied to Different Types</h3>
    <p><code>Semigroupal</code> doesn’t always provide the behaviour we expect, particularly for types that also have instances of <code>Monad</code>. We have seen the behaviour of the <code>Semigroupal</code> for <code>Option</code>. Let’s look at some examples for other types.</p>
    <h4 id="loc-304">12.3.1. Semigroupal Applied to List</h4>
    <p>Combining <code>Lists</code> with <code>Semigroupal</code> produces some potentially unexpected results. We might expect code like the following to <em>zip</em> the lists, but we actually get the cartesian product of their elements:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Semigroupal<br><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">List</span>].product(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>), <span style="color: #4b69c6">List</span>(<span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>))</code></pre>
    <p>This is perhaps surprising. Zipping lists tends to be a more common operation. We’ll see why we get this behaviour in a moment, but let’s first look at <code>Either</code>.</p>
    <h4 id="loc-305">12.3.2. Semigroupal Applied to Either</h4>
    <p>We opened this chapter with a discussion of fail-fast versus accumulating error-handling. We might expect <code>product</code> applied to <code>Either</code> to accumulate errors instead of fail fast. Again, perhaps surprisingly, we find that <code>product</code> implements the same fail-fast behaviour as <code>flatMap</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">A</span>]<br><br><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">ErrorOr</span>].product(<br>  <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">Error 1</span><span style="color: #198810">"</span>)),<br>  <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">Error 2</span><span style="color: #198810">"</span>))<br>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Either[Vector[String], Tuple2[Nothing, Nothing]] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Vector("Error 1")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>In this example <code>product</code> sees the first failure and stops, even though it is possible to examine the second parameter and see that it is also a failure.</p>
    <h4 id="loc-306">12.3.3. Semigroupal Applied to Monads</h4>
    <p>The reason for the surprising results for <code>List</code> and <code>Either</code> is that they are both monads. If we have a monad we can implement <code>product</code> as follows.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Monad<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">product</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Monad</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>], fb: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">F</span>[(<span style="color: #4b69c6">A</span>,<span style="color: #4b69c6">B</span>)] <span style="color: #d73948">=</span><br>  fa.flatMap(a <span style="color: #d73948">=></span> <br>    fb.map(b <span style="color: #d73948">=</span>><br>      (a, b)<br>    )<br>  )</code></pre>
    <p>It would be very strange if we had different semantics for <code>product</code> depending on how we implemented it. To ensure consistent semantics, Cats’ <code>Monad</code> (which extends <code>Semigroupal</code>) provides a standard definition of <code>product</code> in terms of <code>map</code> and <code>flatMap</code> as we showed above.</p>
    <p>So why bother with <code>Semigroupal</code> at all? The answer is that we can create useful data types that have instances of <code>Semigroupal</code> (and <code>Applicative</code>) but not <code>Monad</code>. This frees us to implement <code>product</code> in different ways. We’ll examine this further in a moment when we look at an alternative data type for error handling.</p>
    <h5>Exercise: The Product of Lists</h5>
    <p>Why does <code>product</code> for <code>List</code> produce the Cartesian product? We saw an example above. Here it is again.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">List</span>].product(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>), <span style="color: #4b69c6">List</span>(<span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: List[Tuple2[Int, Int]] = List((1, 3), (1, 4), (2, 3), (2, 4))</span></code></pre>
    <p>We can also write this in terms of <code>tupled</code>.</p>
    <pre><code data-lang="scala">(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>), <span style="color: #4b69c6">List</span>(<span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>)).tupled<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: List[Tuple2[Int, Int]] = List((1, 3), (1, 4), (2, 3), (2, 4))</span></code></pre>
    <h3 id="loc-307">12.4. Parallel</h3>
    <p>In the previous section we saw that when call <code>product</code> on a type that has a <code>Monad</code> instance we get sequential semantics. This makes sense from the point-of-view of keeping consistency with implementations of <code>product</code> in terms of <code>flatMap</code> and <code>map</code>. However it’s not always what we want. The <code>Parallel</code> type class, and its associated syntax, allows us to access alternate semantics for certain monads.</p>
    <p>We’ve seen how the <code>product</code> method on <code>Either</code> stops at the first error. If we define some <code>Left</code> instances of <code>Either</code></p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Semigroupal<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">val</span> error1: <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">Error 1</span><span style="color: #198810">"</span>))<br><span style="color: #d73948">val</span> error2: <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #198810">"</span><span style="color: #198810">Error 2</span><span style="color: #198810">"</span>))</code></pre>
    <p>and then call <code>product</code> on them</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Semigroupal</span>[<span style="color: #4b69c6">ErrorOr</span>].product(error1, error2)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Either[Vector[String], Tuple2[Int, Int]] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Vector("Error 1")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>we see we only get the one <code>Left</code>.</p>
    <p>We can also write this using <code>tupled</code> as a short-cut.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.* <br><br>(error1, error2).tupled</code></pre>
    <p>To collect all the errors we simply replace <code>tupled</code> with its “parallel” version called <code>parTupled</code>.</p>
    <pre><code data-lang="scala">(error1, error2).parTupled<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Either[Vector[String], Tuple2[Int, Int]] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = Vector("Error 1", "Error 2")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>Notice that both errors are returned! This behaviour is not special to using <code>Vector</code> as the error type. Any type that has a <code>Semigroup</code> instance will work. For example, we can use a use <code>List</code> instead</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorOrList</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">val</span> errStr1: <span style="color: #4b69c6">ErrorOrList</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">error 1</span><span style="color: #198810">"</span>))<br><span style="color: #d73948">val</span> errStr2: <span style="color: #4b69c6">ErrorOrList</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Left</span>(<span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">error 2</span><span style="color: #198810">"</span>))</code></pre>
    <p>and <code>parTupled</code> will collect all the errors as before.</p>
    <pre><code data-lang="scala">(errStr1, errStr2).parTupled<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Either[List[String], Tuple2[Int, Int]] = Left(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   value = List("error 1", "error 2")</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>There are many syntax methods provided by <code>Parallel</code> for methods on <code>Semigroupal</code> and related types, but the most commonly used is <code>parMapN</code>.</p>
    <p>Let’s define some successes</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> success1: <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Right</span>(<span style="color: #b60157">1</span>)<br><span style="color: #d73948">val</span> success2: <span style="color: #4b69c6">ErrorOr</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Right</span>(<span style="color: #b60157">2</span>)<br><span style="color: #d73948">val</span> addTwo <span style="color: #d73948">=</span> (x: <span style="color: #d73948">Int</span>, y: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=></span> x + y</code></pre>
    <p>and see how we can use <code>parMapN</code> to apply a function in an error handling situation.</p>
    <pre><code data-lang="scala">(error1, error2).parMapN(addTwo)<br>(success1, success2).parMapN(addTwo)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Either[Vector[String], Int] = Right(value = 3)</span></code></pre>
    <p>It’s time we looked into how <code>Parallel</code> works. The definition below is the core of <code>Parallel</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Parallel</span>[<span style="color: #4b69c6">M</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">type</span> <span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">applicative</span>: <span style="color: #4b69c6">Applicative</span>[<span style="color: #4b69c6">F</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">monad</span>: <span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">M</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">parallel</span>: <span style="color: #4b69c6">~></span>[<span style="color: #4b69c6">M</span>, <span style="color: #4b69c6">F</span>]<br>}</code></pre>
    <p>This tells us if there is a <code>Parallel</code> instance for some type constructor <code>M</code> then:</p>
    <ul>
      <li>there must be a <code>Monad</code> instance for <code>M</code>;</li>
      <li>there is a related type constructor <code>F</code> that has an <code>Applicative</code> instance; and</li>
      <li>we can convert <code>M</code> to <code>F</code>.</li>
    </ul>
    <p>We haven’t seen <code>~></code> before. It’s a type alias for <code>cats.arrow.FunctionK</code> and is what performs the conversion from <code>M</code> to <code>F</code>. A normal function <code>A => B</code> converts values of type <code>A</code> to values of type <code>B</code>. Remember that <code>M</code> and <code>F</code> are not types; they are type constructors. A <code>FunctionK</code> <code>M ~> F</code> is a function from a value with type <code>M[A]</code> to a value with type <code>F[A]</code>. Let’s see a quick example by defining a <code>FunctionK</code> that converts an <code>Option</code> to a <code>List</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.arrow.FunctionK<br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> optionToList</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">FunctionK</span>[<span style="color: #4b69c6">Option</span>, <span style="color: #4b69c6">List</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">A</span>](fa: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    fa <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>.empty[<span style="color: #4b69c6">A</span>]<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(a) <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>(a)<br>    }<br>}</code></pre>
    <p>We can use it like a function to perform the expected transformation.</p>
    <pre><code data-lang="scala">optionToList(<span style="color: #4b69c6">Some</span>(<span style="color: #b60157">1</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: List[Int] = List(1)</span><br>optionToList(<span style="color: #4b69c6">None</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: List[Nothing] = List()</span></code></pre>
    <p>As the type parameter <code>A</code> is generic a <code>FunctionK</code> cannot inspect any values contained with the type constructor <code>M</code>. The conversion must be performed purely in terms of the structure of the type constructors <code>M</code> and <code>F</code>. We can see in <code>optionToList</code> above this is indeed the case.</p>
    <p>So in summary, <code>Parallel</code> allows us to take a type that has a monad instance and convert it to some related type that instead has an applicative (which is equivalent to <code>Semigroupal</code>) instance. This related type will have some useful alternate semantics. We’ve seen the case above where the related applicative for <code>Either</code> allows for accumulation of errors instead of fail-fast semantics.</p>
    <p>Now we’ve seen <code>Parallel</code> it’s time to finally learn about <code>Applicative</code>.</p>
    <h5>Exercise: Parallel List</h5>
    <p>Does <code>List</code> have a <code>Parallel</code> instance? If so, what does the <code>Parallel</code> instance do?</p>
    <h3 id="loc-308">12.5. Apply and Applicative</h3>
    <p>Semigroupals aren’t mentioned frequently in the wider functional programming literature. They provide a subset of the functionality of a related type class called an <strong>applicative functor</strong> (“applicative” for short).</p>
    <p>Cats models applicatives using two type classes. The first, <code>cats.Apply</code>, extends <code>Semigroupal</code> and <code>Functor</code> and adds an <code>ap</code> method that applies a parameter to a function within a context. The second, <code>cats.Applicative</code>, extends <code>Apply</code> and adds the <code>pure</code> method introduced in <a href="#loc-228">Chapter 10</a>. Here’s a simplified definition in code:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Apply</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Semigroupal</span>[<span style="color: #4b69c6">F</span>] <span style="color: #d73948">with</span> <span style="color: #8b41b1">Functor</span>[<span style="color: #4b69c6">F</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">ap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](ff: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>])(fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">product</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>], fb: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">F</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)] <span style="color: #d73948">=</span><br>    ap(map(fa)(a <span style="color: #d73948">=></span> (b: <span style="color: #4b69c6">B</span>) <span style="color: #d73948">=></span> (a, b)))(fb)<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Applicative</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Apply</span>[<span style="color: #4b69c6">F</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](a: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>Breaking this down, the <code>ap</code> method applies a parameter <code>fa</code> to a function <code>ff</code> within a context <code>F[_]</code>. The <code>product</code> method from <code>Semigroupal</code> is defined in terms of <code>ap</code> and <code>map</code>.</p>
    <p>Don’t worry too much about the implementation of <code>product</code>—it’s difficult to read and the details aren’t particuarly important. The main point is that there is a tight relationship between <code>product</code>, <code>ap</code>, and <code>map</code> that allows any one of them to be defined in terms of the other two.</p>
    <p><code>Applicative</code> also introduces the <code>pure</code> method. This is the same <code>pure</code> we saw in <code>Monad</code>. It constructs a new applicative instance from an unwrapped value. In this sense, <code>Applicative</code> is related to <code>Apply</code> as <code>Monoid</code> is related to <code>Semigroup</code>.</p>
    <h4 id="loc-309">12.5.1. The Hierarchy of Sequencing Type Classes</h4>
    <p>With the introduction of <code>Apply</code> and <code>Applicative</code>, we can zoom out and see a whole family of type classes that concern themselves with sequencing computations in different ways. <a href="#loc-310">Figure 11</a> shows the relationship between the type classes covered in this book.</p>
    <figure id="loc-310">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAApQAAAEYCAYAAADiVWYCAAAAAXNSR0IArs4c6QAANj9JREFUeAHt3QeYFEXawPF3YQkKcgKCYgIVBATFAJjgQ0XBhKdiRjxUPDkDBlQQPeTwRFHPeJwgJjCgCIcYzjOgYEBQFEWPaCKLEgSBBYStr966m3FmZ3ZnZmdntsO/n2eZDtXdVb+3XV6qqscCYUEAgXwKmHzejHulFChIWSKzAsQ3M69cl67o+Oa6vlwfAd8KFPq25lQcAZ8KGEPO4YXQFRTkJtcgvl6Irkiu4uuN1lELBLwnUMV7VaJGCCCAAAIIIIAAAn4SIKH0U7SoKwIIIIAAAggg4EEBEkoPBoUqIYAAAggggAACfhIgofRTtKgrAggggAACCCDgQQESSg8GhSohgAACCCCAAAJ+EiCh9FO0qCsCCCCAAAIIIOBBARJKDwaFKiGAAAIIIIAAAn4SIKH0U7SoKwIIIIAAAggg4EEBEkoPBoUqIYAAAggggAACfhIgofRTtKgrAggggAACCCDgQQH+14seDApVQiCZwLp169z/Tq5OnTrJDme9b/Xq1e4a9evXz/pa+bzAZ599JlWqVJGDDz44n7et9Htt375dtm3bllAP/V8OVq9ePWE/OxBAAIFcCtBDmUtdro1ABQgsXLhQjjzySNl5553ld7/7nbRu3VqmTJlSAVeOv8RJJ50knTt3jt/pg637779fhg8f7oOaVmwVR48eLTVr1kz4Ofrooyv2Rkmu9sILLyTZyy4EEAizAD2UYY4+bfeFwHnnnScHHHCAvPbaa1K1alV56qmnZNmyZRVe9wEDBkhxcXGFX5cL5k5AeyKXL18ed4PCwtz+Wtde0R49esi5554bd182EEAg3AL0UIY7/rTe4wI6zK1DuldddZXUq1fP9VBec8017i/02Kr/+uuvMn/+fNm0aVPsblmzZo3b3rhxo6xcuTJ67KeffhLt+YxNII8//njp0qVLtIyuLFmyRObOnSs6vBq7rFq1ym1u3rxZFixYEHvInVMy4S0qKpLIkHqk8Nq1a0XrpYteJ1L3X375xdXNGBMp6j51+5tvvslJMh13Ix9t6PC2TlGI/dFebLXSeMfGLTYGsd4rVqxwriW9lUGfP31OYq+zePHiuO1YLn1eSsZej5f1vMSezzoCCCCAAAIIpCdg/95Of7EJn7HJgjnnnHOMTQ6Tnvi3v/3N7LjjjqZt27amUaNGRrd1sT1Jxs4tNIMGDTL77LOPqVGjhhk6dKgZNmyYadKkiTunTZs25ueff3blL730UtOzZ0+3vmHDBnPccceZPffc0xx00EHuunaOoru2Xtc21YwbN87stNNOxg7Fu3M++eQTs//++7tr165d2xx44IHmq6++csfskLRp1aqVW4/80bFjR3P77be7zbFjxxo7VGv69etn9t13X2OTZ3PIIYcYmxS54xMmTDC77767ad68ubE9cEbrGlkuvPBC07t378hm2p/ahvRCllGptO+fbcHHH3/cxTTZdX788UcXozlz5kQPP/TQQy6WukO9Dz/8cHPRRReZvffe29ieTnPEEUcYm9S78vpMnHHGGaZu3bpG4672dpqFefPNN9262u22227uR5+VsmJf2vMSrViOVnIU34weBgojECYBeijDFG3a6jsB7YF68sknxf5FLnvssYcbZnzvvfei7dD9t9xyi3z++edi/1KXL7/8Uu677z6ZNWuWK6M9kPrz7bffyhdffCFDhgyRDz74QL7++ms3VKq9SU888UT0epGVxx57zPVuam+UnnfWWWdJixYt5Prrr48UkYcfflhswuiuo71f3bt3l169esl3333neiltgitnn3120hdHoheJWZkxY4abK6q9kIsWLRLtdbXJryuhbdC2zps3T2bPni02mXLtjTk9lKvac6jzR2N/Ij29qUD0GdGYqbX2LOqz8+yzz7rTbr75Zvnhhx9E46/lPvroI7H/IJATTjhBbDLqymjPpv7oC1HpxD72eUlVN44jgID/BEgo/RczahwygW7durm/2EeMGOGSvE6dOsmDDz7oFJ5//nn3drMmdhMnThRNNm1vZNxLO5FhbNu7J7ZXSXRoW+di6tCo7SV0Q5olSXWe3H777efeKtdjzZo1c8PSseVuvPFGsb1bssMOO8i0adNcAmJ7GF0RfYGob9++brhcE9J0Fh221cREF9vDKeeff360HZrQakKjS8uWLV0bNbkM+6KJ9ltvvRX3s3Xr1rRYbO+jnHbaaa5sw4YNRV/m0WkTumjSeN1117k46LbGeZdddtHVhCXd2Mc+LwkXYQcCCPheILezt33PQwMQ8IaAHVoWOzzpfrSX8IEHHhCdS6nz5Oxwt+txjNRUk4QOHTpENuM+9a3gatWqRfdpMqjJY8lFX7rQXkA7lOzm52niGumZipTVpDGyLF26VPTrjGK/rkbfRtfEVY+VZ9GkMjLvUq+hPVzvv/++mx+oPWPJ6l2e+/j5HI3lSy+9lNAEnSOb6RJ5FrSH0w55ux7xdK6RKvaRr3OKfV7SuS5lEEDAXwIklP6KF7VFQOzcRJk0aZKTaNq0qXsJQnt/Si6xL1KUPJZqW4ebNaE7/fTTXQJ30003ucSytPPsnEz34oW+wKG9mbroy0RaBz2mCY6da1fa6Un369C8nqvD6Xa+n/Tv318mT57sekT1rXeW0gUiiX2m5npF/QdKgwYN3DSJo446qvSb/O+Ixkhfuikt9ikvQAEEEAiEAEPegQgjjQiqwMsvv+wSyHfeece9Ea1J2t133y32JR3XZPtyirz66qvyr3/9y21r8jVy5MiEr5LJ1EfnQeqculdeecXNobMv4Ljt0q6jiYfOsdQ5mjovU+fl3XXXXdKuXTuxL/W44WrdpwmhfQfD1bnkULi+Ufzhhx9Gj+tQ7sUXX+x6OPWrcfTrk7QX7dNPP036JnFpdQvjfp3OoHNun376adEh8O+//96tp2thX85y81cj3wygUykic3c12dRF51fqPMtUsU/3npRDAAF/C5BQ+jt+1D7gAvpl4zqErcPd2mOo8yd1TuRtt93mWq7Jmg5FX3nllaJz4nbddVd59913xb7RnZWMDlXrnLrI3Ekdatbk8PXXX096XR161eRXX+7Qc3Seow6djh8/3s3D1C9mv+KKK6Rr166ujpqo6rzI2EWH4++99143V0+H3PWrkrTd2gurCbS2tX379jJq1ChRF5ayBR555BGXROrcVJ2Pqv/40Je80ln0Hwb6UpXOo9Vn6tprr3XJvJ6rsdVnUufk6vOoX0FUVuzTuR9lEEAAAQQQQCAzgXJ/SYp+lYt9CaPU820Pn7G9UaUez+TAYYcdZt544424U2wSZ/SrZ1ItNsEwW7ZsSVpMv5YmWR1tUmxs4uLO0TJ2qDzhfPu9ldGvtUk4WI4dNmy+/tqgdJqsjuvXr0+naNIyGit9rpIt9vtCE3aXFfuEwjnekaP4ZvZfO6URCJEAcyhDFGya6m8BHcYsa6nI/8f3Mccc474iSF/K0ReC9Ct99OUL+52PZVXBHSurd1SHrFMtpZXhpY5UconH9St9NH7lXbTnOfYlrtjraI95yaWs2JcsyzYCCARLIL3xj2C1mdYgUJkC2i9TmfdP+972i6zd9w/qkKZ+ZY/9outSk4u0L1pKQf3uSf2uw3QS1lIukfHu/w3/VvTvQN/EN2Mwn52Qo/j6TIHqIpA/gYr+ZZq/mnMnBPwpQMLhkbjlKOEgvsGOr0daRzUQ8J4AL+V4LybUCAEEEEAAAQQQ8JUACaWvwkVlEUAAAQQQQAAB7wmQUHovJtQIAQQQQAABBBDwlQAJpa/CRWURQAABBBBAAAHvCZBQei8m1AgBBBBAAAEEEPCVAAmlr8JFZRFAAAEEEEAAAe8JkFB6LybUCAEEEEAAAQQQ8JUACaWvwkVlEUAAAQQQQAAB7wmQUHovJtQIAV8I/PTTT2L/X9G+qCuVRAABBBDIrQAJZW59uToCgRXo2LGjLFq0KOP2fffdd6I/LAgggAACwREgoQxOLGkJAr4QGDdunMyYMcMXdaWSCCCAAALpCRSmV4xSCCDgd4ERI0ZI586d5cknn5T169fLjTfeKI0bN5a33npLdtppJ3nnnXdkl112kcsuu8yVmTZtmuy7775y9dVXu+Pa/kmTJsnLL78sbdq0iQ53z5s3T9577z354x//6IieffZZad68ubRt21bmz58vo0aNks2bN8uFF14o1apVk9dee0322msvWbFihVx33XV+Z/VV/b///nuXzK9bt07mzp0rN9xwg7z99tsyZcoUOfXUU6V79+6uPePHj5c33nhDGjVqJP3795datWpJac+PrwCoLAII5EyAHsqc0XJhBLwlMHHiRLn11ltd0tCyZUvp1q2bGGNk5syZ0rt3b2nYsKG0a9dOBgwYIB9++KH07dvXJZ4nnniiK/fKK6/IwIED5YILLpCmTZvKDz/84Bqow956LLJogqKJpCaMXbt2leOPP1769OkjX3/9tbvHDjvs4M7Xe7HkV0Bjcs0118juu+8u+gwcd9xxsnz5crn44ovlT3/6k4vRggULZPbs2S7+S5YskcGDB7tKlvb85LcF3A0BBBBAAAEEVMDmcJWzdOnSxUyePDl6c9v7ZGzCYIYOHWpskhHdX69ePbNmzRq3XVxcbGyvpZkzZ44566yzzEMPPRQtZ3shzTfffGP+/e9/G9u7Fd3fq1cv88wzz5gHH3zQ2N7N6P7ISs+ePc3YsWMjm5X2qbHIwSNZae1J58a219nYua+uqH2hytSsWdPY3kq3fcYZZ5h//vOf0cvocdsbbWyvtttX2vMTPcFjKzmKbw4eGS6JQDAEGPIORhxpBQIZC9hk0Q1F64l16tRx5+u+jRs3SpUq/x28KCgocMOeP//8s6xdu1ZatGiR9n10WL1u3bppl6dgfgU0xjoFQX90scmlbNu2TZYuXeqmQ1SvXl00/rov2RL7/CQ7zj4EEAiXAEPe4Yo3rQ25gCaFukyfPt0ljU2aNHHbkT80yWjfvr2bJ6n7bA+k6LBnq1at5IADDnDn6f6VK1fK6tWrdVXq16/vhrh1Xb9GaPHixboqhx9+uLz55pvRuZaRIXJNYLZs2eLK8If3BIYNG+amKowePVp69OgRV8FUz09cYTYQQCBUAvRQhircNDbsAiNHjpThw4fLwoULRROGwsLEXwGPPvqomyf5wAMPiB36ljFjxrgeTH2B45RTTnEvcehLN/qjy2GHHeZ6LnVOXrNmzdyLPbr/hBNOEDsc7o5r0qlJqR0yl9NPP1369esn+uKHvuQT6Q3Vc1gqX0Bf3Bo0aJBMnTrV9U7HPiPpPD+V3wJqgAACCCCAQPAFKm2mWWQOnO0dTKsORUVFScuVdv6mTZuSlt+6daspeY5969vo/MzKXOyjFro5lOl6a+w1RrFLps9P7LmVsZ6j+Ab/NxQtRKCcAondE+W8EKchgIC3BRo0aODmyencuHQWnVOXbCntfH17O9kSmaMXe6xGjRqxm6x7TCBZ7DN9fjzWJKqDAAI5FijI8fW5PAIIxAtoZ038HrYqRUBfOLFLRf8OJL6VEs3Em+Yovok3Yg8CCDgBXsrhQUAAAQQQQAABBBDISoCEMis+TkYAAQQQQAABBBAgoeQZQAABBBBAAAEEEMhKgIQyKz5ORgABBBBAAAEEECCh5BlAAAEEEEAAAQQQyEqAhDIrPk5GAAEEEEAAAQQQIKHkGUAAAQQQQAABBBDISoCEMis+TkYAAQQQQAABBBAgoeQZQAABBBBAAAEEEMhKgIQyKz5ORgABBBBAAAEEECCh5BlAAAEEEEAAAQQQyEqAhDIrPk5GAAEEEEAAAQQQKIAAAQTyKmDyejdulkqgon8HEt9U4vk9XtHxzW/tuRsCCCCAAAIIpCdQ9EKz/9v4XNNVRWObHpPeGZQqKVA0rmknZ2g/Sx5jGwEEEEAAAQQQCIUASWX5w0wyWX47zkQAAQQQQACBgAmQVGYeUJLJzM04AwEEEEAAAQQCLkBSmX6ASSbTt6IkAggggAACCIRMgKQydcBJJlMbUQIBBBBAAAEEQi7gksqxTVdr4hRyioTmk0wmkLADAQQQQAABBBBILkDilOiCSaIJexBAAAEEEEAAgTIFSKB+48HiNwvWEEAAAQQQQACBjARIpEQwyOiRoTACCCCAAAIIIJAoEOaEKsxtT3wS2IMAAggggAACCGQhEMbEKoxtzuIR4VQEEEAAAQQQQCC1QJgSrDC1NXXkKYEAAggggAACCFSgQBgSrTC0sQIfCS6FAAIIIIAAAghkLhDkhCvIbcs80pyBAAIIIIAAAgjkUCCIiVcQ25TDR4BLI4AAAggggAAC2QsEKQELUluyjyxXQAABBBBAAAEE8igQhEQsCG3IY8i5FQIIIIAAAgggUPECfk7I/Fz3io8kV0QAAQQQQAABBCpRwI+JmR/rXIkh5tYIIIAAAggggEDuBfyUoPmprrmPHHdAAAG/CxT4vQHUHwEEPC1gPF278FWO3/nhizktRiAvAoV5uQs3QQCB0AoYQ07pheAXFJBLeiEO1AGBoApUCWrDaBcCCCCAAAIIIIBAfgRIKPPjzF0QQAABBBBAAIHACpBQBja0NAwBBBBAAAEEEMiPAAllfpy5CwIIIIAAAgggEFgBEsrAhpaGIYAAAggggAAC+REgocyPM3dBAAEEEEAAAQQCK0BCGdjQ0jAEEEAAAQQQQCA/AiSU+XHmLggggAACCCCAQGAFSCgDG1oahgACCCCAAAII5EeAhDI/ztwFAQQQQAABBBAIrAAJZWBDS8MQQKCkwJYtW2T79u0ld2e9/corr8hPP/2U9XW4AAIIIOBXARJKv0aOeiOAQEYCc+fOlZo1a0qvXr0yOi+dwmeffbbMmjUrnaKUQQABBAIpQEIZyLDSKAQQKCnw6KOPSqtWrWT8+PGyZs2akofZRgABBBDIQoCEMgs8TkUAAX8IbN68WcaMGSNDhgyRxo0bu/XYmq9bt06Ki4vdriVLlsiPP/4Ye1hSHY8U3rhxo/z888+Rzeinnl9UVBTdZgUBBBBAAAEEEEAgfQHjheWZZ54xDRo0MFu3bjXDhg0zBxxwQFy1zjzzTHPzzTebo48+2jRv3txUr17dXHvttdEyqY7XqFHDvPHGG2by5Mnu3GXLlkXPtcmpsUPt5vPPP4/uq4wVGzKTftgoiQACCCCAAAIIeEegMnKnhHt27NjR9OvXz+1fsWKFKSwsNO+//360nCaMzZo1M4sWLXL7ZsyYYQoKCsxHH33ktlMdjySUWvjAAw80f/7zn915+sedd95pOnXqFN2urBX7SJBQeue/C2qCQOAEGPIOXEhpEAIIxAroyzg2eZRLLrnE7d5tt93k5JNPFp1TGbuceOKJsvfee7td7du3lzZt2sjUqVOjRVIdjxS0PZvu2rY31A2jjxw5Uvr27Rs5zCcCCCAQSIHCQLaKRiGAAAL/Exg1apRUq1ZNrrvuuqiJ7YkU/XnwwQelbt260f2xK7Vr15ZVq1bF7opbL+34BRdcIAMGDJAXX3xRdt55Z7E9kvL73/8+7lw2EEAAgaAJkFAGLaK0BwEEogL6Ms7o0aNdgnfsscdG9+uKJn76os4111wTt1839LyZM2fKeeedl3As1XH9aqI+ffrI8OHDpX79+nLFFVdI1apVk16HnQgggAACCCCAAAKpBSpryqC7r76MU6tWLfPLL78k1KN///7Rl3N0jmTbtm3N6tWrzfr1683AgQPdeStXrnTnpToeO4dST9B5mrqvTp067poJN6+EHTZUzKFM/bxSAgEEyilAD2U54TgNAQS8L6DzJC+66CLR4emSS+/eveWBBx6QDz74wB2yiad06NBBFi9eLA0bNpRJkya5z8h5qY5HyumnztPs3Lmz7LnnnlKvXr3YQ6wjgAACCCCAAAIIZChQCX1xmd9SeyCvvvpqd+KGDRsSLpDqeMkT1q5da3baaSfz5ZdfljxUads2bvRQZvjwUhwBBNIX4C3v9K0oiQACIRDQnsiyllTH9dxHHnlE2rVrJ61bty7rUhxDAAEEAiPAkHdgQklDEECgvAL6Ek1ZiWKq4yXv26JFC7G9miV3s40AAggEVqAgsC2jYQgg4AUBHeL1Qj1CXwf7Re1qwO/80D8JACCQGwGGvHPjylURQAABBBBAAIHQCJBQhibUNBQBBBBAAAEEEMiNAAllbly5KgIIIIAAAgggEBoBEsrQhJqGIoAAAggggAACuREgocyNK1dFAAEEEEAAAQRCI0BCGZpQ01AEEEAAAQQQQCA3AiSUuXHlqggggAACCCCAQGgESChDE2oaigACCCCAAAII5EaAhDI3rlwVAQQQQAABBBAIjQAJZWhCTUMRQAABBBBAAIHcCJBQ5saVqyKAAAIIIIAAAqERIKEMTahpKAIIpCMwfvx4ueyyy2TQoEGyceNGd8qIESNk4cKFMnDgQLnqqqtk0aJF6VyKMggggEBoBEgoQxNqGooAAqkEFixYILNnz5a+ffvKkiVLZPDgwe6UiRMnyq233irdu3eXli1bSrdu3cQYk+pyHEcAAQQQQAABBBCoAAGbd/lv2b59u3n55ZdN586dXeW7dOliJk+eHG1Io0aNjE04o9t+WLGxJAOugAeaSyCAQHKBwuS72YsAAgiET2Dp0qVy4403SvXq1aWgoEC2bduWFKG4uFg2b96c9Bg7EUAAgTAKMOQdxqjTZgQQSCowbNgw6dq1q4wePVp69OgRV2bt2rVue/r06VKlShVp0qRJ3HE2EEAAgTAL0EMZ5ujTdgQQiBOwQ9zuZZypU6eKHdaWwsLffkWOHDlShg8f7l7O0YQz9ljcRdhAAAEEQihQEMI202QEEMifgE4vzN/dKuBOOpStw901atSIXk17Lfv37y8dOnRww+HRAz5a0TbZhd/5PooZVUXATwK//fPbT7WmrggggECOBGrWrJlw5QYNGoju17mVLAgggAACiQL8azXRhD0IIFBxAr7roay4pnvrSvRQeise1AaBoAnwUk7QIkp7EEAAAQQQQACBPAuQUOYZnNshgAACCCCAAAJBEyChDFpEaQ8CCCCAAAIIIJBnARLKPINzOwQQQAABBBBAIGgCJJRBiyjtQQABBBBAAAEE8ixAQplncG6HAAIIIIAAAggETYCEMmgRpT0IIIAAAggggECeBUgo8wzO7RBAAAEEEEAAgaAJkFAGLaK0BwEEEEAAAQQQyLMACWWewbkdAggggAACCCAQNAESyqBFlPYggAACCCCAAAJ5FiChzDM4t0MAAQQQQAABBIImUBC0BtEeBBDwlIDxVG2oDL/zeQYQQAABBBBAAIGyBIomtGy86blmN5VVxgvHtI5FY1s08UJdqAMCCCBQEQIMeVeEItdAAIFKFyga17RT8ZZfPy0oNDMqvTIpKlBQVaYXm20zi8Y2PSZFUQ4jgAACCCCAAAII5ENAk8mNzzVdpZ/5uF9F3KPohWb/5+pMUlkRnFwDAQQQQAABBBAov4Afk8lIa0kqIxJ8IoAAAggggAAClSTg52QyQkZSGZHgEwEEEEAAAQQQyLNAEJLJCBlJZUSCTwQQQAABBBBAIE8CQUomI2QuqRzbdLW2LbKPTwQQQAABBBBAAIEcCAQxmYwwBbltkTbyiQACCCCAAAIIVKpAGBKuMLSxUh8ibo4AAggggAAC4RUIU6IVpraG94mm5QgggAACCCCQV4EwJlhhbHNeHypuhgACCCCAAALhEQhzYhXmtofnCaelCCCAAAIIIJBTARIqEQxy+ohxcQQQQAABBBAIsgCJ1G/RxeI3C9YQQAABBBBAAIG0BEigEpkwSTRhDwIIIIAAAgggkFSAxCkpi9uJTek2HEEAAQQQQAABBJwACVPqBwGj1EaUQAABBBBAAIGQCpAopR94rNK3oiQCCCCAAAIIhESABCnzQGOWuRlnIIAAAggggEBABUiMyh9Y7Mpvx5kIIFCxAgUVezmuhgACKQRMiuMczq9ARf8OJL75jV+qu1V0fFPdj+MIhFagMLQtp+EIVJKAMeQclUQfd9uCgtzkGsQ3jrnSNnIV30prEDdGwOMCVTxeP6qHAAIIIIAAAggg4HEBEkqPB4jqIYAAAggggAACXhcgofR6hKgfAggggAACCCDgcQESSo8HiOohgAACCCCAAAJeFyCh9HqEqB8CCCCAAAIIIOBxARJKjweI6iGAAAIIIIAAAl4XIKH0eoSoHwIIIIAAAggg4HEBEkqPB4jqIYAAAggggAACXhcgofR6hKgfAggggAACCCDgcQESSo8HiOohgAACCCCAAAJeFyCh9HqEqB8CpQhs2bJFtm/fXsrR8u/+7LPP5PPPP3cX2LZtm3z77bflv1gpZ27evFm+/PLLUo6yOx0BjX+yH/1fP8bGMJ1rlSyj1021/Prrrzl5/lLdl+MIIOBNARJKb8aFWiFQpsDcuXOlZs2a0qtXrzLLlefg/fffL8OHD3en6nrTpk1lwYIF5blU9JwXXnghuq4r99xzjxx00EE5SVbjbhTQjV9++cXFX5+Bkj+LFi2S2BimIvjkk0/ku+++ixaLXPvqq6+O7iu5MnXqVKlRo4aMHj265CG2EUAgpAIklCENPM32t8Cjjz4qrVq1kvHjx8uaNWty1pgzzjhDbr/9dtlnn33KfQ/t5ezRo0fc+T179pS///3v0qRJk7j9bGQm8Mwzz8iqVavifvbee++MLnL33XfLzJkzE84ZMWKE6D9cSi7aA9qvXz/RTxYEEEAgIkBCGZHgEwGfCOhw8ZgxY2TIkCHSuHFjtx5bdT2+adMmt0t7mxYuXBj3l/+6deukuLjYHV+yZIn8+OOPsafHrWtyctlll0m1atXi9msv2A8//BC3Tzc0uZk3b17cUOjixYvjtrWcJpJXXnmlVKlSRVavXu2GbnV/ZNFkZeXKlXH11nvqPpbfBHbaaSepX79+3I+aJluSxUbLxfZOxp53/PHHyw033BC7y62PHTtWVqxYIS1btow7pjH75ptvZNmyZXH7M3ne4k5kAwEEEEAAAQRKFbB/72a32F4p06BBA7N161YzbNgwc8ABB8Rd0P6Fb44++mhje5HMvvvua+rVq2cOOeQQY5MxV+7MM880N998syvTvHlzU716dXPttddGr3HhhRea3r17u+033njD2KHN6LGPP/7Y7LfffsYmhKZZs2bmqKOOMmvXrjVff/216dixo9ljjz3c/Vq0aGFsYmHefPNN06hRI+3KMrvttlv0Z5dddjF2KN1d9/LLLzenn3569B668sgjjxg7JO72TZ8+3bVD26L1PeWUU4xNlOPKl2dD61RqlMp/oDxVyfic9evXO9NJkyYlPTc2hqXFxs6BNK1btzY2ATU777yzi40+O5FrT5s2zdiE1cUwchP7jxVj/xFjHnvsMfdMPf744+7QhAkTzO677+7iU1hYaC699NLIKSbV8xYtWMErOYpv+Z8MzkQAAQQQQKACBbL+a1MTN00WdbE9RUb/An///fej19WkQPfZ4XC3T5MvTRyuv/56t61/wWsyaHv83PaMGTNMQUGB+eijj9x2bDISm1AWFRWZvfbay/zlL39x5fSPTz/91K3PmTPHjBs3ztieT6NJx2GHHWZs75Y7ZufbueTHbfzvD62jJpq6zJo1y9VXE9DIcvDBB5t//OMfZsOGDS5Rue+++9y19fpav4EDB0aKlvvTxtT3CaUm43bqQPRn9uzZziM2hmXFRgs3bNjQxS4CGUkoNRG94447XGJvX/5yh+3wuLFTLYydxhCXUL744ovmq6++cmX0fmqr//jQJdXz5grl4I8cxbcCfxVwKQSCJZB8bCRYbaQ1CARGQOe02eRRLrnkEtcm2+snJ598suicythFh0G7d+/udtWuXVvOP/98mTJlSrTIiSeeKJG5du3bt5c2bdqIvmhR1vLBBx+44fEBAwZEix166KFuXYc/zz77bLGJqXtZQ4dL58+f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MmVKqbe5+uqrpWbNmvLLL7+UWiZXBwYPHizPPPNMri7PdRFAAIG8C5BQ5p2cGyKAQD4EjDFy/fXXS3FxccLt5s+fLyNGjEjYzw4EEEAAgfIJkFCWz42zEEDA4wKtWrWSn376SZ5++umEmvbv3186deqUsF93LFmyRJYtW5ZwbM2aNW7fxo0bZc6cObJ58+aEMqtWrZJ58+aJDrmXXDZs2OCGubdt21byENsIIIAAAggggAACZQjYjsL8L48//rg59NBDjR36NnvssYexSWC0Eu+9956pVauW0U9bb7N+/Xp37JNPPjH777+/adKkialdu7Y58MADzVdffeWO2STQVKlSxdx1113ueg0aNDD16tUzdi6kO/7111+bjh07umO6v0WLFsYmpdF7DhkyxFStWtU0bdrUtG7d2n0OHDgwejwfK9rWMuLEIQQQQCArAXoos+LjZAQQ8LJAz549Zdddd5V77rnHVdMmbnLDDTdIv379ZPfdd49WvaioSLp37y69evWS7777zvVStm3bVs4++2yJ9Cjq0Lke0x/twbQJpAwaNMhdY+vWraJzMrV3c/ny5WITVrn//vvdsXfffVduu+02efXVV2XhwoVlzuuMVogVBBBAAAEEEEAAgahAPjrfEu4R6aHUA++8847rkdQew+eff97YBNPYF3GM9iraWroeyrfffttUr17d2Le+o9eaNWuWOz5z5kyjPZRaVns1I8uoUaNM48aNI5txn3ZI3XTr1s3t69Onj2nTpk3c8S5duhh6KKPPCCsIIBAAgcIAtIEmIIAAAqUKHHvssXLccce53kR961vfsLZD2rJy5croOUuXLpU6deqITSqj++zQtNhhatFjBx98cHR/ZGWHHXaIfjWR9mLaBFMmTJggmzZtksWLF8tBBx3kimpv5uGHHx45jU8EEEAgkAIMeQcyrDQKAQRiBe6++24ZM2aMVKtWTXr37h17yK3beZOiL9TokHRk+eyzz9zLNXos1XLllVfK66+/7l4AmjZtWtw9dMhdr82CAAIIBFmAhDLI0aVtCCDgBOxLMi7Ze+6556SwMHFg5qijjhItY1+ecfMjFy1aJPYFHGnXrl20p7EsyhkzZkjXrl2lUaNGsm7dOpk6dWq0+EknneSSzS+++MJ9hdHEiRNFk04WBBBAIEgCJJRBiiZtQQCBUgXOPfdcOeSQQ5Ie157Ll19+2b1U06xZM2nZsqUbuh4/frwUFBQkPSd2p37f5S233CLt27eXs846S0455ZTo4TPOOEMuvfRSd0wTTjsP021HC7CCAAIIBEAg9W/KADSSJiCAQKUJ6MsolXbz8txY/3eMmkTGzqdM5zp6ns6frFu3btLi+ia4zsnUn8pY/pcY8zu/MvC5JwIhEOCXSwiCTBMRqEQB3yWUlWiV01uTUOaUl4sjEHoBhrxD/wgAgAACCCCAAAIIZCdAQpmdH2cjgAACCCCAAAKhFyChDP0jAAACCCCAAAIIIJCdAAlldn6cjQACCCCAAAIIhF6AhDL0jwAACCCAAAIIIIBAdgIklNn5cTYCCCCAAAIIIBB6ARLK0D8CACCAAAIIIIAAAtkJkFBm58fZCCCAAAIIIIBA6AVIKEP/CACAAAIIIIAAAghkJ0BCmZ0fZyOAAAIIIIAAAqEXIKEM/SMAAAIIIIAAAgggkJ0ACWV2fpyNAAIIIIAAAgiEXoCEMvSPAAAIIIAAAggggEB2AiSU2flxNgIIIIAAAgggEHqBgtALAIAAArkUMLm8ONfOWIDf+RmTcQICCKQj8P++vpXz3Cr6ewAAAABJRU5ErkJggg==">
      <figcaption>Figure 11: Monad type class hierarchy</figcaption>
    </figure>
    <p>Each type class in the hierarchy represents a particular set of sequencing semantics, introduces a set of characteristic methods, and defines the functionality of its supertypes in terms of them:</p>
    <ul>
      <li>every monad is an applicative;</li>
      <li>every applicative a semigroupal;</li>
      <li>and so on.</li>
    </ul>
    <p>Because of the lawful nature of the relationships between the type classes, the inheritance relationships are constant across all instances of a type class. <code>Apply</code> defines <code>product</code> in terms of <code>ap</code> and <code>map</code>; <code>Monad</code> defines <code>product</code>, <code>ap</code>, and <code>map</code>, in terms of <code>pure</code> and <code>flatMap</code>.</p>
    <p>To illustrate this let’s consider two hypothetical data types:</p>
    <ul>
      <li>
        <p><code>Foo</code> is a monad. It has an instance of the <code>Monad</code> type class that implements <code>pure</code> and <code>flatMap</code> and inherits standard definitions of <code>product</code>, <code>map</code>, and <code>ap</code>;</p>
      </li>
      <li>
        <p><code>Bar</code> is an applicative functor. It has an instance of <code>Applicative</code> that implements <code>pure</code> and <code>ap</code> and inherits standard definitions of <code>product</code> and <code>map</code>.</p>
      </li>
    </ul>
    <p>What can we say about these two data types without knowing more about their implementation?</p>
    <p>We know strictly more about <code>Foo</code> than <code>Bar</code>: <code>Monad</code> is a subtype of <code>Applicative</code>, so we can guarantee properties of <code>Foo</code> (namely <code>flatMap</code>) that we cannot guarantee with <code>Bar</code>. Conversely, we know that <code>Bar</code> may have a wider range of behaviours than <code>Foo</code>. It has fewer laws to obey (no <code>flatMap</code>), so it can implement behaviours that <code>Foo</code> cannot.</p>
    <p>This demonstrates the classic trade-off of power (in the mathematical sense) versus constraint. The more constraints we place on a data type, the more guarantees we have about its behaviour, but the fewer behaviours we can model.</p>
    <p>Monads happen to be a sweet spot in this trade-off. They are flexible enough to model a wide range of behaviours and restrictive enough to give strong guarantees about those behaviours. However, there are situations where monads aren’t the right tool for the job. Sometimes we want Thai food, and burritos just won’t satisfy.</p>
    <p>Whereas monads impose a strict <em>sequencing</em> on the computations they model, applicatives and semigroupals impose no such restriction. This puts them in a different sweet spot in the hierarchy. We can use them to represent classes of independent computations that monads cannot.</p>
    <p>We choose our semantics by choosing our data structures. If we choose a monad, we get strict sequencing. If we choose an applicative, we lose the ability to <code>flatMap</code>. This is the trade-off enforced by the consistency laws. So choose your types carefully!</p>
    <h3 id="loc-311">12.6. Summary</h3>
    <p>While monads and functors are the most widely used sequencing data types we’ve covered in this book, semigroupals and applicatives are the most general. These type classes provide a generic mechanism to combine values and apply functions within a context, from which we can fashion monads and a variety of other combinators.</p>
    <p><code>Semigroupal</code> and <code>Applicative</code> are most commonly used as a means of combining independent values such as the results of validation rules. Cats provides the <code>Parallel</code> type class to allow to easily switch between a monad and an alternative applicative (or semigroupal) semantics.</p>
    <p>Applicative and semigroupal are both introduced in <a id="loc-312" href="#loc-530" role="doc-biblioref"><em>Applicative Programming with Effects</em> [54</a>]<a id="loc-313" href="#loc-659" role="doc-noteref"><sup>83</sup></a>.</p>
    <h2 id="loc-314">13. Foldable and Traverse</h2>
    <p>In this chapter we’ll look at two type classes that capture iteration over collections:</p>
    <ul>
      <li><code>Foldable</code> abstracts the familiar <code>foldLeft</code> and <code>foldRight</code> operations;</li>
      <li><code>Traverse</code> is a higher-level abstraction that uses <code>Applicatives</code> to iterate with less pain than folding.</li>
    </ul>
    <p>We’ll start by looking at <code>Foldable</code>, and then examine cases where folding becomes complex and <code>Traverse</code> becomes convenient.</p>
    <h3 id="loc-315">13.1. Foldable</h3>
    <p>The <code>Foldable</code> type class captures the <code>foldLeft</code> and <code>foldRight</code> methods we’re used to using with sequences like <code>List</code> and <code>Vector</code>. Using <code>Foldable</code>, we can write generic folds that work with a variety of sequence types. We can also invent new sequences and plug them into our code. <code>Foldable</code> gives us great use cases for <code>Monoids</code> and the <code>Eval</code> monad.</p>
    <h4 id="loc-316">13.1.1. Folds and Folding</h4>
    <p>Let’s start with a quick recap of the general concept of folding a sequence. Here’s an example of a fold.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">show</span>[<span style="color: #4b69c6">A</span>](list: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>  list.foldLeft(<span style="color: #198810">"</span><span style="color: #198810">nil</span><span style="color: #198810">"</span>)((accum, item) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$item<span style="color: #198810"> then </span>$accum<span style="color: #198810">"</span>)</code></pre>
    <p>This produces output like the following.</p>
    <pre><code data-lang="scala">show(<span style="color: #4b69c6">Nil</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: String = "nil"</span><br><br>show(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "3 then 2 then 1 then nil"</span></code></pre>
    <p>There are two parameters we pass to <code>foldLeft</code>: an <strong>accumulator</strong> value and a <strong>binary function</strong> to combine it with each item in the sequence.</p>
    <p>The <code>foldLeft</code> method works recursively down the sequence. Our binary function is called repeatedly for each item, the result of each call becoming the accumulator for the next. When we reach the end of the sequence, the final accumulator becomes our final result.</p>
    <p>Depending on the operation we’re performing, the order in which we fold may be important. Because of this there are two standard variants of fold:</p>
    <ul>
      <li><code>foldLeft</code> traverses from “left” to “right” (start to finish);</li>
      <li><code>foldRight</code> traverses from “right” to “left” (finish to start).</li>
    </ul>
    <p><a href="#loc-317">Figure 12</a> illustrates each direction.</p>
    <figure id="loc-317">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjIwMHB4IiBoZWlnaHQ9IjgwMHB4IiB2aWV3Qm94PSIwIDAgMjIwMCA4MDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQxLjIgKDM1Mzk3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5mb2xkPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImZvbGRyaWdodC1zdW0iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMDcuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICA8ZWxsaXBzZSBpZD0iT3ZhbC0xIiBmaWxsPSIjMDAwMDAwIiBjeD0iMTMxLjY0NjI1OSIgY3k9IjIyLjMxMjkyNTIiIHJ4PSIyMi4zMTI5MjUyIiByeT0iMjIuMzEyOTI1MiI+PC9lbGxpcHNlPgogICAgICAgICAgICA8dGV4dCBpZD0iMSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0Ni44NTcxNDI5IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI2LjAyNDQ4OTgiIHk9IjE0OC44NzA3NDgiPjE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIxIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQ2Ljg1NzE0MjkiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjcuMTQwMTM2MDUiIHk9IjY5My4zMDYxMjIiPjE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTMuOTU5MTg0LDQ0LjYyNTg1MDMgTDIyMC44OTc5NTksMTExLjU2NDYyNiIgaWQ9IkxpbmUiIHN0cm9rZT0iI0Y2QTYyMyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuMzMzMzMzLDQ0LjYyNTg1MDMgTDQyLjM5NDU1NzgsMTExLjU2NDYyNiIgaWQ9IkxpbmUiIHN0cm9rZT0iI0Y2QTYyMyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgIDxlbGxpcHNlIGlkPSJPdmFsLTEiIGZpbGw9IiMwMDAwMDAiIGN4PSIyMzkuODYzOTQ2IiBjeT0iMTMzLjg3NzU1MSIgcng9IjIyLjMxMjkyNTIiIHJ5PSIyMi4zMTI5MjUyIj48L2VsbGlwc2U+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNjIuMTc2ODcxLDE1Ni4xOTA0NzYgTDMyOS4xMTU2NDYsMjIzLjEyOTI1MiIgaWQ9IkxpbmUiIHN0cm9rZT0iI0Y2QTYyMyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0yMTcuNTUxMDIsMTU2LjE5MDQ3NiBMMTUwLjYxMjI0NSwyMjMuMTI5MjUyIiBpZD0iTGluZSIgc3Ryb2tlPSIjRjZBNjIzIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiPjwvcGF0aD4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC0xIiBmaWxsPSIjMDAwMDAwIiBjeD0iMzU1Ljg5MTE1NiIgY3k9IjI0NS40NDIxNzciIHI9IjIyLjMxMjkyNTIiPjwvY2lyY2xlPgogICAgICAgICAgICA8cGF0aCBkPSJNMzc4LjIwNDA4MiwyNjcuNzU1MTAyIEw0MzUuMTEyOTc4LDMyNC42NjM5OTkiIGlkPSJMaW5lIiBzdHJva2U9IiNGNkE2MjMiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMzMzLjU3ODIzMSwyNjcuNzU1MTAyIEwyNjYuNjM5NDU2LDMzNC42OTM4NzgiIGlkPSJMaW5lIiBzdHJva2U9IiNGNkE2MjMiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNNDg4LjY1MzA2MSwzMzQuNjkzODc4IEw0NDQuMDI3MjExLDM3OS4zMTk3MjgiIGlkPSJMaW5lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMTAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTQ4OC42NTMwNjEsMzM0LjY5Mzg3OCBMNDQ0LjAyNzIxMSwzNzkuMzE5NzI4IiBpZD0iTGluZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0NjYuMzQwMTM2LCAzNTcuMDA2ODAzKSByb3RhdGUoOTAuMDAwMDAwKSB0cmFuc2xhdGUoLTQ2Ni4zNDAxMzYsIC0zNTcuMDA2ODAzKSAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTIyNC4yNDQ4OTgsNDkwLjg4NDM1NCBDMjI0LjI0NDg5OCw1MDMuNTI4Nzg2IDIzNC4zMDQ0MzgsNTE0LjA0MTI3MSAyNDYuNTU3ODIzLDUxNC4wNDEyNyBDMjU4LjgxMTIwOSw1MTQuMDQxMjY5IDMyNC4yNzcwMDYsNTE0LjA0MTI2OSAzMzUuODA5NTI0LDUxNC4wNDEyNjkgQzM0Ny4zNDIwNDIsNTE0LjA0MTI2OSAzNTguMTIyNDQ5LDUyMy44MzQwOCAzNTguMTIyNDQ5LDUzNS41MTAyMDMiIGlkPSJQYXRoLTI1IiBzdHJva2U9IiM0OTkwRTIiIHN0cm9rZS13aWR0aD0iNCI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMzU4LjEyMjQ0OSw0OTAuODg0MzU0IEMzNTguMTIyNDQ5LDUwMy41Mjg3ODYgMzY4LjE4MTk4OSw1MTQuMDQxMjcxIDM4MC40MzUzNzQsNTE0LjA0MTI3IEMzOTIuNjg4NzYsNTE0LjA0MTI2OSA0NTguMTU0NTU3LDUxNC4wNDEyNjkgNDY5LjY4NzA3NSw1MTQuMDQxMjY5IEM0ODEuMjE5NTkzLDUxNC4wNDEyNjkgNDkyLDUyMy44MzQwOCA0OTIsNTM1LjUxMDIwMyIgaWQ9IlBhdGgtMjUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MjUuMDYxMjI0LCA1MTMuMTk3Mjc4KSBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC00MjUuMDYxMjI0LCAtNTEzLjE5NzI3OCkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0yMjQuMjQ0ODk4LDQ5MC44ODQzNTQgQzIyNC4yNDQ4OTgsNTAzLjUyODc4NiAyMzQuMzA0NDM4LDUxNC4wNDEyNzEgMjQ2LjU1NzgyMyw1MTQuMDQxMjcgQzI1OC44MTEyMDksNTE0LjA0MTI2OSAzMjQuMjc3MDA2LDUxNC4wNDEyNjkgMzM1LjgwOTUyNCw1MTQuMDQxMjY5IEMzNDcuMzQyMDQyLDUxNC4wNDEyNjkgMzU4LjEyMjQ0OSw1MjMuODM0MDggMzU4LjEyMjQ0OSw1MzUuNTEwMjAzIiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTM1OC4xMjI0NDksNDkwLjg4NDM1NCBDMzU4LjEyMjQ0OSw1MDMuNTI4Nzg2IDM2OC4xODE5ODksNTE0LjA0MTI3MSAzODAuNDM1Mzc0LDUxNC4wNDEyNyBDMzkyLjY4ODc2LDUxNC4wNDEyNjkgNDU4LjE1NDU1Nyw1MTQuMDQxMjY5IDQ2OS42ODcwNzUsNTE0LjA0MTI2OSBDNDgxLjIxOTU5Myw1MTQuMDQxMjY5IDQ5Miw1MjMuODM0MDggNDkyLDUzNS41MTAyMDMiIGlkPSJQYXRoLTI1IiBzdHJva2U9IiM0OTkwRTIiIHN0cm9rZS13aWR0aD0iNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDI1LjA2MTIyNCwgNTEzLjE5NzI3OCkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtNDI1LjA2MTIyNCwgLTUxMy4xOTcyNzgpICI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTExLjU2NDYyNiw1OTAuMTc2ODcxIEMxMTEuNTY0NjI2LDYwMi44MjEzMDMgMTIxLjYyNDE2Niw2MTMuMzMzNzg4IDEzMy44Nzc1NTEsNjEzLjMzMzc4NyBDMTQ2LjEzMDkzNiw2MTMuMzMzNzg2IDIxMS41OTY3MzMsNjEzLjMzMzc4NiAyMjMuMTI5MjUyLDYxMy4zMzM3ODYgQzIzNC42NjE3Nyw2MTMuMzMzNzg2IDI0NS40NDIxNzcsNjIzLjEyNjU5NyAyNDUuNDQyMTc3LDYzNC44MDI3MiIgaWQ9IlBhdGgtMjUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0Ij48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNDUuNDQyMTc3LDU5MC4xNzY4NzEgQzI0NS40NDIxNzcsNjAyLjgyMTMwMyAyNTUuNTAxNzE3LDYxMy4zMzM3ODggMjY3Ljc1NTEwMiw2MTMuMzMzNzg3IEMyODAuMDA4NDg3LDYxMy4zMzM3ODYgMzQ1LjQ3NDI4NCw2MTMuMzMzNzg2IDM1Ny4wMDY4MDMsNjEzLjMzMzc4NiBDMzY4LjUzOTMyMSw2MTMuMzMzNzg2IDM3OS4zMTk3MjgsNjIzLjEyNjU5NyAzNzkuMzE5NzI4LDYzNC44MDI3MiIgaWQ9IlBhdGgtMjUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMTIuMzgwOTUyLCA2MTIuNDg5Nzk1KSBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0zMTIuMzgwOTUyLCAtNjEyLjQ4OTc5NSkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0wLDY5OC4zOTQ1NTggQy0yLjYwOTYxNTYyZS0xMSw3MTEuMDM4OTkgMTAuMDU5NTM5OCw3MjEuNTUxNDc1IDIyLjMxMjkyNTIsNzIxLjU1MTQ3NCBDMzQuNTY2MzEwNiw3MjEuNTUxNDczIDEwMC4wMzIxMDgsNzIxLjU1MTQ3MyAxMTEuNTY0NjI2LDcyMS41NTE0NzMgQzEyMy4wOTcxNDQsNzIxLjU1MTQ3MyAxMzMuODc3NTUxLDczMS4zNDQyODQgMTMzLjg3NzU1MSw3NDMuMDIwNDA3IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTEzMy44Nzc1NTEsNjk4LjM5NDU1OCBDMTMzLjg3NzU1MSw3MTEuMDM4OTkgMTQzLjkzNzA5MSw3MjEuNTUxNDc1IDE1Ni4xOTA0NzYsNzIxLjU1MTQ3NCBDMTY4LjQ0Mzg2Miw3MjEuNTUxNDczIDIzMy45MDk2NTksNzIxLjU1MTQ3MyAyNDUuNDQyMTc3LDcyMS41NTE0NzMgQzI1Ni45NzQ2OTUsNzIxLjU1MTQ3MyAyNjcuNzU1MTAyLDczMS4zNDQyODQgMjY3Ljc1NTEwMiw3NDMuMDIwNDA3IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMC44MTYzMjcsIDcyMC43MDc0ODMpIHNjYWxlKC0xLCAxKSB0cmFuc2xhdGUoLTIwMC44MTYzMjcsIC03MjAuNzA3NDgzKSAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTI1MS4wMjA0MDgsMzg5LjkxODM2NyBMMjUxLjAyMDQwOCw0MzcuODkxMTU2IiBpZD0iTGluZSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIHN0cm9rZS1kYXNoYXJyYXk9IjEwLDEwLDEwLDEwIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMzEuNjQ2MjU5LDI3OS40NjkzODggTDEzMS42NDYyNTksNTI2LjU4NzU1MyIgaWQ9IkxpbmUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBzdHJva2UtZGFzaGFycmF5PSIxMCwxMCwxMCwxMCI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMjEuMTk3Mjc4OSwxNjUuNjczNDY5IEwyMS4xOTcyNzg5LDYzNy4wMzUzNDEiIGlkPSJMaW5lIiBzdHJva2U9IiM0OTkwRTIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWRhc2hhcnJheT0iMTAsMTAsMTAsMTAiPjwvcGF0aD4KICAgICAgICAgICAgPHRleHQgaWQ9IjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDYuODU3MTQyOSIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTE4LjcwNDc2MiIgeT0iMjY0Ljg5Nzk1OSI+MjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDYuODU3MTQyOSIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTE3LjU4OTExNiIgeT0iNTgwLjYyNTg1Ij4yPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iMyIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0Ni44NTcxNDI5IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyMzYuOTYzMjY1IiB5PSIzNzguNjkzODc4Ij4zPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iMyIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0Ni44NTcxNDI5IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyMzYuOTYzMjY1IiB5PSI0ODYuOTExNTY1Ij4zPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iMCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0Ni44NTcxNDI5IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI0NTIuMjgyOTkzIiB5PSI0ODYuOTExNTY1Ij4wPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iMyIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0Ni44NTcxNDI5IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIzNDUuMTgwOTUyIiB5PSI1ODAuNjI1ODUiPjM8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSI1IiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQ2Ljg1NzE0MjkiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjIzMi41MDA2OCIgeT0iNjg5Ljk1OTE4NCI+NTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjYiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDYuODU3MTQyOSIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTE5LjgyMDQwOCIgeT0iNzg4LjEzNjA1NCI+NjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IisiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDYuODU3MTQyOSIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzQ5OTBFMiI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzQyLjk0OTY2IiB5PSI0OTEuMzc0MTUiPis8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIrIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQ2Ljg1NzE0MjkiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiM0OTkwRTIiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjIzMC4yNjkzODgiIHk9IjU4MC42MjU4NSI+KzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IisiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDYuODU3MTQyOSIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzQ5OTBFMiI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTE4LjcwNDc2MiIgeT0iNjkyLjE5MDQ3NiI+KzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICAgICAgPGcgaWQ9ImZvbGRsZWZ0LXN1bSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk5LjAwMDAwMCwgMC4wMDAwMDApIj4KICAgICAgICAgICAgPGVsbGlwc2UgaWQ9Ik92YWwtMSIgZmlsbD0iIzAwMDAwMCIgY3g9IjM4Ny41IiBjeT0iMjQuMjA1NzQ4OSIgcng9IjI0LjIxODc1IiByeT0iMjQuMjA1NzQ4OSI+PC9lbGxpcHNlPgogICAgICAgICAgICA8cGF0aCBkPSJNNDExLjcxODc1LDQ4LjQxMTQ5NzcgTDQ4NC4zNzUsMTIxLjAyODc0NCIgaWQ9IkxpbmUiIHN0cm9rZT0iI0Y2QTYyMyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNjMuMjgxMjUsNDguNDExNDk3NyBMMjkwLjYyNSwxMjEuMDI4NzQ0IiBpZD0iTGluZSIgc3Ryb2tlPSIjRjZBNjIzIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiPjwvcGF0aD4KICAgICAgICAgICAgPGVsbGlwc2UgaWQ9Ik92YWwtMSIgZmlsbD0iIzAwMDAwMCIgY3g9IjUwNC45NjA5MzgiIGN5PSIxNDUuMjM0NDkzIiByeD0iMjQuMjE4NzUiIHJ5PSIyNC4yMDU3NDg5Ij48L2VsbGlwc2U+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik01MjkuMTc5Njg4LDE2OS40NDAyNDIgTDYwMS44MzU5MzgsMjQyLjA1NzQ4OSIgaWQ9IkxpbmUiIHN0cm9rZT0iI0Y2QTYyMyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik00ODAuNzQyMTg3LDE2OS40NDAyNDIgTDQwOC4wODU5MzgsMjQyLjA1NzQ4OSIgaWQ9IkxpbmUiIHN0cm9rZT0iI0Y2QTYyMyIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIj48L3BhdGg+CiAgICAgICAgICAgIDxlbGxpcHNlIGlkPSJPdmFsLTEiIGZpbGw9IiMwMDAwMDAiIGN4PSI2MzAuODk4NDM4IiBjeT0iMjY2LjI2MzIzOCIgcng9IjI0LjIxODc1IiByeT0iMjQuMjA1NzQ4OSI+PC9lbGxpcHNlPgogICAgICAgICAgICA8cGF0aCBkPSJNNjU1LjExNzE4OCwyOTAuNDY4OTg2IEw3MTYuODg2ODcyLDM1Mi4yMDU1MTEiIGlkPSJMaW5lIiBzdHJva2U9IiNGNkE2MjMiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNNjA2LjY3OTY4OCwyOTAuNDY4OTg2IEw1MzQuMDIzNDM4LDM2My4wODYyMzMiIGlkPSJMaW5lIiBzdHJva2U9IiNGNkE2MjMiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNNzc1LDM2My4wODYyMzMgTDcyNi41NjI1LDQxMS40OTc3MzEiIGlkPSJMaW5lIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMTAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTc3NSwzNjMuMDg2MjMzIEw3MjYuNTYyNSw0MTEuNDk3NzMxIiBpZD0iTGluZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjEwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NTAuNzgxMjUwLCAzODcuMjkxOTgyKSByb3RhdGUoOTAuMDAwMDAwKSB0cmFuc2xhdGUoLTc1MC43ODEyNTAsIC0zODcuMjkxOTgyKSAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTI0Mi4xODc1LDY4OS44NjM4NDMgQzI0Mi4xODc1LDcwMy41ODA5MTIgMjUzLjEwNjI2LDcxNC45ODUxOCAyNjYuNDA2MjUsNzE0Ljk4NTE3OSBDMjc5LjcwNjI0LDcxNC45ODUxNzggMzUwLjc2MzY5OSw3MTQuOTg1MTc4IDM2My4yODEyNSw3MTQuOTg1MTc4IEMzNzUuNzk4ODAxLDcxNC45ODUxNzggMzg3LjUsNzI1LjYwODcyMSAzODcuNSw3MzguMjc1MzM5IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTM4Ny41LDY4OS44NjM4NDMgQzM4Ny41LDcwMy41ODA5MTIgMzk4LjQxODc2LDcxNC45ODUxOCA0MTEuNzE4NzUsNzE0Ljk4NTE3OSBDNDI1LjAxODc0LDcxNC45ODUxNzggNDk2LjA3NjE5OSw3MTQuOTg1MTc4IDUwOC41OTM3NSw3MTQuOTg1MTc4IEM1MjEuMTExMzAxLDcxNC45ODUxNzggNTMyLjgxMjUsNzI1LjYwODcyMSA1MzIuODEyNSw3MzguMjc1MzM5IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ2MC4xNTYyNTAsIDcxNC4wNjk1OTEpIHNjYWxlKC0xLCAxKSB0cmFuc2xhdGUoLTQ2MC4xNTYyNTAsIC03MTQuMDY5NTkxKSAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTI0Mi4xODc1LDY4OS44NjM4NDMgQzI0Mi4xODc1LDcwMy41ODA5MTIgMjUzLjEwNjI2LDcxNC45ODUxOCAyNjYuNDA2MjUsNzE0Ljk4NTE3OSBDMjc5LjcwNjI0LDcxNC45ODUxNzggMzUwLjc2MzY5OSw3MTQuOTg1MTc4IDM2My4yODEyNSw3MTQuOTg1MTc4IEMzNzUuNzk4ODAxLDcxNC45ODUxNzggMzg3LjUsNzI1LjYwODcyMSAzODcuNSw3MzguMjc1MzM5IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTM4Ny41LDY4OS44NjM4NDMgQzM4Ny41LDcwMy41ODA5MTIgMzk4LjQxODc2LDcxNC45ODUxOCA0MTEuNzE4NzUsNzE0Ljk4NTE3OSBDNDI1LjAxODc0LDcxNC45ODUxNzggNDk2LjA3NjE5OSw3MTQuOTg1MTc4IDUwOC41OTM3NSw3MTQuOTg1MTc4IEM1MjEuMTExMzAxLDcxNC45ODUxNzggNTMyLjgxMjUsNzI1LjYwODcyMSA1MzIuODEyNSw3MzguMjc1MzM5IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ2MC4xNTYyNTAsIDcxNC4wNjk1OTEpIHNjYWxlKC0xLCAxKSB0cmFuc2xhdGUoLTQ2MC4xNTYyNTAsIC03MTQuMDY5NTkxKSAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTEyMS4wOTM3NSw1NzYuMDk2ODIzIEMxMjEuMDkzNzUsNTg5LjgxMzg5MyAxMzIuMDEyNTEsNjAxLjIxODE2IDE0NS4zMTI1LDYwMS4yMTgxNTkgQzE1OC42MTI0OSw2MDEuMjE4MTU4IDIyOS42Njk5NDksNjAxLjIxODE1OCAyNDIuMTg3NSw2MDEuMjE4MTU4IEMyNTQuNzA1MDUxLDYwMS4yMTgxNTggMjY2LjQwNjI1LDYxMS44NDE3MDEgMjY2LjQwNjI1LDYyNC41MDgzMiIgaWQ9IlBhdGgtMjUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0Ij48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0yNjYuNDA2MjUsNTc2LjA5NjgyMyBDMjY2LjQwNjI1LDU4OS44MTM4OTMgMjc3LjMyNTAxLDYwMS4yMTgxNiAyOTAuNjI1LDYwMS4yMTgxNTkgQzMwMy45MjQ5OSw2MDEuMjE4MTU4IDM3NC45ODI0NDksNjAxLjIxODE1OCAzODcuNSw2MDEuMjE4MTU4IEM0MDAuMDE3NTUxLDYwMS4yMTgxNTggNDExLjcxODc1LDYxMS44NDE3MDEgNDExLjcxODc1LDYyNC41MDgzMiIgaWQ9IlBhdGgtMjUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzkuMDYyNTAwLCA2MDAuMzAyNTcxKSBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0zMzkuMDYyNTAwLCAtNjAwLjMwMjU3MSkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0wLDQ2My41NDAwOTEgQy0yLjgzMjUxMmUtMTEsNDc3LjI1NzE2IDEwLjkxODc2MDIsNDg4LjY2MTQyOCAyNC4yMTg3NSw0ODguNjYxNDI3IEMzNy41MTg3Mzk4LDQ4OC42NjE0MjYgMTA4LjU3NjE5OSw0ODguNjYxNDI2IDEyMS4wOTM3NSw0ODguNjYxNDI2IEMxMzMuNjExMzAxLDQ4OC42NjE0MjYgMTQ1LjMxMjUsNDk5LjI4NDk2OSAxNDUuMzEyNSw1MTEuOTUxNTg4IiBpZD0iUGF0aC0yNSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTE0NS4zMTI1LDQ2My41NDAwOTEgQzE0NS4zMTI1LDQ3Ny4yNTcxNiAxNTYuMjMxMjYsNDg4LjY2MTQyOCAxNjkuNTMxMjUsNDg4LjY2MTQyNyBDMTgyLjgzMTI0LDQ4OC42NjE0MjYgMjUzLjg4ODY5OSw0ODguNjYxNDI2IDI2Ni40MDYyNSw0ODguNjYxNDI2IEMyNzguOTIzODAxLDQ4OC42NjE0MjYgMjkwLjYyNSw0OTkuMjg0OTY5IDI5MC42MjUsNTExLjk1MTU4OCIgaWQ9IlBhdGgtMjUiIHN0cm9rZT0iIzQ5OTBFMiIgc3Ryb2tlLXdpZHRoPSI0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMTcuOTY4NzUwLCA0ODcuNzQ1ODM5KSBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0yMTcuOTY4NzUwLCAtNDg3Ljc0NTgzOSkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik01MDguNTkzNzUsNDIyLjk5NTQ2MSBMNTA4LjU5Mzc1LDYyMy40Mjk2MTQiIGlkPSJMaW5lIiBzdHJva2U9IiM0OTkwRTIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWRhc2hhcnJheT0iMTAsMTAsMTAsMTAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTM4Ny41LDMwMy4xNzcwMDUgTDM4Ny41LDUwOC4zNzc4NDYiIGlkPSJMaW5lIiBzdHJva2U9IiM0OTkwRTIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWRhc2hhcnJheT0iMTAsMTAsMTAsMTAiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTI2Ny42MTcxODgsMTc5LjcyNzY4NSBMMjY3LjYxNzE4OCw0MDAuNjA1MTQ0IiBpZD0iTGluZSIgc3Ryb2tlPSIjNDk5MEUyIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIHN0cm9rZS1kYXNoYXJyYXk9IjEwLDEwLDEwLDEwIj48L3BhdGg+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIxIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjUwLjgzMjA3MjYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjI1MS4xNTY2MjgiIHk9IjE2MS43NjcwMiI+MTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzcyLjI1MDM3OCIgeT0iMjg2LjQyNjYyNiI+MjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjMiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNDkzLjM0NDEyOCIgeT0iNDA2LjI0NTA4MyI+MzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjEiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjUxLjE1NjYyOCIgeT0iNDUzLjQ0NjI5MyI+MTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzcyLjI1MDM3OCIgeT0iNTU5Ljk1MTU4OSI+MjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjMiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNDkzLjM0NDEyOCIgeT0iNjc5Ljc3MDA0NSI+MzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iOC45NjkxMjgyMSIgeT0iNDUzLjQ0NjI5MyI+MDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjEiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTMwLjA2Mjg3OCIgeT0iNTU5Ljk1MTU4OSI+MTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjMiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjUxLjE1NjYyOCIgeT0iNjc5Ljc3MDA0NSI+MzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IisiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzQ5OTBFMiI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTMwLjA2Mjg3OCIgeT0iNDUzLjQ0NjI5MyI+KzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IisiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzQ5OTBFMiI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjUxLjE1NjYyOCIgeT0iNTU5Ljk1MTU4OSI+KzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IisiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzQ5OTBFMiI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzcyLjI1MDM3OCIgeT0iNjc5Ljc3MDA0NSI+KzwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjYiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNTAuODMyMDcyNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzcyLjI1MDM3OCIgeT0iNzg3LjQ4NTYyOCI+NjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==" style="width: 80%">
      <figcaption>Figure 12: Illustration of foldLeft and foldRight</figcaption>
    </figure>
    <p><code>foldLeft</code> and <code>foldRight</code> are equivalent if our binary operation is associative. For example, we can sum a <code>List[Int]</code> by folding in either direction, using <code>0</code> as our accumulator and addition as our operation:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).foldLeft(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Int = 6</span><br><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).foldRight(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Int = 6</span></code></pre>
    <p>If we provide a non-associative operator the order of evaluation makes a difference. For example, if we fold using subtraction, we get different results in each direction:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).foldLeft(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> - <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Int = -6</span><br><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).foldRight(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> - <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Int = 2</span></code></pre>
    <div>
      <h5>Folds on Sequences</h5>
      <p>In <a href="#loc-60">Section 3.3</a> we learned that folds are an abstraction of structural recursion. Here we are looking only at folds on sequences, which are ordered collections of data. Every sequence, regardless of implementation, can be viewed as a list. This means it is either an empty sequence or contains an elements and a sequence. Using this view we can define <code>foldLeft</code> and <code>foldRight</code> for any sequence.</p>
    </div>
    <h5>Exercise: Reflecting on Folds</h5>
    <p>Try using <code>foldLeft</code> and <code>foldRight</code> with an empty list as the accumulator and <code>::</code> as the binary operator. What results do you get in each case?</p>
    <h5>Exercise: Scaf-fold-ing Other Methods</h5>
    <p><code>foldLeft</code> and <code>foldRight</code> are very general methods. We can use them to implement many of the other high-level sequence operations we know. Prove this to yourself by implementing substitutes for <code>List's</code> <code>map</code>, <code>flatMap</code>, <code>filter</code>, and <code>sum</code> methods in terms of <code>foldRight</code>.</p>
    <h4 id="loc-318">13.1.2. Foldable in Cats</h4>
    <p>Cats’ <code>Foldable</code> abstracts <code>foldLeft</code> and <code>foldRight</code> into a type class. Instances of <code>Foldable</code> define these two methods and inherit a host of derived methods. Cats provides out-of-the-box instances of <code>Foldable</code> for a handful of Scala data types: <code>List</code>, <code>Vector</code>, <code>LazyList</code>, and <code>Option</code>.</p>
    <p>We can summon instances as usual using <code>Foldable.apply</code> and call their implementations of <code>foldLeft</code> directly. Let’s define an instance of <code>List</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ints <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>)</code></pre>
    <p>Here is an example using the <code>Foldable</code> instance on <code>List</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Foldable<br><br><span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">List</span>].foldLeft(ints, <span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Int = 6</span></code></pre>
    <p>Other sequences like <code>Vector</code> and <code>LazyList</code> work in the same way. Here is an example using <code>Option</code>, which is treated like a sequence of zero or one elements.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> maybeInt <span style="color: #d73948">=</span> <span style="color: #4b69c6">Option</span>(<span style="color: #b60157">123</span>)<br><br><span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">Option</span>].foldLeft(maybeInt, <span style="color: #b60157">10</span>)(<span style="color: #d73948">_</span> * <span style="color: #d73948">_</span>)</code></pre>
    <h5>13.1.2.1. Folding Right</h5>
    <p><code>Foldable</code> defines <code>foldRight</code> differently to <code>foldLeft</code>, in terms of the <code>Eval</code> monad:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">foldRight</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](fa: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>], lb: <span style="color: #4b69c6">Eval</span>[<span style="color: #4b69c6">B</span>])<br>                     (f: (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">Eval</span>[<span style="color: #4b69c6">B</span>]) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Eval</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Eval</span>[<span style="color: #4b69c6">B</span>]</code></pre>
    <p>Using <code>Eval</code> means folding is always stack safe, even when the collection’s default definition of <code>foldRight</code> is not. For example, the default implementation of <code>foldRight</code> for <code>LazyList</code> is not stack safe. The longer the lazy list, the larger the stack requirements for the fold. A sufficiently large lazy list will trigger a <code>StackOverflowError</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> bigData <span style="color: #d73948">=</span> (<span style="color: #b60157">1</span> to <span style="color: #b60157">100000</span>).to(<span style="color: #4b69c6">LazyList</span>)<br><br>bigData.foldRight(<span style="color: #b60157">0</span><span style="color: #d73948">L</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> java.lang.StackOverflowError ...</span></code></pre>
    <p>Using <code>Foldable</code> forces us to use stack safe operations.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Eval<br><br><span style="color: #d73948">val</span> eval: <span style="color: #4b69c6">Eval</span>[<span style="color: #d73948">Long</span>] =<br>  <span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">LazyList</span>].<br>    foldRight(bigData, <span style="color: #4b69c6">Eval</span>.now(<span style="color: #b60157">0</span><span style="color: #d73948">L</span>)) { (num, eval) <span style="color: #d73948">=</span>><br>      eval.map(<span style="color: #d73948">_</span> + num)<br>    }</code></pre>
    <p>This fixes the overflow exception.</p>
    <pre><code data-lang="scala">eval.value<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Long = 5000050000L</span></code></pre>
    <div>
      <h5>Stack Safety in the Standard Library</h5>
      <p>Stack safety isn’t typically an issue when using the standard library. The most commonly used collection types, such as <code>List</code> and <code>Vector</code>, provide stack safe implementations of <code>foldRight</code>.</p>
      <pre><code data-lang="scala">(<span style="color: #b60157">1</span> to <span style="color: #b60157">100000</span>).toList.foldRight(<span style="color: #b60157">0</span><span style="color: #d73948">L</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br>(<span style="color: #b60157">1</span> to <span style="color: #b60157">100000</span>).toVector.foldRight(<span style="color: #b60157">0</span><span style="color: #d73948">L</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Long = 5000050000L</span></code></pre>
      <p>We’ve called out <code>LazyList</code> because it is an exception to this rule. Whatever data type we’re using, though, it’s useful to know that <code>Eval</code> has our back.</p>
    </div>
    <h5>13.1.2.2. Folding with Monoids</h5>
    <p><code>Foldable</code> provides us with a host of useful methods defined on top of <code>foldLeft</code>. Many of these are copies of familiar methods from the standard library: <code>find</code>, <code>exists</code>, <code>forall</code>, <code>toList</code>, <code>isEmpty</code>, <code>nonEmpty</code>, and so on:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">Option</span>].nonEmpty(<span style="color: #4b69c6">Option</span>(<span style="color: #b60157">42</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Boolean = true</span><br><br><span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">List</span>].find(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))(<span style="color: #d73948">_</span> % <span style="color: #b60157">2</span> <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Option[Int] = Some(value = 2)</span></code></pre>
    <p>In addition to these familiar methods, Cats provides two methods that make use of <code>Monoids</code>:</p>
    <ul>
      <li>
        <p><code>combineAll</code> (and its alias <code>fold</code>) combines all elements in the sequence using a <code>Monoid</code>;</p>
      </li>
      <li>
        <p><code>foldMap</code> maps a user-supplied function over the sequence and combines the results using a <code>Monoid</code>.</p>
      </li>
    </ul>
    <p>For example, we can use <code>combineAll</code> to sum over a <code>List[Int]</code>.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">List</span>].combineAll(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Int = 6</span></code></pre>
    <p>Alternatively, we can use <code>foldMap</code> to convert each <code>Int</code> to a <code>String</code> and concatenate them.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">List</span>].foldMap(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))(<span style="color: #d73948">_</span>.toString)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: String = "123"</span></code></pre>
    <p>Finally, we can compose <code>Foldables</code> to work on nested sequences. Take <code>ints</code> below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> ints <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>), <span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">4</span>, <span style="color: #b60157">5</span>, <span style="color: #b60157">6</span>))</code></pre>
    <p>Composing <code>Foldables</code> for <code>List</code> and <code>Vector</code> supports deep traversal on <code>ints</code>.</p>
    <pre><code data-lang="scala">(<span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">List</span>].compose(using <span style="color: #4b69c6">Foldable</span>[<span style="color: #4b69c6">Vector</span>])).combineAll(ints)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res9: Int = 21</span></code></pre>
    <h5>13.1.2.3. Syntax for Foldable</h5>
    <p>Every method in <code>Foldable</code> is available in syntax form. In each case, the first argument to the method on <code>Foldable</code> becomes the receiver of the method call:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).combineAll<br><span style="color: #74747c">//</span><span style="color: #74747c"> res10: Int = 6</span><br><br><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).foldMap(<span style="color: #d73948">_</span>.toString)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: String = "123"</span></code></pre>
    <div>
      <h5>Explicits over Implicits</h5>
      <p>Remember that Scala will only use an instance of <code>Foldable</code> if the method isn’t explicitly available on the receiver. For example, the following code will use the version of <code>foldLeft</code> defined on <code>List</code></p>
      <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>).foldLeft(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Int = 6</span></code></pre>
      <p>whereas the following generic code will use <code>Foldable</code>.</p>
      <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">sum</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Foldable</span>](values: <span style="color: #4b69c6">F</span>[<span style="color: #d73948">Int</span>]): <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>  values.foldLeft(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)</code></pre>
      <p>We typically don’t need to worry about this distinction. It’s a feature! We call the method we want and the compiler uses a <code>Foldable</code> when needed to ensure our code works as expected. If we need a stack-safe implementation of <code>foldRight</code>, using <code>Eval</code> as the accumulator is enough to force the compiler to select the method from Cats.</p>
    </div>
    <h3 id="loc-319">13.2. Traverse</h3>
    <p><code>foldLeft</code> and <code>foldRight</code> are flexible iteration methods but they require us to do a lot of work to define accumulators and combinator functions. The <code>Traverse</code> type class is a higher level tool that leverages <code>Applicatives</code> to provide a more convenient, more lawful, pattern for iteration.</p>
    <h4 id="loc-320">13.2.1. Traversing with Futures</h4>
    <p>We can demonstrate <code>Traverse</code> using the <code>Future.traverse</code> and <code>Future.sequence</code> methods in the Scala standard library. These methods provide <code>Future</code>-specific implementations of the traverse pattern. As an example, suppose we have a list of server hostnames and a method to poll a host for its uptime.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.*<br><span style="color: #d73948">import</span> scala.concurrent.duration.*<br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global<br><br><span style="color: #d73948">val</span> hostnames <span style="color: #d73948">=</span> <span style="color: #4b69c6">List</span>(<br>  <span style="color: #198810">"</span><span style="color: #198810">alpha.example.com</span><span style="color: #198810">"</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">beta.example.com</span><span style="color: #198810">"</span>,<br>  <span style="color: #198810">"</span><span style="color: #198810">gamma.demo.com</span><span style="color: #198810">"</span><br>)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">getUptime</span>(hostname: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Future</span>(hostname.length * <span style="color: #b60157">60</span>) <span style="color: #74747c">//</span><span style="color: #74747c"> just for demonstration</span></code></pre>
    <p>Now, suppose we want to poll all of the hosts and collect all of their uptimes. We can’t simply <code>map</code> over <code>hostnames</code> because the result—a <code>List[Future[Int]]</code>—would contain more than one <code>Future</code>. We need to reduce the results to a single <code>Future</code> to get something we can block on. Let’s start by doing this manually using a fold.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> allUptimes: <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]] =<br>  hostnames.foldLeft(<span style="color: #4b69c6">Future</span>(<span style="color: #4b69c6">List</span>.empty[<span style="color: #d73948">Int</span>])) {<br>    (accum, host) <span style="color: #d73948">=</span>><br>      <span style="color: #d73948">val</span> uptime <span style="color: #d73948">=</span> getUptime(host)<br>      <span style="color: #d73948">for</span> {<br>        accum  <span style="color: #d73948">&lt;-</span> accum<br>        uptime <span style="color: #d73948">&lt;-</span> uptime<br>      } <span style="color: #d73948">yield</span> accum :+ uptime<br>  }</code></pre>
    <p>Intuitively, we iterate over <code>hostnames</code>, call <code>func</code> for each item, and combine the results into a list. This produces a correct result.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(allUptimes, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: List[Int] = List(1020, 960, 840)</span></code></pre>
    <p>However, the code is fairly unwieldy because of the need to create and combine <code>Futures</code> at every iteration. We can improve on things greatly using <code>Future.traverse</code>, which is tailor-made for this pattern.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> allUptimes: <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]] =<br>  <span style="color: #4b69c6">Future</span>.traverse(hostnames)(getUptime)</code></pre>
    <p>This produces the same result as before, but the code is much clearer and more concise.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(allUptimes, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: List[Int] = List(1020, 960, 840)</span></code></pre>
    <p>Let’s see how it works. If we ignore distractions like <code>CanBuildFrom</code> and <code>ExecutionContext</code>, the implementation of <code>Future.traverse</code> in the standard library looks like this:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">traverse</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](values: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>])<br>    (func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">B</span>]] <span style="color: #d73948">=</span><br>  values.foldLeft(<span style="color: #4b69c6">Future</span>(<span style="color: #4b69c6">List</span>.empty[<span style="color: #4b69c6">B</span>])) { (accum, host) <span style="color: #d73948">=</span>><br>    <span style="color: #d73948">val</span> item <span style="color: #d73948">=</span> func(host)<br>    <span style="color: #d73948">for</span> {<br>      accum <span style="color: #d73948">&lt;-</span> accum<br>      item  <span style="color: #d73948">&lt;-</span> item<br>    } <span style="color: #d73948">yield</span> accum :+ item<br>  }</code></pre>
    <p>This is essentially the same as our example code above. <code>Future.traverse</code> is abstracting away the pain of folding and defining accumulators and combination functions. It gives us a clean high-level interface to do what we want:</p>
    <ul>
      <li>start with a <code>List[A]</code>;</li>
      <li>provide a function <code>A => Future[B]</code>; and</li>
      <li>end up with a <code>Future[List[B]]</code>.</li>
    </ul>
    <p>The standard library also provides another method, <code>Future.sequence</code>, that assumes we’re starting with a <code>List[Future[B]]</code> and doesn’t require us to provide a transformation function.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Future</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">sequence</span>[<span style="color: #4b69c6">B</span>](futures: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">B</span>]]): <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">B</span>]] <span style="color: #d73948">=</span><br>    traverse(futures)(identity)<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br>}</code></pre>
    <p>In this case the intuitive understanding is even simpler:</p>
    <ul>
      <li>start with a <code>List[Future[A]]</code>; and</li>
      <li>end up with a <code>Future[List[A]]</code>.</li>
    </ul>
    <p><code>Future.traverse</code> and <code>Future.sequence</code> solve a very specific problem: they allow us to iterate over a sequence of <code>Futures</code> and accumulate a result. The simplified examples above only work with <code>Lists</code>, but the real <code>Future.traverse</code> and <code>Future.sequence</code> work with any standard Scala collection.</p>
    <p>Cats’ <code>Traverse</code> type class generalises these patterns to work with any type of <code>Applicative</code>: <code>Future</code>, <code>Option</code>, <code>List</code>, and so on. We’ll approach <code>Traverse</code> in the next sections in two steps: first we’ll generalise over the <code>Applicative</code>, then we’ll generalise over the sequence type. We’ll end up with an extremely valuable tool that trivialises many operations involving sequences and other data types.</p>
    <h4 id="loc-321">13.2.2. Traversing with Applicatives</h4>
    <p>If we squint, we’ll see that we can rewrite <code>traverse</code> in terms of an <code>Applicative</code>. Our accumulator from the example above:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Future</span>(<span style="color: #4b69c6">List</span>.empty[<span style="color: #d73948">Int</span>])</code></pre>
    <p>can be generalized to a use of <code>Applicative.pure</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #4b69c6">List</span>.empty[<span style="color: #d73948">Int</span>].pure[<span style="color: #4b69c6">Future</span>]</code></pre>
    <p>Our combinator, which used to be this:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">oldCombine</span>(<br>  accum : <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]],<br>  host  : <span style="color: #4b69c6">String</span><br>): <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]] <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> uptime <span style="color: #d73948">=</span> getUptime(host)<br>  <span style="color: #d73948">for</span> {<br>    accum  <span style="color: #d73948">&lt;-</span> accum<br>    uptime <span style="color: #d73948">&lt;-</span> uptime<br>  } <span style="color: #d73948">yield</span> accum :+ uptime<br>}</code></pre>
    <p>can be rewritten to use <code>mapN</code>, another <code>Applicative</code> operation.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Combining accumulator and hostname using an Applicative:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">newCombine</span>(<br>    accum: <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]],<br>    host: <span style="color: #4b69c6">String</span><br>): <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]] <span style="color: #d73948">=</span><br>  (accum, getUptime(host)).mapN(<span style="color: #d73948">_</span> :+ <span style="color: #d73948">_</span>)</code></pre>
    <p>By substituting these snippets back into the definition of <code>traverse</code> we can generalise it to to work with any <code>Applicative</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Applicative<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">listTraverse</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Applicative</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>]<br>      (list: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">B</span>]] <span style="color: #d73948">=</span><br>  list.foldLeft(<span style="color: #4b69c6">List</span>.empty[<span style="color: #4b69c6">B</span>].pure[<span style="color: #4b69c6">F</span>]) { (accum, item) <span style="color: #d73948">=</span>><br>    (accum, func(item)).mapN(<span style="color: #d73948">_</span> :+ <span style="color: #d73948">_</span>)<br>  }<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">listSequence</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Applicative</span>, <span style="color: #4b69c6">B</span>]<br>      (list: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">B</span>]] <span style="color: #d73948">=</span><br>  listTraverse(list)(identity)</code></pre>
    <p>We can use <code>listTraverse</code> to re-implement our uptime example.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> totalUptime <span style="color: #d73948">=</span> listTraverse(hostnames)(getUptime)</code></pre>
    <p>Once again, we get the same result.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(totalUptime, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: List[Int] = List(1020, 960, 840)</span></code></pre>
    <p>or we can use it with other <code>Applicative</code> data types as shown in the following exercises.</p>
    <h5>Exercise: Traversing with Vectors</h5>
    <p>What is the result of the following?</p>
    <pre><code data-lang="scala">listSequence(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>), <span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>)))</code></pre>
    <p>What about a list of three parameters?</p>
    <pre><code data-lang="scala">listSequence(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>), <span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">3</span>, <span style="color: #b60157">4</span>), <span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">5</span>, <span style="color: #b60157">6</span>)))</code></pre>
    <h5>Exercise: Traversing with Options</h5>
    <p>Here’s an example that uses <code>Options</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">process</span>(inputs: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]) <span style="color: #d73948">=</span><br>  listTraverse(inputs)(n <span style="color: #d73948">=></span> <span style="color: #d73948">if</span>(n % <span style="color: #b60157">2</span> <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) <span style="color: #4b69c6">Some</span>(n) <span style="color: #d73948">else</span> <span style="color: #4b69c6">None</span>)</code></pre>
    <p>What is the return type of this method? What does it produce for the following inputs?</p>
    <pre><code data-lang="scala">process(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">2</span>, <span style="color: #b60157">4</span>, <span style="color: #b60157">6</span>))<br>process(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))</code></pre>
    <h5>Exercise: Traversing with Validated</h5>
    <p>Finally, here is an example that uses <code>Validated</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.Validated<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">ErrorsOr</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Validated</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">process</span>(inputs: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]): <span style="color: #4b69c6">ErrorsOr</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]] <span style="color: #d73948">=</span><br>  listTraverse(inputs) { n <span style="color: #d73948">=</span>><br>    <span style="color: #d73948">if</span>(n % <span style="color: #b60157">2</span> <span style="color: #d73948">==</span> <span style="color: #b60157">0</span>) {<br>      <span style="color: #4b69c6">Validated</span>.valid(n)<br>    } <span style="color: #d73948">else</span> {<br>      <span style="color: #4b69c6">Validated</span>.invalid(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$n<span style="color: #198810"> is not even</span><span style="color: #198810">"</span>))<br>    }<br>  }</code></pre>
    <p>What does this method produce for the following inputs?</p>
    <pre><code data-lang="scala">process(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">2</span>, <span style="color: #b60157">4</span>, <span style="color: #b60157">6</span>))<br>process(<span style="color: #4b69c6">List</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))</code></pre>
    <h4 id="loc-322">13.2.3. Traverse in Cats</h4>
    <p>Our <code>listTraverse</code> and <code>listSequence</code> methods work with any type of <code>Applicative</code>, but they only work with one type of sequence: <code>List</code>. We can generalise over different sequence types using a type class, which brings us to Cats’ <code>Traverse</code>. Here’s the abbreviated definition:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Traverse</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">traverse</span>[<span style="color: #4b69c6">G</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Applicative</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>]<br>      (inputs: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">G</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">G</span>[<span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">sequence</span>[<span style="color: #4b69c6">G</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Applicative</span>, <span style="color: #4b69c6">B</span>]<br>      (inputs: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">G</span>[<span style="color: #4b69c6">B</span>]]): <span style="color: #4b69c6">G</span>[<span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>]] <span style="color: #d73948">=</span><br>    traverse(inputs)(identity)<br>}</code></pre>
    <p>Cats provides instances of <code>Traverse</code> for <code>List</code>, <code>Vector</code>, <code>Stream</code>, <code>Option</code>, <code>Either</code>, and a variety of other types. We can summon instances as usual using <code>Traverse.apply</code> and use the <code>traverse</code> and <code>sequence</code> methods as described in the previous section.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Traverse<br><br><span style="color: #d73948">val</span> totalUptime: <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">List</span>[<span style="color: #d73948">Int</span>]] =<br>  <span style="color: #4b69c6">Traverse</span>[<span style="color: #4b69c6">List</span>].traverse(hostnames)(getUptime)</code></pre>
    <p>We get the same result as before.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(totalUptime, <span style="color: #b60157">1</span>.second)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: List[Int] = List(1020, 960, 840)</span></code></pre>
    <p>There are also syntax versions of the methods.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">val</span> numbers  <span style="color: #d73948">=</span> hostnames.traverse(getUptime)<br><span style="color: #d73948">val</span> numbers2 <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Future</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">2</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">3</span>)).sequence</code></pre>
    <p>As you can see, this is much more compact and readable than the <code>foldLeft</code> code we started with earlier this chapter!</p>
    <h3 id="loc-323">13.3. Conclusions</h3>
    <p>In this chapter we were introduced to <code>Foldable</code> and <code>Traverse</code>, two type classes for iterating over sequences.</p>
    <p><code>Foldable</code> abstracts the <code>foldLeft</code> and <code>foldRight</code> methods we know from collections in the standard library. It adds stack-safe implementations of these methods to a handful of extra data types, and defines a host of situationally useful additions. That said, <code>Foldable</code> doesn’t introduce much that we didn’t already know.</p>
    <p>The real power comes from <code>Traverse</code>, which abstracts and generalises the <code>traverse</code> and <code>sequence</code> methods we know from <code>Future</code>. Using these methods we can turn an <code>F[G[A]]</code> into a <code>G[F[A]]</code> for any <code>F</code> with an instance of <code>Traverse</code> and any <code>G</code> with an instance of <code>Applicative</code>. In terms of the reduction we get in lines of code, <code>Traverse</code> is one of the most powerful patterns in this book. We can reduce <code>folds</code> of many lines down to a single <code>traverse</code>.</p>
    <p>As far as I know, the <code>Foldable</code> type class was cooked up by the Haskell community as a simple abstraction over the well known left- and right-folds. The <code>traverse</code> method, however, comes from <a id="loc-324" href="#loc-509" role="doc-biblioref"><em>The Essence of the Iterator Pattern</em> [33</a>].</p>
    <span id="loc-325"></span>
    <h2 id="loc-326">14. Indexed Types</h2>
    <p>In this chapter we look at <strong>indexed types</strong>. An indexed type is a type constructor, so a type like <code>F[_]</code>, along with a set of types that can fill in the constructor’s type parameters. Let’s say this set of types is <code>Int</code>, <code>String</code>, and <code>Option[Double]</code>. Then, for a type constructor <code>F</code> we can construct an indexed type from the set <code>F[Int]</code>, <code>F[String]</code>, and <code>F[Option[Double]]</code>. The types <code>Int</code>, <code>String</code>, and <code>Option[Double]</code> act as indices into the set <code>F[Int]</code>, <code>F[String]</code>, and <code>F[Option[Double]]</code>, hence the name. The type constructor <code>F</code> can be either data and codata.</p>
    <p>The description above is very abstract, and doesn’t help us understand how indexed types are useful. We’ll see a lot of details and examples in this chapter, but let’s start with a more useful high-level overview. We can think of indexed types as working with proofs that a type parameter is equal to a particular element from the set of indices. Indexed <em>data</em> provides this evidence when we destructure it, while indexed <em>codata</em> requires this evidence when we call methods. Remember the definition of algebras we gave in <a href="#loc-130">Section 6.2</a>, where we said an algebra consists of three different kinds of methods: constructors, combinators, and interpreters. Indexed types allows us to do two things:</p>
    <ul>
      <li>
        <p>We can restrict where constructors and combinators can be used. We can think of representing some state using a type parameter of <code>F</code>, and we can only call particular methods when we are in the correct state. In this case we are working with <strong>indexed codata</strong>.</p>
      </li>
      <li>
        <p>We restrict the types produced by interpreters, enabling us to create type-safe interpreters that guarantee they only encounter particular states when they run. Again these constraints are represented using type parameters. In this case we are working with <strong>indexed data</strong>.</p>
      </li>
    </ul>
    <p>Indexed data are more usually known as <strong>generalized algebraic data types</strong>. Indexed codata are sometimes known as <strong>typestate</strong>. Both can make use of what is known as <strong>phantom types</strong>. Indeed, an early name for indexed data was <strong>first-class phantom types</strong>. As you might expect, indexed data and indexed codata are dual to one another.</p>
    <h3 id="loc-327">14.1. Phantom Types</h3>
    <p>Phantom types are a basic building block of indexed types, so we’ll start with an example of them. A phantom type is simply a type parameter that doesn’t correspond to any value. In the example below, the type parameter <code>A</code> is a phantom type, because there is no value of type <code>A</code>, while <code>B</code> is not because there is a value of that type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> PhantomExample</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](value: <span style="color: #4b69c6">B</span>)</code></pre>
    <p>Phantom types are used to shift constraints to compile time. A simple example involves units of measurement. Most of the world has standardized on SI units, such as metres and litres. However, other measuring systems, such as Imperial units, remain in use some countries or in some niches within countries that otherwise use metric. Differences between different measurement systems can cause problems. A dramatic example is the [loss of the Mars orbiter][mars], caused by two software components using incompatible measurements (one using metric, and one using US customary measurements.)</p>
    <p>With phantom types we can annotate measurements with their units, which in turn can prevent us ever using incompatible units. Let’s work with just length, which is sufficient to show the idea. We’ll start by defining a length type with a phantom type recording the unit, and a method that allows us to add together lengths.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Length</span>[<span style="color: #d73948">Unit</span>](value: <span style="color: #d73948">Double</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(that: <span style="color: #4b69c6">Length</span>[<span style="color: #d73948">Unit</span>]): <span style="color: #4b69c6">Length</span>[<span style="color: #d73948">Unit</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Length</span>[<span style="color: #d73948">Unit</span>](<span style="color: #d73948">this</span>.value + that.value)<br>}</code></pre>
    <p>We’ll need to define a few unit types to use this, and some <code>Lengths</code> using these units.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Metres</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Feet</span><br><br><span style="color: #d73948">val</span> threeMetres <span style="color: #d73948">=</span> <span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">Metres</span>](<span style="color: #b60157">3</span>)<br><span style="color: #d73948">val</span> threeFeetAndRising <span style="color: #d73948">=</span> <span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">Feet</span>](<span style="color: #b60157">3</span>)</code></pre>
    <p>Now we can add <code>Lengths</code> together if they have the same unit.</p>
    <pre><code data-lang="scala">threeMetres + threeMetres<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Length[Metres] = Length(value = 6.0)</span></code></pre>
    <p>However if we try to add <code>Lengths</code> with different units the code will not compile.</p>
    <pre><code data-lang="scala">threeMetres + threeFeetAndRising<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Found:    (repl.MdocSession.MdocApp.threeFeetAndRising :</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   repl.MdocSession.MdocApp.Length[repl.MdocSession.MdocApp.Feet])</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Required: repl.MdocSession.MdocApp.Length[repl.MdocSession.MdocApp.Metres]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> threeMetres + threeFeetAndRising</span><br><span style="color: #74747c">//</span><span style="color: #74747c">               ^^^^^^^^^^^^^^^^^^</span></code></pre>
    <p>There is one big problem with phantom types on their own: there is no way to use the information stored in the phantom type in further processing. For example, force times length gives torque (with the SI unit of newton metres). However we cannot define a <code>*</code> method on <code>Length</code> that can only be called if the <code>Unit</code> is <code>Metre</code> using just the tool of phantom types. Similarly, we cannot define, say, a <code>toString</code> method that uses the <code>Unit</code> type to appropriately print the result. Solving these problems leads us to indexed codata, so let’s now look at that.</p>
    <p>[mars]: <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure">https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure</a></p>
    <h3 id="loc-328">14.2. Indexed Codata</h3>
    <p>The basic idea of indexed codata is to prevent methods being called unless certain conditions, encoded in types, are met. More precisely, methods are guarded by type equalities that callers must prove they satisfy to call a method. The contextual abstraction features, <code>given</code> instances and <code>using</code> clauses, are used to implement this in Scala.</p>
    <p>We’ll start our exploration of indexed codata with a very simple example. We are going to define a switch that can only be turned on when it is off, and off when it is on. Since this is codata, we start with an interface.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Switch</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">on</span>: <span style="color: #4b69c6">Switch</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">off</span>: <span style="color: #4b69c6">Switch</span><br>}</code></pre>
    <p>There are no constraints on this interface as defined; we can turn any switch on, even if it is already on, and vice versa. The first step to implement such a constraint is to add a type parameter, which will hold the state of the <code>Switch</code>. This type parameter doesn’t correspond to any data we store in <code>Switch</code>, so it is a phantom type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Switch</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">on</span>: <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">A</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">off</span>: <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>We are now going to add constraints that say we can only call certain methods when this type parameter corresponds to particular concrete types. It is in this way that indexed codata goes beyond what phantom types alone can do: we can inspect, at compile-time, the type of a type parameter and make decisions based on this type.</p>
    <p>Implementing these constraints has two parts. The first is defining types to represent on and off.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> On</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Off</span></code></pre>
    <p>The second step is to add the constraints to the relevant methods on <code>Switch</code>. Here is how we do it.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Switch</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">on</span>(using ev: <span style="color: #4b69c6">A</span> <span style="color: #4b69c6">=:=</span> <span style="color: #4b69c6">Off</span>): <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">On</span>]<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">off</span>(using ev: <span style="color: #4b69c6">A</span> <span style="color: #4b69c6">=:=</span> <span style="color: #4b69c6">On</span>): <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">Off</span>]<br>}</code></pre>
    <p>We can create an implementation to show it really works.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> SimpleSwitch</span>[<span style="color: #4b69c6">A</span>]() <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Switch</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">on</span>(using ev: <span style="color: #4b69c6">A</span> <span style="color: #4b69c6">=:=</span> <span style="color: #4b69c6">Off</span>): <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">On</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">SimpleSwitch</span>()<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">off</span>(using ev: <span style="color: #4b69c6">A</span> <span style="color: #4b69c6">=:=</span> <span style="color: #4b69c6">On</span>): <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">Off</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">SimpleSwitch</span>()<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> SimpleSwitch</span> {<br>  <span style="color: #d73948">val</span> on: <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">On</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">SimpleSwitch</span>()<br>  <span style="color: #d73948">val</span> off: <span style="color: #4b69c6">Switch</span>[<span style="color: #4b69c6">Off</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">SimpleSwitch</span>()<br>}</code></pre>
    <p>Here are some examples of using it correctly</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">SimpleSwitch</span>.on.off<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Switch[Off] = SimpleSwitch()</span><br><span style="color: #4b69c6">SimpleSwitch</span>.off.on<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Switch[On] = SimpleSwitch()</span></code></pre>
    <p>Incorrect uses fail to compile.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">SimpleSwitch</span>.on.on<br><span style="color: #74747c">//</span><span style="color: #74747c"> error: </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Cannot prove that MdocApp1.this.On =:= MdocApp1.this.Off.</span></code></pre>
    <p>The constraint is made of two parts: using clauses, which we learned about in <a href="#loc-93">Chapter 5</a>, and the [<code>A =:= B</code>][scala.=:=] construction, which is new. <code>=:=</code> represents a type equality. If a given instance <code>A =:= B</code> exists, then the type <code>A</code> is equal to the type <code>B</code>. (Note we can write this with the more familiar prefix notation <code>=:=[A, B]</code> if we prefer.) We never create these instances ourselves; instead the compiler creates them for us. In the method <code>on</code> we are asking the compiler to construct an instance <code>A =:= Off</code>, which can only be done if <code>A</code> <em>is</em> <code>Off</code>. This in turn means we can only call the method when the <code>Switch</code> is <code>Off</code>. This is the core idea of indexed codata: we raise states into types, and restrict method calls to a subset of states.</p>
    <p>This is a different use of contextual abstraction to type classes. Type classes associate operations with types. What we’re doing here is proving some property of a type with respect to another type. More precisely we’re proving that a type parameter is equal to a particular type. The given instance only exists when the compiler can prove this is the case. Hence these given instances are sometimes called <strong>evidence</strong> or <strong>witnesses</strong>. This different view subsumes type classes, as we can think of type classes as evidence that a type implements a certain interface.</p>
    <h5>14.2.0.1. Exercise: Torque {-}</h5>
    <p>In <a href="#loc-327">Section 14.1</a> we saw we could use phantom types to represent units. We also ran into a limitation: we had no way to inspect the phantom types and hence make decisions based on them. Now, with indexed codata, we can do solve this problem.</p>
    <p>Below if the definition of <code>Length</code> we previously used. Your mission is to:</p>
    <ol>
      <li>implement a type <code>Force</code>, parameterized by a phantom type that represents the units of force;</li>
      <li>implement a type <code>Torque</code>, parameterized by a phantom type that represents the units of torque;</li>
      <li>define types <code>Newtons</code> and <code>NewtonMetres</code> to represent force in SI units;</li>
      <li>implement a method <code>*</code> on <code>Force</code> that accepts a <code>Length</code> and returns a <code>Torque</code>. It can only be called if the <code>Force</code> is in <code>Newtons</code> and the <code>Length</code> is in <code>Metres</code>. In this case the <code>Torque</code> is in <code>NewtonMetres</code>. (Torque is force times length.)</li>
    </ol>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Length</span>[<span style="color: #d73948">Unit</span>](value: <span style="color: #d73948">Double</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(that: <span style="color: #4b69c6">Length</span>[<span style="color: #d73948">Unit</span>]): <span style="color: #4b69c6">Length</span>[<span style="color: #d73948">Unit</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Length</span>[<span style="color: #d73948">Unit</span>](<span style="color: #d73948">this</span>.value + that.value)<br>}</code></pre>
    <h4 id="loc-329">14.2.1. API Protocols</h4>
    <p>An API protocol defines the order in which methods must be called. The protocol in the case of <code>Switch</code> is that we can only call <code>off</code> after calling <code>on</code> and vice versa. This protocol is a simple finite state machine, and illustrated in <a href="#loc-330">Figure 13</a>. Many common types have similar protocols. For example, files can only be read once they are opened and cannot be read once they have been closed.</p>
    <figure id="loc-330">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuNDMuMCAoMCkKIC0tPgo8IS0tIFRpdGxlOiBzd2l0Y2hfZnNtIFBhZ2VzOiAxIC0tPgo8c3ZnIHdpZHRoPSIxODlwdCIgaGVpZ2h0PSI1N3B0Igogdmlld0JveD0iMC4wMCAwLjAwIDE4OC41MCA1Ni43NSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CjxnIGlkPSJncmFwaDAiIGNsYXNzPSJncmFwaCIgdHJhbnNmb3JtPSJzY2FsZSgxIDEpIHJvdGF0ZSgwKSB0cmFuc2xhdGUoNCA1Mi43NSkiPgo8dGl0bGU+c3dpdGNoX2ZzbTwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IndoaXRlIiBzdHJva2U9InRyYW5zcGFyZW50IiBwb2ludHM9Ii00LDQgLTQsLTUyLjc1IDE4NC41LC01Mi43NSAxODQuNSw0IC00LDQiLz4KPCEtLSBPbiAtLT4KPGcgaWQ9Im5vZGUxIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5PbjwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSIyNy41IiBjeT0iLTIyLjc1IiByeD0iMjEuNCIgcnk9IjIxLjQiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMjcuNSIgeT0iLTE5LjA1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPk9uPC90ZXh0Pgo8L2c+CjwhLS0gT2ZmIC0tPgo8ZyBpZD0ibm9kZTIiIGNsYXNzPSJub2RlIj4KPHRpdGxlPk9mZjwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSIxNTEuNSIgY3k9Ii0yMi43NSIgcng9IjIzIiByeT0iMjMiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMTUxLjUiIHk9Ii0xOS4wNSIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIj5PZmY8L3RleHQ+CjwvZz4KPCEtLSBPbiYjNDU7Jmd0O09mZiAtLT4KPGcgaWQ9ImVkZ2UxIiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5PbiYjNDU7Jmd0O09mZjwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik00OC42LC0yOC4wMkM1OC4xOCwtMzAuMjcgNjkuODYsLTMyLjYzIDgwLjUsLTMzLjc1IDkzLjI4LC0zNS4wOCAxMDcuMjgsLTMzLjUgMTE5LjM4LC0zMS4xNiIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIxMjAuNDIsLTM0LjUxIDEyOS40NCwtMjguOTYgMTE4LjkzLC0yNy42NyAxMjAuNDIsLTM0LjUxIi8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9Ijg4LjUiIHk9Ii0zNy41NSIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIj5vZmY8L3RleHQ+CjwvZz4KPCEtLSBPbiYjNDU7Jmd0O09mZiAtLT4KPCEtLSBPZmYmIzQ1OyZndDtPbiAtLT4KPGcgaWQ9ImVkZ2UzIiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5PZmYmIzQ1OyZndDtPbjwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xMzAuODEsLTEyLjU2QzExNi45LC02LjU2IDk3Ljc0LC0wLjcgODAuNSwtMy43NSA3Mi42MSwtNS4xNSA2NC4zMywtNy42NSA1Ni43NywtMTAuMzkiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iNTUuMzgsLTcuMTggNDcuMzIsLTE0LjA2IDU3LjkxLC0xMy43IDU1LjM4LC03LjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9Ijg4LjUiIHk9Ii03LjU1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPm9uPC90ZXh0Pgo8L2c+CjwvZz4KPC9zdmc+Cg==">
      <figcaption>Figure 13: The switch API protocol</figcaption>
    </figure>
    <p>Indexed codata allows us to enforce API protocols at compile-time. Often these protocols are finite-state machines. We can represent these protocols with a single type parameter that represents the state, as we did with <code>Switch</code>. We can also use multiple type parameters if that makes for a more convenient representation.</p>
    <p>Let’s see an example using multiple type parameters. We’re going to build an API that represents a very limited subset of [HTML][html], the language the defines web pages. An example of HTML is below.</p>
    <pre><code data-lang="html">&lt;!<span style="color: #d73948">DOCTYPE</span> <span style="color: #d73948">html</span>><br>&lt;<span style="color: #4b69c6">html</span>><br>  &lt;<span style="color: #4b69c6">head</span>>&lt;<span style="color: #4b69c6">title</span>>Our Amazing Web Page&lt;/<span style="color: #4b69c6">title</span>>&lt;/<span style="color: #4b69c6">head</span>><br>  &lt;<span style="color: #4b69c6">body</span>><br>    &lt;<span style="color: #4b69c6">h1</span>>This Is Our Amazing Web Page&lt;/<span style="color: #4b69c6">h1</span>><br>    &lt;<span style="color: #4b69c6">p</span>>Please be in awe of its &lt;<span style="color: #4b69c6">strong</span>>amazingness&lt;/<span style="color: #4b69c6">strong</span>>&lt;/<span style="color: #4b69c6">p</span>><br>  &lt;/<span style="color: #4b69c6">body</span>><br>&lt;/<span style="color: #4b69c6">html</span>></code></pre>
    <p>In HTML the content of the page is marked up with tags, like <code>&lt;h1></code>, that give it meaning. For example, <code>&lt;h1></code> means a heading at level one, and <code>&lt;p></code> means a paragraph. An opening tag is closed by a corresponding closing tag, such as <code>&lt;/h1></code> for <code>&lt;h1></code> and <code>&lt;/p></code> for <code>&lt;p></code>.</p>
    <p>There are several rules for valid HTML[^valid-html]. We’re going to focus on the following:</p>
    <ol>
      <li>Within the <code>html</code> tag there can only be a <code>head</code> and a <code>body</code> tag, in that order.</li>
      <li>Within the <code>head</code> tag there must be exactly one <code>title</code>, and there can be any other number of allowed tags (of which we’re only going to model <code>link</code>).</li>
      <li>Within the <code>body</code> there can be any number of allowed tags (of which we are only going to model <code>h1</code> and <code>p</code>).</li>
    </ol>
    <p>We’re going to use a Church-encoded representation for HTML, so tags are created by method calls. <a href="#loc-331">Figure 14</a> shows the finite state machine representation of the API protocol. I find it easier to read as a regular expression, which we can write down as</p>
    <figure id="loc-331">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuNDMuMCAoMCkKIC0tPgo8IS0tIFRpdGxlOiBodG1sX2ZzbSBQYWdlczogMSAtLT4KPHN2ZyB3aWR0aD0iNTg1cHQiIGhlaWdodD0iMTUycHQiCiB2aWV3Qm94PSIwLjAwIDAuMDAgNTg0Ljk3IDE1Mi4yNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CjxnIGlkPSJncmFwaDAiIGNsYXNzPSJncmFwaCIgdHJhbnNmb3JtPSJzY2FsZSgxIDEpIHJvdGF0ZSgwKSB0cmFuc2xhdGUoNCAxNDguMjcpIj4KPHRpdGxlPmh0bWxfZnNtPC90aXRsZT4KPHBvbHlnb24gZmlsbD0id2hpdGUiIHN0cm9rZT0idHJhbnNwYXJlbnQiIHBvaW50cz0iLTQsNCAtNCwtMTQ4LjI3IDU4MC45NywtMTQ4LjI3IDU4MC45Nyw0IC00LDQiLz4KPCEtLSBIZWFkIC0tPgo8ZyBpZD0ibm9kZTEiIGNsYXNzPSJub2RlIj4KPHRpdGxlPkhlYWQ8L3RpdGxlPgo8ZWxsaXBzZSBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBjeD0iMjguOTciIGN5PSItNDIuMDUiIHJ4PSIyOS41IiByeT0iMjkuNSIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIyOC45NyIgeT0iLTM4LjM1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPkhlYWQ8L3RleHQ+CjwvZz4KPCEtLSBMaW5rMSAtLT4KPGcgaWQ9Im5vZGUyIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5MaW5rMTwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSIxMjEuOTciIGN5PSItODEuMDUiIHJ4PSIyNy4xIiByeT0iMjcuMSIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIxMjEuOTciIHk9Ii03Ny4zNSIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIj5MaW5rPC90ZXh0Pgo8L2c+CjwhLS0gSGVhZCYjNDU7Jmd0O0xpbmsxIC0tPgo8ZyBpZD0iZWRnZTEiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPkhlYWQmIzQ1OyZndDtMaW5rMTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik01Ni4yOSwtNTMuMzNDNjUuOTIsLTU3LjQ2IDc2Ljk1LC02Mi4xOCA4Ny4xNCwtNjYuNTUiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iODYuMDEsLTY5Ljg3IDk2LjU4LC03MC42IDg4Ljc3LC02My40NCA4Ni4wMSwtNjkuODciLz4KPC9nPgo8IS0tIFRpdGxlIC0tPgo8ZyBpZD0ibm9kZTMiIGNsYXNzPSJub2RlIj4KPHRpdGxlPlRpdGxlPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9IjIxMS45NyIgY3k9Ii00Mi4wNSIgcng9IjI3LjEiIHJ5PSIyNy4xIi8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjIxMS45NyIgeT0iLTM4LjM1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPlRpdGxlPC90ZXh0Pgo8L2c+CjwhLS0gSGVhZCYjNDU7Jmd0O1RpdGxlIC0tPgo8ZyBpZD0iZWRnZTIiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPkhlYWQmIzQ1OyZndDtUaXRsZTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik01OC4yNSwtNDIuMDVDODkuNjEsLTQyLjA1IDE0MC4yOCwtNDIuMDUgMTc0LjU3LC00Mi4wNSIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIxNzQuNjUsLTQ1LjU1IDE4NC42NSwtNDIuMDUgMTc0LjY1LC0zOC41NSAxNzQuNjUsLTQ1LjU1Ii8+CjwvZz4KPCEtLSBMaW5rMSYjNDU7Jmd0O0xpbmsxIC0tPgo8ZyBpZD0iZWRnZTMiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPkxpbmsxJiM0NTsmZ3Q7TGluazE8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNMTA1Ljc5LC0xMDMuNDJDMTAzLjA0LC0xMTUuNDIgMTA4LjQ0LC0xMjYuMzUgMTIxLjk3LC0xMjYuMzUgMTMxLjQ5LC0xMjYuMzUgMTM2Ljk4LC0xMjAuOTUgMTM4LjQ1LC0xMTMuNTciLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMTQxLjk0LC0xMTMuMzIgMTM4LjE1LC0xMDMuNDIgMTM0Ljk0LC0xMTMuNTIgMTQxLjk0LC0xMTMuMzIiLz4KPC9nPgo8IS0tIExpbmsxJiM0NTsmZ3Q7VGl0bGUgLS0+CjxnIGlkPSJlZGdlNCIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+TGluazEmIzQ1OyZndDtUaXRsZTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xNDcuNDgsLTcwLjE5QzE1Ni43MywtNjYuMDkgMTY3LjQyLC02MS4zNSAxNzcuMzYsLTU2Ljk1Ii8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjE3OC44NywtNjAuMTEgMTg2LjU5LC01Mi44NiAxNzYuMDMsLTUzLjcxIDE3OC44NywtNjAuMTEiLz4KPC9nPgo8IS0tIExpbmsyIC0tPgo8ZyBpZD0ibm9kZTQiIGNsYXNzPSJub2RlIj4KPHRpdGxlPkxpbmsyPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9IjMwMi45NyIgY3k9Ii04MS4wNSIgcng9IjI3LjEiIHJ5PSIyNy4xIi8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjMwMi45NyIgeT0iLTc3LjM1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPkxpbms8L3RleHQ+CjwvZz4KPCEtLSBUaXRsZSYjNDU7Jmd0O0xpbmsyIC0tPgo8ZyBpZD0iZWRnZTUiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPlRpdGxlJiM0NTsmZ3Q7TGluazI8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNMjM3LjI5LC01Mi43MUMyNDYuOTEsLTU2LjkyIDI1OC4xMSwtNjEuODMgMjY4LjQ4LC02Ni4zNyIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIyNjcuMTIsLTY5LjYgMjc3LjY4LC03MC40MSAyNjkuOTMsLTYzLjE5IDI2Ny4xMiwtNjkuNiIvPgo8L2c+CjwhLS0gQm9keSAtLT4KPGcgaWQ9Im5vZGU1IiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5Cb2R5PC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9IjM5NS45NyIgY3k9Ii00Mi4wNSIgcng9IjI5LjgiIHJ5PSIyOS44Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjM5NS45NyIgeT0iLTM4LjM1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPkJvZHk8L3RleHQ+CjwvZz4KPCEtLSBUaXRsZSYjNDU7Jmd0O0JvZHkgLS0+CjxnIGlkPSJlZGdlNiIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+VGl0bGUmIzQ1OyZndDtCb2R5PC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTIzOS40NCwtNDIuMDVDMjY5Ljk5LC00Mi4wNSAzMjAuNTUsLTQyLjA1IDM1NS42OSwtNDIuMDUiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMzU2LjA3LC00NS41NSAzNjYuMDcsLTQyLjA1IDM1Ni4wNywtMzguNTUgMzU2LjA3LC00NS41NSIvPgo8L2c+CjwhLS0gTGluazImIzQ1OyZndDtMaW5rMiAtLT4KPGcgaWQ9ImVkZ2U3IiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5MaW5rMiYjNDU7Jmd0O0xpbmsyPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTI4Ni43OSwtMTAzLjQyQzI4NC4wNCwtMTE1LjQyIDI4OS40NCwtMTI2LjM1IDMwMi45NywtMTI2LjM1IDMxMi40OSwtMTI2LjM1IDMxNy45OCwtMTIwLjk1IDMxOS40NSwtMTEzLjU3Ii8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjMyMi45NCwtMTEzLjMyIDMxOS4xNSwtMTAzLjQyIDMxNS45NCwtMTEzLjUyIDMyMi45NCwtMTEzLjMyIi8+CjwvZz4KPCEtLSBMaW5rMiYjNDU7Jmd0O0JvZHkgLS0+CjxnIGlkPSJlZGdlOCIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+TGluazImIzQ1OyZndDtCb2R5PC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTMyOC4zNiwtNzAuNkMzMzcuNzksLTY2LjU2IDM0OC43OCwtNjEuODUgMzU5LjA4LC01Ny40MyIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIzNjAuNDYsLTYwLjY1IDM2OC4yOCwtNTMuNDkgMzU3LjcxLC01NC4yMSAzNjAuNDYsLTYwLjY1Ii8+CjwvZz4KPCEtLSBIMSAtLT4KPGcgaWQ9Im5vZGU2IiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5IMTwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSI0ODMuOTciIGN5PSItNzcuMDUiIHJ4PSIyMS40IiByeT0iMjEuNCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI0ODMuOTciIHk9Ii03My4zNSIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIj5IMTwvdGV4dD4KPC9nPgo8IS0tIEJvZHkmIzQ1OyZndDtIMSAtLT4KPGcgaWQ9ImVkZ2U5IiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5Cb2R5JiM0NTsmZ3Q7SDE8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNNDI0LjE4LC01My4xMkM0MzMuODUsLTU3LjA2IDQ0NC43NiwtNjEuNSA0NTQuNTMsLTY1LjQ4Ii8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjQ1My4yNSwtNjguNzMgNDYzLjgzLC02OS4yNiA0NTUuODksLTYyLjI1IDQ1My4yNSwtNjguNzMiLz4KPC9nPgo8IS0tIFAgLS0+CjxnIGlkPSJub2RlNyIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+UDwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSI1NTguOTciIGN5PSItNzcuMDUiIHJ4PSIxOCIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjU1OC45NyIgeT0iLTczLjM1IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPlA8L3RleHQ+CjwvZz4KPCEtLSBCb2R5JiM0NTsmZ3Q7UCAtLT4KPGcgaWQ9ImVkZ2UxMCIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+Qm9keSYjNDU7Jmd0O1A8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNNDI2LjExLC0zOS43NEM0NDguMywtMzguODUgNDc5LjM1LC0zOS40OSA1MDUuNDIsLTQ3LjA1IDUxNS45LC01MC4wOSA1MjYuNTMsLTU1LjYxIDUzNS40NywtNjEuMDkiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iNTMzLjc5LC02NC4xNyA1NDQuMDgsLTY2LjY4IDUzNy42LC01OC4zIDUzMy43OSwtNjQuMTciLz4KPC9nPgo8IS0tIEgxJiM0NTsmZ3Q7SDEgLS0+CjxnIGlkPSJlZGdlMTIiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPkgxJiM0NTsmZ3Q7SDE8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNNDcxLjE5LC05NC40OUM0NjcuODYsLTEwNS43MSA0NzIuMTIsLTExNi41IDQ4My45NywtMTE2LjUgNDkyLjEyLC0xMTYuNSA0OTYuNjgsLTExMS40IDQ5Ny42NSwtMTA0LjU2Ii8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjUwMS4xMywtMTA0LjE0IDQ5Ni43NSwtOTQuNDkgNDk0LjE1LC0xMDQuNzYgNTAxLjEzLC0xMDQuMTQiLz4KPC9nPgo8IS0tIEgxJiM0NTsmZ3Q7UCAtLT4KPGcgaWQ9ImVkZ2UxMSIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+SDEmIzQ1OyZndDtQPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTUwNC45MiwtNzAuOTZDNTEzLjA4LC03MC4yNiA1MjIuNjUsLTcwLjEyIDUzMS4zOSwtNzAuNTMiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iNTMxLjI2LC03NC4wMyA1NDEuNSwtNzEuMyA1MzEuNzksLTY3LjA1IDUzMS4yNiwtNzQuMDMiLz4KPC9nPgo8IS0tIFAmIzQ1OyZndDtIMSAtLT4KPGcgaWQ9ImVkZ2UxMyIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+UCYjNDU7Jmd0O0gxPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTU0MS41LC04Mi44QzUzMy43MSwtODMuNjcgNTI0LjE1LC04My45NyA1MTUuMTMsLTgzLjcxIi8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjUxNS4xLC04MC4yIDUwNC45MiwtODMuMTQgNTE0LjcxLC04Ny4xOSA1MTUuMSwtODAuMiIvPgo8L2c+CjwhLS0gUCYjNDU7Jmd0O1AgLS0+CjxnIGlkPSJlZGdlMTQiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPlAmIzQ1OyZndDtQPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTU0Ny4wNSwtOTAuNzJDNTQyLjI4LC0xMDEuNzEgNTQ2LjI1LC0xMTMuMDUgNTU4Ljk3LC0xMTMuMDUgNTY3LjcyLC0xMTMuMDUgNTcyLjMzLC0xMDcuNjkgNTcyLjgsLTEwMC43NyIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSI1NzYuMiwtOTkuODkgNTcwLjg5LC05MC43MiA1NjkuMzIsLTEwMS4yIDU3Ni4yLC05OS44OSIvPgo8L2c+CjwvZz4KPC9zdmc+Cg==">
      <figcaption>Figure 14: The HTML API protocol</figcaption>
    </figure>
    <p>As the code is fairly repetitive I will just present all the code and then discuss the important parts. Here’s the implementation.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">trait</span><span style="color: #4b69c6"> StructureState</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Empty</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">StructureState</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> InHead</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">StructureState</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> InBody</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">StructureState</span><br><br><span style="color: #d73948">sealed</span> <span style="color: #d73948">trait</span><span style="color: #4b69c6"> TitleState</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> WithoutTitle</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">TitleState</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> WithTitle</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">TitleState</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Not a case class so external users cannot copy it</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> and break invariants</span><br><span style="color: #d73948">final</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> Html</span>[<span style="color: #4b69c6">S</span> <span style="color: #d73948">&lt;:</span> <span style="color: #4b69c6">StructureState</span>, <span style="color: #4b69c6">T</span> <span style="color: #d73948">&lt;:</span> <span style="color: #4b69c6">TitleState</span>](<br>    head: <span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">String</span>],<br>    body: <span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">String</span>]<br>) {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Head tags ---------------------------------------------</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">head</span>(using <span style="color: #4b69c6">S</span> =:= <span style="color: #4b69c6">Empty</span>): <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">InHead</span>, <span style="color: #4b69c6">WithoutTitle</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Html</span>(head, body)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">title</span>(<br>      text: <span style="color: #4b69c6">String</span><br>  )(using <span style="color: #4b69c6">S</span> =:= <span style="color: #4b69c6">InHead</span>, <span style="color: #4b69c6">T</span> =:= <span style="color: #4b69c6">WithoutTitle</span>): <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">InHead</span>, <span style="color: #4b69c6">WithTitle</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Html</span>(head :+ <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">&lt;title></span>$text<span style="color: #198810">&lt;/title></span><span style="color: #198810">"</span>, <span style="color: #d73948">this</span>.body)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">link</span>(rel: <span style="color: #4b69c6">String</span>, href: <span style="color: #4b69c6">String</span>)(using <span style="color: #4b69c6">S</span> =:= <span style="color: #4b69c6">InHead</span>): <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">InHead</span>, <span style="color: #4b69c6">T</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Html</span>(head :+ <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">&lt;link rel=</span><span style="color: #1d6c76">\"</span>$rel<span style="color: #1d6c76">\"</span><span style="color: #198810"> href=</span><span style="color: #1d6c76">\"</span>$href<span style="color: #1d6c76">\"</span><span style="color: #198810">/></span><span style="color: #198810">"</span>, body)<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Body tags ---------------------------------------------</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">body</span>(using <span style="color: #4b69c6">S</span> =:= <span style="color: #4b69c6">InHead</span>, <span style="color: #4b69c6">T</span> =:= <span style="color: #4b69c6">WithTitle</span>): <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">InBody</span>, <span style="color: #4b69c6">WithTitle</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Html</span>(head, body)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">h1</span>(text: <span style="color: #4b69c6">String</span>)(using <span style="color: #4b69c6">S</span> =:= <span style="color: #4b69c6">InBody</span>): <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">InBody</span>, <span style="color: #4b69c6">T</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Html</span>(head, body :+ <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">&lt;h1></span>$text<span style="color: #198810">&lt;/h1></span><span style="color: #198810">"</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">p</span>(text: <span style="color: #4b69c6">String</span>)(using <span style="color: #4b69c6">S</span> =:= <span style="color: #4b69c6">InBody</span>): <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">InBody</span>, <span style="color: #4b69c6">T</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Html</span>(head, body :+ <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">&lt;p></span>$text<span style="color: #198810">&lt;/p></span><span style="color: #198810">"</span>)<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Interpreter ------------------------------------------</span><br><br>  <span style="color: #d73948">override</span> <span style="color: #d73948">def</span> <span style="color: #4b69c6">toString</span>(): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> h <span style="color: #d73948">=</span> head.mkString(<span style="color: #198810">"</span><span style="color: #198810">  &lt;head></span><span style="color: #1d6c76">\n</span><span style="color: #198810">    </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #1d6c76">\n</span><span style="color: #198810">    </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #1d6c76">\n</span><span style="color: #198810">  &lt;/head></span><span style="color: #198810">"</span>)<br>    <span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> body.mkString(<span style="color: #198810">"</span><span style="color: #198810">  &lt;body></span><span style="color: #1d6c76">\n</span><span style="color: #198810">    </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #1d6c76">\n</span><span style="color: #198810">    </span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #1d6c76">\n</span><span style="color: #198810">  &lt;/body></span><span style="color: #198810">"</span>)<br><br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #1d6c76">\n</span><span style="color: #198810">&lt;html></span><span style="color: #1d6c76">\n</span>$h<span style="color: #1d6c76">\n</span>$b<span style="color: #1d6c76">\n</span><span style="color: #198810">&lt;/html></span><span style="color: #198810">"</span><br>  }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Html</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Html</span>[<span style="color: #4b69c6">Empty</span>, <span style="color: #4b69c6">WithoutTitle</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Html</span>(<span style="color: #4b69c6">Vector</span>.empty, <span style="color: #4b69c6">Vector</span>.empty)<br>}</code></pre>
    <p>The key point is that we factor the state into two components. <code>StructureState</code> represents where in the overall structure we are (inside the <code>head</code>, inside the <code>body</code>, or inside neither). <code>TitleState</code> represents the state when defining the elements inside the <code>head</code>, specifically whether we have a <code>title</code> element or not. We could certainly represent this with one state type variable, but I find the factored representation both easier to work with and easier for other developers to understand.</p>
    <p>Here’s an example in use.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Html</span>.empty.head<br>  .link(<span style="color: #198810">"</span><span style="color: #198810">stylesheet</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">styles.css</span><span style="color: #198810">"</span>)<br>  .title(<span style="color: #198810">"</span><span style="color: #198810">Our Amazing Webpage</span><span style="color: #198810">"</span>)<br>  .body<br>  .h1(<span style="color: #198810">"</span><span style="color: #198810">Where Amazing Exists</span><span style="color: #198810">"</span>)<br>  .p(<span style="color: #198810">"</span><span style="color: #198810">Right here</span><span style="color: #198810">"</span>)<br>  .toString<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: String = """</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> &lt;html></span><br><span style="color: #74747c">//</span><span style="color: #74747c">   &lt;head></span><br><span style="color: #74747c">//</span><span style="color: #74747c">     &lt;link rel="stylesheet" href="styles.css"/></span><br><span style="color: #74747c">//</span><span style="color: #74747c">     &lt;title>Our Amazing Webpage&lt;/title></span><br><span style="color: #74747c">//</span><span style="color: #74747c">   &lt;/head></span><br><span style="color: #74747c">//</span><span style="color: #74747c">   &lt;body></span><br><span style="color: #74747c">//</span><span style="color: #74747c">     &lt;h1>Where Amazing Exists&lt;/h1></span><br><span style="color: #74747c">//</span><span style="color: #74747c">     &lt;p>Right here&lt;/p></span><br><span style="color: #74747c">//</span><span style="color: #74747c">   &lt;/body></span><br><span style="color: #74747c">//</span><span style="color: #74747c"> &lt;/html>"""</span></code></pre>
    <p>Here’s an example of the type system preventing an invalid construction, in this case the lack of a title.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Html</span>.empty.head<br>  .link(<span style="color: #198810">"</span><span style="color: #198810">stylesheet</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">styles.css</span><span style="color: #198810">"</span>)<br>  .body<br>  .h1(<span style="color: #198810">"</span><span style="color: #198810">This Shouldn't Work</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error: </span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Cannot prove that MdocApp2.this.WithoutTitle =:= MdocApp2.this.WithTitle.</span></code></pre>
    <p>These error messages are not great. We’ll address this in <a href="#loc-413">Chapter 17</a>.</p>
    <p>We can implement more complex protocols, such as those that can be represented by context-free or even context-sensitive grammars, using the same technique.</p>
    <h5>14.2.1.1. Exercise: HTML API Design {-}</h5>
    <p>I don’t particularly like the HTML API we developed above, as the flat method call structure doesn’t match the nesting in the HTML structure we’re creating. I would prefer to write the following.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Html</span>.empty<br>  .head(<span style="color: #d73948">_</span>.title(<span style="color: #198810">"</span><span style="color: #198810">Our Amazing Webpage</span><span style="color: #198810">"</span>))<br>  .body(<span style="color: #d73948">_</span>.h1(<span style="color: #198810">"</span><span style="color: #198810">Where Amazing Happens</span><span style="color: #198810">"</span>).p(<span style="color: #198810">"</span><span style="color: #198810">Right here</span><span style="color: #198810">"</span>))<br>  .toString</code></pre>
    <p>We still require the <code>head</code> is specified before the <code>body</code>, but now the nesting of the method calls matches the nesting of the structure. Notice we’re still using a Church-encoded representation.</p>
    <p>Can you think of how to implement this? You’ll need to use indexed codata, and perhaps a bit of inspiration. This is a very open ended question, so don’t worry if you struggle with it!</p>
    <p>[html]: <a href="https://html.spec.whatwg.org/multipage/">https://html.spec.whatwg.org/multipage/</a></p>
    <p>[^valid-html]: The HTML specification allows for very lenient parsing of HTML. For example, if we don’t define the <code>head</code> tag it will usually be inferred. However we aren’t going to allow that kind of leniency in our API.</p>
    <h4 id="loc-332">14.2.2. Beyond Equality Constraints</h4>
    <p>Indexed data is all about equality constraints: proofs that some type parameter is equal to some type. However we can go beyond equality constraints with contextual abstraction. We can use [<code>&lt;:&lt;</code>][scala.&lt;:&lt;] for evidence of a subtyping relationship, and [<code>NotGiven</code>][scala.NotGiven] for evidence that no given instance exists (with which we can test that types are not equal, for example). Beyond that, we can view any given instance as evidence.</p>
    <p>Let’s return to our example of length, force, and torque to see how this is useful. In the exercise where we defined torque as force times length, we fixed the computation to have SI units. The example code is below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Force</span>[<span style="color: #d73948">Unit</span>](value: <span style="color: #d73948">Double</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>[<span style="color: #4b69c6">L</span>](length: <span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">L</span>])(using <span style="color: #d73948">Unit</span> =:= <span style="color: #4b69c6">Newtons</span>, <span style="color: #4b69c6">L</span> =:= <span style="color: #4b69c6">Metres</span>): <span style="color: #4b69c6">Torque</span>[<span style="color: #4b69c6">NewtonMetres</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Torque</span>(<span style="color: #d73948">this</span>.value * length.value)<br>}</code></pre>
    <p>This is a reasonable thing to do, as other units are insane, but there are a lot of insane people out there. To accommodate other unit types we can create given instances that represent the result types of operations of interest. In this case we want to represent the result of multiplying a length unit by the force unit. In code we can write the following.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Weird units</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Feet</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Pounds</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> PoundsFeet</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> An instance exists if A * B = C</span><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Multiply</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>, <span style="color: #4b69c6">C</span>]<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Multiply</span> {<br>  given <span style="color: #4b69c6">Multiply</span>[<span style="color: #4b69c6">Metres</span>, <span style="color: #4b69c6">Newtons</span>, <span style="color: #4b69c6">NewtonMetres</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Multiply</span> {}<br>  given <span style="color: #4b69c6">Multiply</span>[<span style="color: #4b69c6">Feet</span>, <span style="color: #4b69c6">Pounds</span>, <span style="color: #4b69c6">PoundsFeet</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">Multiply</span> {}<br>}</code></pre>
    <p>Now we can define <code>*</code> methods on <code>Length</code> and <code>Force</code> in terms of <code>Multiply</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Length</span>[<span style="color: #4b69c6">L</span>](value: <span style="color: #d73948">Double</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>[<span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">T</span>](that: <span style="color: #4b69c6">Force</span>[<span style="color: #4b69c6">F</span>])(using <span style="color: #4b69c6">Multiply</span>[<span style="color: #4b69c6">L</span>, <span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">T</span>]): <span style="color: #4b69c6">Torque</span>[<span style="color: #4b69c6">T</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Torque</span>(<span style="color: #d73948">this</span>.value * that.value)<br>}<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Force</span>[<span style="color: #4b69c6">F</span>](value: <span style="color: #d73948">Double</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>[<span style="color: #4b69c6">L</span>, <span style="color: #4b69c6">T</span>](that: <span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">L</span>])(using <span style="color: #4b69c6">Multiply</span>[<span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">L</span>, <span style="color: #4b69c6">T</span>]): <span style="color: #4b69c6">Torque</span>[<span style="color: #4b69c6">T</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Torque</span>(<span style="color: #d73948">this</span>.value * that.value)<br>}</code></pre>
    <p>Here’s an example showing it works.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">Metres</span>](<span style="color: #b60157">3</span>) * <span style="color: #4b69c6">Force</span>[<span style="color: #4b69c6">Newtons</span>](<span style="color: #b60157">4</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Torque[NewtonMetres] = Torque(value = 12.0)</span><br><br><span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">Feet</span>](<span style="color: #b60157">3</span>) * <span style="color: #4b69c6">Force</span>[<span style="color: #4b69c6">Pounds</span>](<span style="color: #b60157">4</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: Torque[PoundsFeet] = Torque(value = 12.0)</span></code></pre>
    <p>Note that’s it hard to think of <code>Multiply</code> as a type class, as it does not provide <em>any</em> methods. Viewing it as evidence, however, does make sense.</p>
    <h5>14.2.2.1. Exercise: Commutivitiy {-}</h5>
    <p>In the example above we defined a <code>Multiply</code> type class to represent that metres times newtons gives newton metres. Multiplication is commutative. If</p>
    <p>, then</p>
    <p>. However we have not represented this, and if we try newtons times metres, as in the example below, the code will fail.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Force</span>[<span style="color: #4b69c6">Newtons</span>](<span style="color: #b60157">3</span>) * <span style="color: #4b69c6">Length</span>[<span style="color: #4b69c6">Metres</span>](<span style="color: #b60157">4</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> No given instance of type MdocApp4.this.Multiply[MdocApp4.this.Newtons, MdocApp4.this.Metres, Any] was found for parameter x$2 of method * in class Force</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Force[Newtons](3) * Length[Metres](4)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                                     ^</span></code></pre>
    <p>Add evidence to <code>Multiply</code> that if <code>Multiply[A, B, C]</code> exists, then so does <code>Multiply[B, A, C]</code>, and show that it solves this problem.</p>
    <p>Now that we have learned about indexed codata, we’ll turn to its dual, indexed data.</p>
    <h3 id="loc-333">14.3. Indexed Data</h3>
    <p>The key idea of indexed data is to encode type equalities in data. When we come to inspect the data (usually, via structural recursion) we discover these equalities, which in turn limit what values we can produce. Notice, again, the duality with codata. Indexed codata limits methods we can call. Indexed data limits values we can produce. Also, remember that indexed data is often known as generalized algebraic data types. We are using the simpler term indexed data to emphasise the relationship to indexed codata, and also because it’s much easier to type!</p>
    <p>Concretely, indexed data in Scala occurs when:</p>
    <ol>
      <li>we define a sum type with at least one type parameter; and</li>
      <li>cases within the sum instantiate that type parameter with a concrete type.</li>
    </ol>
    <p>Let’s see an example. Imagine we are implementing a programming language. We need some representation of values within the language. Suppose our language supports strings, integers, and doubles, which we will represent with the corresponding Scala types. The code below shows how we can implement this as a standard algebraic data type.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Value</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">VString</span>(value: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">VInt</span>(value: <span style="color: #d73948">Int</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">VDouble</span>(value: <span style="color: #d73948">Double</span>)<br>}<br></code></pre>
    <p>Using indexed data we can use the alternate implementation below.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Value</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">VString</span>(value: <span style="color: #4b69c6">String</span>) extends <span style="color: #4b69c6">Value</span>[<span style="color: #4b69c6">String</span>]<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">VInt</span>(value: <span style="color: #d73948">Int</span>) extends <span style="color: #4b69c6">Value</span>[<span style="color: #d73948">Int</span>]<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">VDouble</span>(value: <span style="color: #d73948">Double</span>) extends <span style="color: #4b69c6">Value</span>[<span style="color: #d73948">Double</span>]<br>}</code></pre>
    <p>This is indexed data, as it meets the criteria above: we have a type parameter <code>A</code> that is instantiated with a concrete type in the cases <code>VString</code>, <code>VInt</code>, and <code>VDouble</code>. It’s quite easy to use indexed data in Scala, and people often do so not knowing that it is anything special. The natural next question is why is this useful? It will take a more involved example to show why, so let us now dive into one that makes good use of indexed data.</p>
    <h4 id="loc-334">14.3.1. The Probability Monad</h4>
    <p>For our case study of indexed data we will create a probability monad. This is a composable abstraction for defining probability distributions. The probability monad has a lot of uses. The most relevant to most developers is generating data for property-based tests, so we’ll focus on this use case. However, it can also be used, for example, for statistical inference or for creating generative art. See the conclusions (<a href="#loc-335">Section 14.4</a>) for some pointers to these uses.</p>
    <p>Let’s start with an example of generating random data. [Doodle][doodle] is a Scala library for graphics and visualization. A core part of the library is representing colors. Doodle has two different representations of colors, RGB and OkLCH, with conversions between the two. These conversions involve some somewhat tricky mathematics. Testing these conversions is an excellent use of property-based testing. If we can generate many, say, random RGB colors, we can test the conversion by checking the roundrip from RGB to OkLCH and back results in the original color[^numerics].</p>
    <p>To create an RGB color we need three unsigned bytes, so our first task is to define how we generate a random byte. Doodle happens to have an implementation of the probability monad that we will use. Here is how we can do it.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><span style="color: #d73948">import</span> doodle.core.Color<br><span style="color: #d73948">import</span> doodle.core.UnsignedByte<br><span style="color: #d73948">import</span> doodle.random.{*, given}<br><br><span style="color: #d73948">val</span> randomByte: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">UnsignedByte</span>] <span style="color: #d73948">=</span> <br>  <span style="color: #4b69c6">Random</span>.int(<span style="color: #b60157">0</span>, <span style="color: #b60157">255</span>).map(<span style="color: #4b69c6">UnsignedByte</span>.clip)</code></pre>
    <p>Note that once again we see the interpreter strategy. A <code>Random[A]</code> is a value representing a program that will generate a random value of type <code>A</code> when it runs.</p>
    <p>With three random unsigned bytes we can create a random RGB color.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> randomRGB: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">Color</span>] =<br>  (randomByte, randomByte, randomByte)<br>    .mapN((r, g, b) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Color</span>.rgb(r, g, b))</code></pre>
    <p>We might want to check our code by generating a few random values.</p>
    <pre><code data-lang="scala">randomRGB.replicateA(<span style="color: #b60157">2</span>).run<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: List[Color] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Rgb(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     r = UnsignedByte(value = 22),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     g = UnsignedByte(value = -42),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     b = UnsignedByte(value = -82),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     a = Normalized(get = 1.0)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   ),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   Rgb(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     r = UnsignedByte(value = -63),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     g = UnsignedByte(value = -99),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     b = UnsignedByte(value = -43),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     a = Normalized(get = 1.0)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   )</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <p>It seems to be working.</p>
    <p>Once we have a source of random data we can write tests using it. We can easily generate more data than is feasible for a programmer to write by hand, and therefore have a higher degree of certainty that our code is correct than we would get with manual testing. The details of writing the tests are not important to us here, so let’s move on.</p>
    <p>We have seen is an illustration of using the probability monad to generate random data. The probability monad works the same way as every other algebra: we have constructors (<code>Random.int</code>), combinators (<code>map</code>, and <code>mapN</code>), and interpreters (<code>run</code>). Being a monad means the algebra has some specific structure. For example, it tells us that we have <code>pure</code> and <code>flatMap</code> available, from which we can derive <code>mapN</code>.</p>
    <p>Let’s sketch an plausible interface for our probability monad.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Random</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Random</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>  <br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Generate a uniformly distributed random  Double greater</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> than or equal to zero and less than one.</span><br>  <span style="color: #d73948">val</span> double: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>  <br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Generate a uniformly distributed random  Int</span><br>  <span style="color: #d73948">val</span> int: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>}</code></pre>
    <p>The interface has the minimum requirements to be a monad, and a few other constructors. We can make progress on the implementation by applying the reification strategy, introduced in <a href="#loc-130">Section 6.2</a>.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">RFlatMap</span>(<span style="color: #d73948">this</span>, f)<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RFlatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](source: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>], f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>])<br>      extends <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RPure</span>(value: <span style="color: #4b69c6">A</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RDouble</span> extends <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Double</span>]<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RInt</span> extends <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Int</span>]<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Random</span> {<br>  <span style="color: #d73948">import</span> Random.{RPure, RDouble, RInt}<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">RPure</span>(value)<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Generate a uniformly distributed random  Double greater</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> than or equal to zero and less than one.</span><br>  <span style="color: #d73948">val</span> double: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">RDouble</span><br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Generate a uniformly distributed random  Int</span><br>  <span style="color: #d73948">val</span> int: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">RInt</span><br>}</code></pre>
    <p>The next step is to implement an interpreter, which is a standard structural recursion. The interpreter has a parameter that provides a source of random numbers.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">run</span>(rng: <span style="color: #4b69c6">scala</span>.<span style="color: #4b69c6">util</span>.<span style="color: #4b69c6">Random</span> <span style="color: #d73948">=</span> scala.util.<span style="color: #4b69c6">Random</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">RFlatMap</span>(source, f) <span style="color: #d73948">=></span> f(source.run(rng)).run(rng)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">RPure</span>(value)        <span style="color: #d73948">=></span> value<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">RDouble</span>             <span style="color: #d73948">=></span> rng.nextDouble()<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">RInt</span>                <span style="color: #d73948">=></span> rng.nextInt()<br>  }</code></pre>
    <p>This is an example of indexed data, as the cases <code>RDouble</code> and <code>RInt</code> provide a concrete type for the type parameter <code>A</code>. This means that these cases in the interpreter can produce values of that concrete type. If we did not use indexed data we could only generate values of type <code>A</code>, which the programmer would have to supply to use like in the <code>RPure</code> case.</p>
    <p>To finish this implementation we should implement the <code>Monad</code> type class, which would give us <code>mapN</code> and other methods for free. However, this is outside the scope of this case study, which is focused on indexed data. I encourage you to do this yourself if you feel you would benefit from the practice.</p>
    <p>Note that indexed data can mix concrete and generic types. Let’s say we add a <code>product</code> method to <code>Random</code>.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> ...</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">product</span>[<span style="color: #4b69c6">B</span>](that: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Random</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">RProduct</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RProduct</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](left: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]) extends <span style="color: #4b69c6">Random</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> .. other cases here</span><br>}</code></pre>
    <p>The right-hand side of the <code>RProduct</code> case instantiates the type parameter to <code>(A, B)</code>, which mixes the concrete tuple type with the generic types <code>A</code> and <code>B</code></p>
    <p>There are a few tricks to using indexed data that are essential in Scala 2, and can sometimes be useful in Scala 3. Take the following translation of the probability monad into Scala 2. (I’ve placed a <code>using</code> directive in this code, so if you paste it into a file and run it with the Scala CLI it will use the latest version of Scala 2.13.)</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c">> using scala 2.13</span><br><br><span style="color: #d73948">sealed</span> <span style="color: #d73948">trait</span><span style="color: #4b69c6"> Random</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">import</span> Random.<span style="color: #d73948">_</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">flatMap</span>[<span style="color: #4b69c6">B</span>](f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">RFlatMap</span>(<span style="color: #d73948">this</span>, f)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">product</span>[<span style="color: #4b69c6">B</span>](that: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Random</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">RProduct</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">run</span>(rng: <span style="color: #4b69c6">scala</span>.<span style="color: #4b69c6">util</span>.<span style="color: #4b69c6">Random</span> <span style="color: #d73948">=</span> scala.util.<span style="color: #4b69c6">Random</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RFlatMap</span>(source, f) <span style="color: #d73948">=></span> f(source.run(rng)).run(rng)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RProduct</span>(l, r)      <span style="color: #d73948">=></span> (l.run(rng), r.run(rng))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RPure</span>(value)        <span style="color: #d73948">=></span> value<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RDouble</span>             <span style="color: #d73948">=></span> rng.nextDouble()<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RInt</span>                <span style="color: #d73948">=></span> rng.nextInt()<br>    }<br><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Random</span> {<br>  <span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> RFlatMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](source: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>], f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>])<br>      extends <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>]<br>  <span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> RProduct</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](left: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>], right: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">B</span>])<br>      extends <span style="color: #4b69c6">Random</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>  <span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> RPure</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Random</span>[<span style="color: #4b69c6">A</span>]<br>  <span style="color: #d73948">case </span><span style="color: #d73948">object</span><span style="color: #4b69c6"> RDouble</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Random</span>[<span style="color: #d73948">Double</span>]<br>  <span style="color: #d73948">case </span><span style="color: #d73948">object</span><span style="color: #4b69c6"> RInt</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Random</span>[<span style="color: #d73948">Int</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pure</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">RPure</span>(value)<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Generate a uniformly distributed random  Double greater</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> than or equal to zero and less than one.</span><br>  <span style="color: #d73948">val</span> double: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">RDouble</span><br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Generate a uniformly distributed random  Int</span><br>  <span style="color: #d73948">val</span> int: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">RInt</span><br>}</code></pre>
    <p>In Scala 2 this generates a lot of type errors like</p>
    <pre><code>[error] constructor cannot be instantiated to expected type;<br>[error]  found   : Random.RProduct[A(in class RProduct),B]<br>[error]  required: Random[A(in trait Random)]<br>[error]       case RProduct(l, r)      => (l.run(rng), r.run(rng))<br>[error]            ^^^^^^^^</code></pre>
    <p>To solve this we need to create a nested method with a fresh type parameter in the interpreter, as shown below. With this change Scala 2′s type inference works and it can successfully compile the code.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">run</span>(rng: <span style="color: #4b69c6">scala</span>.<span style="color: #4b69c6">util</span>.<span style="color: #4b69c6">Random</span> <span style="color: #d73948">=</span> scala.util.<span style="color: #4b69c6">Random</span>): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>[<span style="color: #4b69c6">A</span>](random: <span style="color: #4b69c6">Random</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>    random <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RFlatMap</span>(source, f)   <span style="color: #d73948">=></span> loop(f(loop(source)))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RProduct</span>(left, right) <span style="color: #d73948">=></span> (loop(left), loop(right))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RPure</span>(value)          <span style="color: #d73948">=></span> value<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RDouble</span>               <span style="color: #d73948">=></span> rng.nextDouble()<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RInt</span>                  <span style="color: #d73948">=></span> rng.nextInt()<br>    }<br><br>  loop(<span style="color: #d73948">this</span>)<br>}</code></pre>
    <p>The other trick is for when we want to use pattern matches that match type tags. This means the form like</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> r: <span style="color: #4b69c6">RPure</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=></span> <span style="color: #d73948">???</span></code></pre>
    <p>rather than</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> <span style="color: #4b69c6">RPure</span>(value) <span style="color: #d73948">=></span> <span style="color: #d73948">???</span></code></pre>
    <p>For cases like <code>RProduct</code> it is not clear how to write these pattern matches, as the type parameters <code>A</code> and <code>B</code> for <code>RProduct</code> don’t correspond to the type parameter <code>A</code> on <code>Random</code>. The solution is use lower case names from the type parameters. Concretely, this means we can write</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> r: <span style="color: #4b69c6">RProduct</span>[<span style="color: #4b69c6">a</span>, <span style="color: #4b69c6">b</span>] <span style="color: #d73948">=></span> <span style="color: #d73948">???</span></code></pre>
    <p>The type parameters <code>a</code> and <code>b</code> are existential types; we know they exist but we don’t know what concrete type they correspond to. I’ve found this is occasionally necessary in Scala 2, but very rare in Scala 3.</p>
    <p>[^numerics]: Due to numeric issues there may be small differences between the colors that we should ignore.</p>
    <p>[doodle]: <a href="https://www.creativescala.org/doodle/">https://www.creativescala.org/doodle/</a></p>
    <h3 id="loc-335">14.4. Conclusions</h3>
    <p>In this chapter we looked at indexed data and indexed codata. The key idea of indexed types is to encode equality constraints that a type parameter equals some type. With indexed data these constraints are encoded in the data and we discover them when we destructure the data. In this way indexed data is a producer of equalities. With indexed codata these constraints must be shown to hold when methods are called. Hence indexed codata is a consumer of equalities. We also saw that we can go beyond equalities constraints with contextual abstraction, by encoding other types of constraints in given instances.</p>
    <p>Indexed types build on phantom types. The earliest reference I’ve found to phantom types is <a id="loc-336" href="#loc-524" role="doc-biblioref">Daan Leijen and Erik Meijer. [48]</a>. Type equalities were added soon afterwards, creating what we now know as generalized algebraic data types or indexed data <span id="loc-337">[</span><a href="#loc-489" role="doc-biblioref">13</a>,<a href="#loc-554" role="doc-biblioref">78</a>,<a href="#loc-569" role="doc-biblioref">93</a>]. Most work on generalized algebraic data types is concerned with type inference algorithms (e.g. <span id="loc-338">[</span><a href="#loc-544" role="doc-biblioref">68</a>]), which is not so relevant to the working programmer. <a id="loc-339" href="#loc-528" role="doc-biblioref">Chuan-kai Lin and Tim Sheard. [52]</a> is not different in this respect, but it does have a particularly clear breakdown of how GADTs are used in the most common case.</p>
    <p>Interest in indexed codata is much more recent <span id="loc-340">[</span><a href="#loc-559" role="doc-biblioref">83</a>], reflecting the general lack of attention that codata has received in programming language research (or at least the parts that I read.) Scala has excellent support for indexed codata but, even so, we can see in Scala a lack of symmetry in the support for indexed data and codata. While indexed data is built into the language, indexed codata is something we must built ourselves from contextual abstractions. This is not necessarily a bad thing, as contextual abstraction allows us to go beyond the simple type equalities of indexed data and codata. Recent research has looked to address this asymmetry. For example, <a id="loc-341" href="#loc-542" role="doc-biblioref">Klaus Ostermann and Julian Jabs. [66]</a> considers indexed data and indexed codata as related by transposition of a matrix defining the API and <a id="loc-342" href="#loc-570" role="doc-biblioref">Weixin Zhang, Cristina David, and Meng Wang. [94]</a> develops a system, implemented in Scala, that translates between data and codata.</p>
    <p>In a case study we used indexed codata to implement an API protocol: a restriction on the order in which methods can be called. We can view this as an elaboration on the basic algebra or combinator library strategy we have seen in some many different case studies. We can also relate it to work in the object-oriented programming (OOP) community. It is worth doing so to show that these problems bridge programming communities and sometimes disparate communities discover very similar solutions.</p>
    <p>In the OOP world a combinator library is called a fluent interface. The same article that introduces the term fluent interface also mentions the need for API protocols: “choose your return type based on what you need to continue fluent action” <span id="loc-343">[</span><a href="#loc-504" role="doc-biblioref">28</a>]. Many case studies have explored fluent interfaces (e.g. <span id="loc-344">[</span><a href="#loc-506" role="doc-biblioref">30</a>]; <span id="loc-345">[</span><a href="#loc-517" role="doc-biblioref">41</a>]; <span id="loc-346">[</span><a href="#loc-494" role="doc-biblioref">18</a>]; <span id="loc-347">[</span><a href="#loc-556" role="doc-biblioref">80</a>]) and this style of code is increasing in popularity <span id="loc-348">[</span><a href="#loc-537" role="doc-biblioref">61</a>]. Encoding an API protocol can be quite involved, so another research direction is the creation of tools to generate code from a protocol definition <span id="loc-349">[</span><a href="#loc-526" role="doc-biblioref">50</a>]; <span id="loc-350">[</span><a href="#loc-536" role="doc-biblioref">60</a>]; <span id="loc-351">[</span><a href="#loc-513" role="doc-biblioref">37</a>]; <span id="loc-352">[</span><a href="#loc-563" role="doc-biblioref">87</a>]. <span id="loc-353">[</span><a href="#loc-550" role="doc-biblioref">74</a>] translates API protocols back to the functional world, showing a variety of encodings in Standard ML.</p>
    <p>The probability monad we developed, which is specialized to sampling data, is only one of many possibilities. Sampling gives us an approximate representation of a distribution. Small discrete distributions can be represented exactly. <span id="loc-354">[</span><a href="#loc-502" role="doc-biblioref">26</a>] show how this can be done, in addition to the sampling approach we used. <span id="loc-355">[</span><a href="#loc-519" role="doc-biblioref">43</a>] shows how the exact and sampling approaches can be factored into monad transformer stacks. <span id="loc-356">[</span><a href="#loc-552" role="doc-biblioref">76</a>] uses probability monad as the underlying abstraction on which a variety of different statistical inference algorithms are defined. This is application of the idea of multiple interpretations that we have stressed throughout this book. <span id="loc-357">[</span><a href="#loc-553" role="doc-biblioref">77</a>] expands on this idea, breaking down inference algorithms into reusable components.</p>
    <p>We introduced the probability monad in the context of property based testing <span id="loc-358">[</span><a href="#loc-490" role="doc-biblioref">14</a>]. Randomly generating test data is not the only approach. <span id="loc-359">[</span><a href="#loc-551" role="doc-biblioref">75</a>] describes an elegant way of enumerating data. Also see <span id="loc-360">[</span><a href="#loc-499" role="doc-biblioref">23</a>] for an approach specialized to enumerating algebraic data types. More recently machine learning techniques are being explored. See, for example, <span id="loc-361">[</span><a href="#loc-548" role="doc-biblioref">72</a>] and <span id="loc-362">[</span><a href="#loc-525" role="doc-biblioref">49</a>]. <span id="loc-363">[</span><a href="#loc-514" role="doc-biblioref">38</a>] studies how property based testing is used in practice.</p>
    <p>I mentioned that the probability monad can be used in generative art. Generative art is, broadly, art that is generated by some algorithmic process. This can include an element of randomness. While there are papers on generative art (e.g. <span id="loc-364">[</span><a href="#loc-483" role="doc-biblioref">7</a>]; <span id="loc-365">[</span><a href="#loc-496" role="doc-biblioref">20</a>]), and many other resources that discuss it, it’s much more fun to create some yourself. <a href="#loc-366">Figure 15</a> shows an example of generative art. The code is below, and it has many knobs that you can play with to create your own example. Just add the <code>@main</code> annotation to the <code>cycloid</code> method and you can run the code from the Scala CLI. Have fun!</p>
    <figure id="loc-366">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACAsAAAf6CAYAAAAIBmJRAACAAElEQVR4XuzdebCWZf348dzAmUocPAi4MQpq8lXRXMIFtzRndHIIMQGHZiJwCY3SGcwFIjXBr1tKmgqaZrlQriFI4lSEaLkEqKghKpuayo5wQI6f3++++55nznODbT9/3/J8Xq8Zx+e+rut+OP9f7+e6PhUAAAAAAAAAQCqfqg4AAAAAAAAAAK2bWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAAAAAAAAIBmxAAAAAAAAAAAkIxYAAAAAAAAAgGTEAgAAAAAAAACQjFgAAAAAAAAAAJIRCwAAAAAAAABAMmIBAAAAAAAAAEhGLAAAAAAAAAAAyYgFAAAAAAAAACAZsQAAAAAAAAAAJCMWAAAAAAAAAIBkxAIAAAAAAAAAkIxYAAAAAAAAAACSEQsAAAAAAAAAQDJiAQAAAAAAAABIRiwAAAAAAAAAAMmIBQAAAAAAAAAgGbEAAAAAAAAAACQjFgAAAAAAAACAZMQCAAAAAAAAAJCMWAAAAAAAAAAAkhELAAAAAAAAAEAyYgEAAAAAAAAASEYsAAAAAAAAAADJiAUAAGh11q1bF/369Ys2bdrEVlttFQcddFBcfPHF8frrr1eXAgAAAACkJBYAAKDVufTSS6NPnz6xevXqaGxsjOnTp8e5554bHTp0iIEDB8bChQurrwAAAAAApCIWAACg1enRo0f84Q9/qA6X8cDIkSOjoaEhbrrppuo0AAAAAEAaYgEAAFqVpqamaNu2bXmiwEd5+eWX48ADD4zevXvHihUrqtMAAAAAAK2eWAAAgFZl6dKl0b59++rwRtavXx9Dhw6N7t27x9y5c6vTAAAAAACtmlgAAIBWZfny5dGuXbvq8Ee65ZZbolOnTvHHP/6xOgUAAAAA0GqJBQAAaFU+/PDD2HrrrWPt2rXVqY80ceLE2H777WPq1KnVKQAAAACAVkksAABAq7PffvvF008/XR3+m37729+WkUHbtm3LqwnGjBkTy5Ytqy4DAAAAAGgVxAIAALQ6gwcPjrFjx1aH/6bRo0dHr169okOHDnHzzTfHoEGDonPnzvGzn/2suhQAAAAA4BNPLAAAQKtz3333xfHHH18d/pv233//mDFjRkybNq28kqD4/8yZM+OQQw6J4447LubNm1d9BQAAAADgE0ssAABAq7Nq1apo167dP3yNQFNTU3n9QGNjY/n8m9/8Jjp27BhPPvlkOXfttdfWThwAAAAAAGgNxAIAALRKp5xyStxyyy3V4U0qooJtt922buzxxx8vg4EnnniifH755Zfj85//fPTp0ydWrlxZtxYAAAAA4JNGLAAAQKv08MMPR69evarDm7R06dJo3759dTgee+yx8kqC6dOnl8/r16+Ps846K7p37x5z586trAYAAAAA+OQQCwAA0CoVG/udO3eOOXPmVKc2smHDhthyyy2rw6UpU6ZEQ0NDTJs2rTZWnFjQqVOneOqpp1qsBAAAAAD45BALAADQal188cUxbNiw6vAmFZv/ixYtqg6XJk+eXAYDM2bMqI1NmjSpPHWgiAkAAAAAAD5pxAIAALRa8+fPLzf5V65cWZ3ayNFHHx1Tp06tDtdMnDixjAOeeeaZ2tg999wTbdu2jTZt2pT/79mzZxkovPbaay3eBAAAAAD4zyMWAACgVRswYEBceeWV1eGNfOc734nRo0dXh+s8/PDD5dUGc+fOLf/r2LFjDB8+PDp06FCeNPC73/0uzjvvvDIqKP7dBQsWVL8CAAAAAOA/glgAAIBWbdasWbHjjjtGY2NjdarOI488Up4u8PeMHz8+unbtGieeeGJcd9115di0adPKYODJJ58sn9esWROjRo0qxyZMmNDydQAAAACA/whiAQAAWr0vf/nLMXbs2OpwndWrV8c222wTy5Ytq05tZOTIkbH55pvHu+++Wxt79NFHo1OnTvHCCy/UxmbOnBm77LJL3HbbbbUxAAAAAID/BGIBAABavdmzZ5cb+StWrKhO1enbt2+MGzeuOryRpUuXRps2beLMM8+sG7/rrrti5513jvnz59fGiusKdthhh5gyZUqLlQAAAAAA/15iAQAAUhg0aFBceOGF1eE6Dz30UBxxxBHV4Y0UpxB8+tOfjj333DPuvPPOurniaoK99tor3nvvvdpYcT1B586d49VXX22xEgAAAADg30csAABACosWLYqGhoZ44403qlM169evLzf158yZU53aSBELPPXUU9GhQ4fy9ICWLrjggjjkkENi7dq1tbHx48fH3nvvHatWrWqxEgAAAADg30MsAABAGpdddln07t27OlxnxIgRcc4551SHN9KzZ8+YPn16XH/99XH44YdHU1NT3fxpp50Wp5xySnz44Ye1sSFDhsRXv/rVFqsAAAAAAP49xAIAAKSxbt262GOPPWLSpEnVqZqFCxfGdtttFytWrKhO1Tn77LPjqquuKmOAo446Kq6++uq6+cbGxvJKg/PPP79u7OCDD44rrriixUoAAAAAgP99YgEAAFKZMmVKdOvWre6KgKqvfe1rMXr06OpwnYcffjiOPfbY8vNrr71WXkfw8ssv161ZsmRJdO3aNe6+++7yefbs2dGjR4/41Kc+FVtttVUceuih5UkGxfsAAAAAAP+bxAIAAKRTXAVw0UUXVYdrXnzxxejUqVOsWbOmOlWzevXqaNeuXSxfvrx8/vGPf1xu/re8dqBQBAJFSDBz5sz44he/GDfeeGM888wz0dDQUL5z3nnnxfbbbx/9+/ePBQsW1L0LAAAAAPD/i1gAAIB03nrrrXKDvtjI/yh9+vTZ6GqBqr59+8b48ePLz0UkcPjhh8dNN91UWRUxYcKE2G233WLrrbeuBQiTJ08ug4Q5c+aUY6NGjSqjgnHjxlXeBgAAAAD4+IkFAABIqdiU/8IXvhBNTU3VqVKxid+xY8fayQGb8uCDD8aRRx5Zey5OJCgihCJGqDr99NOjTZs2dWN33nlndOnSJRYuXFg+v/TSS7HffvvFqaeeGqtWrapbCwAAAADwcRILAACQUnESQLHR/8Mf/rA6VTN48OC44IILqsM169evj86dO5dhQbPieoN+/fq1WPVXS5cujc0337x2EkGza665Jrp37x5LliwpnxsbG2PIkCGx9957x9y5c+vWAgAAAAB8XMQCAACk9eqrr5ZH/7/yyivVqdKiRYuioaEh5s2bV52qGTlyZAwdOrT2vHbt2ujWrVs8+uijLVb91Wc+85ny+6oRwPDhw8srDIpQoNnNN99cXlMwY8aMFisBAAAAAD4eYgEAAFK78cYbo2fPnrFhw4bqVOmqq66K4447rjpcs3jx4mjfvn0sW7asNjZ58uTYY489Yt26dS1WRhx22GFxzjnnRK9evequPyhOOSiuHhgwYED5udmUKVPKaw1+9atf1cYAAAAAAD4OYgEAAFIrNueLGODyyy+vTpWKiOCAAw6I22+/vTpV8/Wvfz0uueSSurGTTjopxowZUzc2bNiwcuyII47Y6PqD4kSCQw89NEaMGFE3/vTTT5cnDAgGAAAAAICPk1gAAID0FixYUP6C/9lnn61Olf70pz9Fx44d4y9/+Ut1qlRcY1C8v3r16tpYcXVBceVAcZVBs4kTJ8YxxxxTu/6geh3BO++8E7vttlvccccdtbFibXEiwWabbVZeY9C3b9+YOnVqi7cAAAAAAP55YgEAAPi/JkyYELvvvnusXLmyOlU6//zzy436j1JcI3DFFVfUjRWnBPTv37/2XMQE22yzTSxfvjyuu+668oSBltcOFF566aUyPJg1a1bMnz+/PFXgRz/6URkIbLfddjFy5Mjo3r17HHvssWWQAAAAAADwrxALAADA/zjjjDNiwIAB1eFSY2Nj9OjRI8aNG1edKjWfLrBs2bLa2Pvvvx9dunSJ3//+97WxIjgYP358NDU1Rc+ePTf5fXfddVfsueeecfLJJ8d///d/18bvv//+2HnnncuTEK6++urydILiuwAAAAAA/lliAQAA+B9r166NffbZJ2699dbqVKn41X+xQT9nzpzqVOn0008vTyBo6e67744DDzywdoLAAw88EEcddVT5efbs2WVg8Pbbb7d8pfSNb3wjttxyy1ixYkXd+JgxY+KAAw6INWvWlH9HETAUpxe0vAIBAAAAAODvEQsAAEALxQZ8EQTMnDmzOlUqQoJ99923DAuqFi1aFA0NDfHGG2/UxopI4NBDD43bb7+9fF63bl107ty5FhxccMEF0a9fv9r6Zm+++WZsscUW8ZOf/KQ6FQMHDiz/KxQnHhRhwd577x1z586trAQAAAAA2DSxAAAAVNx7772x6667xnvvvVedKhWb+0OHDq0Oly699NLo06dP3dhTTz0VO+20U+3X/6NGjYpvfvOb5efihICuXbvGo48+2vKV2LBhQ7Rp06YMF+bNm1c3V7xTnChwww031MZuvvnm6NSpUzzxxBMtVgIAAAAAbJpYAAAANqH4xf8xxxwTH3zwQXWqvBqg2OCfMGFCdar8pX8x9+tf/7pu/LTTTouRI0eWn996661o3759LFmypHwuQoFu3bqV77bUvXv3OPfcc8u/o/kag2avvvpqdOzYsQwRmhX/ZnGtwYMPPthiJQAAAADAxsQCAACwCU1NTXHCCSfEsGHDqlOl5557rtyY//Of/1ydiokTJ8bnPve58sqBZgsWLCivKFi8eHH5PGTIkFo8UPjKV74SP/jBD2rPhTPOOCOuueaaOPjgg2PcuHF1c4UiCthtt93KeKHZs88+W15z8NBDD7VYCQAAAABQTywAAAAfYfny5bHnnntucqO+cNNNN5XXAaxdu7Y6VW7+jxgxom7s/PPPLwOAQnEyQHHFQPNG/+uvv17GBPPnz6+tf+CBB+JLX/pSPP/882WY0BwatFRcZ9C/f//a82uvvRaHH354bLbZZrHXXnvFI4880mI1AAAAAMBfiQUAAOBvmDt3bnTq1Km8KmBTiusFBg8eXB2ON998s9zgnz17dm1s6dKlZSDQfBrBwIED47LLLqvNX3LJJdG3b9/a86pVq6Jdu3ZltPC9732vbq5ZESrss88+cfvtt8fChQtjhx12iOuvv768kmDbbbeNLl26lIHC+++/X30VAAAAAEhMLAAAAH/HE088UW78z5w5szpVbugXv+C/4447qlNx6623xkEHHRQbNmyojV1++eVx6qmnlp+bTxdYsmRJ+Vxs/BfXCjz++OO19SeffHL5PY2NjdG1a9eYMmVKba5ZcfJA8T0nnXRSjB49ujZ+zz33xK677loGDd27d48XXnihxVsAAAAAQGZiAQAA+Af84he/iF122aX89X5VsQlfbNbPmTOnOhXHHntsXHHFFbXn4hf+O+64Yzz33HPl85lnnhnDhw+vzd93333l1QZNTU3l8/333x9HH310+XnSpEmx++67l+FA1ZgxY2KLLbaIZcuW1Y2fe+655ZUIxckDRfBw77331s0DAAAAADmJBQAA4B905ZVXxr777lteC1BV/Pq/uA6gOB2gpfnz5290HcENN9wQJ554Yvl58eLFsd1228WiRYtq87169Sq/r7Bu3bryaoHmEKHY+L/00ktra5sVpxNsueWWMXbs2Lrx4v3999+//L5Zs2aVJw0UVxoAAAAAALmJBQAA4J8wbNiwOPLIIzeKAgoDBgwoTwqoKn7VX5wWUGzcF4qTAXbaaad49tlny+cLL7wwBg0aVFv/9NNPl6cPFFccFL7//e/XvreIDxoaGmLBggW19YXiO9u2bVuecDBv3ry6uRdffLEcL4KEd999Nw444ID41re+FR9++GHdOgAAAAAgD7EAAAD8E4oN9iIK6N27d2zYsKFubuXKldGtW7fyyoKq4kSA7373u7Xn6667Lvr06VN+XrFiRXTs2DGef/752vzAgQNjxIgR5ee333472rdvX270F4qTAYq/oaqICEaNGlVefVBVnEZQ/A2F4t877LDD4uyzz66sAgAAAACyEAsAAMA/af369XH88cfH4MGDq1PxzDPPlNcOvP7663Xj77zzTnTu3DmmTZtWPq9Zs6Z8bg4Err/++jjhhBNq6xcuXFhu/jdfT3DWWWeVJxAU3n///dh5553jySefrK0vHHPMMTF58uQ48MAD47bbbqubK/7m4gqF+++/v3wugoFi3UUXXVS3DgAAAADIQSwAAAD/gtWrV8fBBx9c28Bv6dprr41DDjkkPvjgg7rxSZMmRZcuXWLp0qXl85VXXhn9+vUrPxeb+cWpBI8//nht/fDhw2tBQhEfFPHAsmXLyuef/vSn0bNnz7qrBIr1l1xyScyaNasMFooTCVqaMWNGGRkUoUChOKlgr732irFjx9atAwAAAABaP7EAAAD8i957771ys/2qq66qGy828E888cS6aweaffvb346+ffuWn4vgoNjUf+WVV8rnX/7yl9GjR49oamoqn4uooAgE5syZUz4PGjSovIKgUPwbRazw85//vHwuFKcKHHXUUeXnImLo379/ba7ZGWecEUOHDq09T58+Pbbeeuto06ZN+beceuqp8dhjj7V4AwAAAABojcQCAADw/6C4LmDXXXeNW2+9tW68+NX+TjvttNHGe2NjY+y3334xbty48nnUqFExZMiQ2vyRRx4Zt9xyS+358ssvj969e5efm08XKCKFQnGlQfFvr1u3rnwurif47Gc/G6tWrSqvOSjmpk6dWvuuQnEyQXH9QXGFweLFi2PHHXeM8847r/ze4uSD8ePHx3/91/9h767DrSq3sP8LgoAiAgYdSokg3SEhAiJSggIGIB2CgrTSSIqESIOURUuopICkdEh3d5egz++9x3nn/K01z97b855jEN/Pde1rr/nMueZae/MH69rjfsbI5IoVK+b27NkT9lwAAAAAAAAAdw/CAgAAAMD/aNeuXVZ0nzRpUtj6okWLXNKkSd3Ro0fD1rdt2+Yef/xxt2XLFiv8J0yY0B07dszOrVu3zor53qgABQB0vGzZMjtu1KiRa9mypX+vcuXK2dgDT4kSJdz06dPt8axZs1yGDBn8MIFH3QjUwaB69equa9eutjZ79mx7Hf0s6myge+o9fvPNN2HPBQAAAAAAAHB3ICwAAAAA/Ak2btzoEiVK5H744Yew9S5duthogFu3boWtjx071kYYqAvAO++849q2beufq1OnjmvevLl/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ySWX7Nx+++354RGozvvd736XH+7y7LPPpkr5GsTtH/zgB/nhLjbBa7G6Cy64YGfq1Kn54S4qEktmA6jOs5nfhlQEVf8ldtxxx84qq6ySBP3GMCCNgMjh33ogO0fXXnttEgcIFaoCGTEkBsw///zJ7OAc/vKXv0xCgopBiQLOHVQJbrfddp211147JRcstNBCqXrQZ9jAuCEh4bnnnuusscYaqWIxCIIgCGYkJB+Zd81njTA+VpgWrSFU69955535zeOK5IIrr7yys/XWW6f5XdqPNcYRRxzRufnmm9Ptw6ItgbXDt771rfymBNOA82UdY73xcqclBEEQBEEQBDMOYRYIgiAIgiAIgqDLoYce2tlpp53ywyMQ///Nb34zPzwCPYR7K9zbsMldi8ZXWV97HlXyBPg//elP+U0JyQGnnXZafriLfsc27Us4F0T/NogM3mOJyy+/PCUnXHTRRZ3ZZputaxggELzmNa/pzDLLLCnFQSUhkeCKK65I74Uh4OSTT06tHJgppBvccMMNKRZ51113Te0JXv/613e22Wab1F6gaTtw1llnpXQCwgBjAYNBwy677JIqFbVWYCrwvoMgCIJgRuBHP/pRZ+GFF04teRqz3Fi455570vzsMc3VLxUSjpgvGfokBDEQHnbYYVUT46DceuutaT63xqjBUGDNsPTSS+c3BUEQBEEQBEGXMAsEQRAEQRAEQdDlqquu6qy22mr54RGceOKJnc997nP54RFsu+22VaEfYoQvueSS/HAX92dMqCF9QFVeG1//+tc7W265ZX64i2hfgvwzzzyT35Qg0q+44or54cQf//jHVPmvLUMbooDdrhpSAoJ/MwswDUgPIPoT9f3xHiAFwP+ZCfbbb7/O/fffnwwE2hcstdRSqQKSaWDfffdN4r/X/rrXvS6ZBkQVa/3gbwYEzyF1gBlDqgATwa9//etknnjf+95Xbc8QBEEQBK805tfddtstmewuvPDC/OahkdRjbWI+PP7441+Stjx/+ctfUvLBmmuumebnT3ziE8nMZ80wXlx88cXpPUgm6odz+B//8R/ptUSyQBCMDoZeKWDW6AzAWoXFOjoIgiCYaIRZIAiCIAiCIAiCLk31eY0f//jHKU6/hup4yQA19tprr2qUvxYEeu7WsPEver8NrRK0TKhh868kQtjcJ9aXBAWVelOmTMkPdyHK33TT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E0YNlf5NjJtn0jToMF8ws9Qw7t4FYvm7BHgJFkT4jDm3+eabJyE8V8szDHiPdF33aaedlu7PM29rESFNZNdddy03J7x/vJe0OqmtIYI8w1IpzBsTc9t7QxJCDWvl1VdfHdlmXIxrV+pCG87zpS99KZllutZoEARBEARBEARB8NclzAJBEARBEARBELyvIFQtscQSIxXcUgJUzYPIR4CTELDHHnskcZfop2qdKEcsI5ASAVXiExZVFGtPcMQRRyTh1vkIuT5H8M1tCJotDzISCGpR84R5poWauJyrxnPP8xLV25/5zGeq7Q1A3FR9ff/995e7RlhzzTU7TQsgSm+66abl5gkQZQmktX7wGdXknkEf2jg4329+85ty1xDPXZKBZzQOKrq1AeiDyYRp5Pzzzy93jaC9AIG5rxqb6WG++eZLSRHNqviM56VFhudqfjGD3H777SPHZIyH+ZHNBzXMaXH4vndcIdecYoT5zne+U+5qhSHlU5/6VBKgf/e735W7J2BOE8ONmXlew/Vag01Th3QAYjhzRsYacr7aWjKuzCvadTiuqw0D843WHhmGDOu8afjRFoB5oIvll18+pRjU2gSY/23JEloDEOzNZWNagznG+6uJtWJsGDy0SKiZEeA92Hx3mHfWWd+7osQ81I6l7/0RBEEQBEEQBEEQ/PUJs0AQBEEQBEEQBO87cjV/ju7PVfP5f5HmflTlEvr1fP+7v/u7JCjqSU/EPeWUU1LFriQBghvRT694gqPq6d133z2JuQRqohuzwCc+8YnGVQwGr732Wvqempi79dZbD3bbbbdy8xD7d9xxx3JzgoiqIlv/9S70gZeW0AUx0z13xfGrtjamtXtpwnjQJVJCL3QisPYPXRAzRam3iapNTj311JSeUKvCbiIBQvpEWZHdBnGZOaSPlVdeufqsSo4++ug0L8w95ouddtppsO6666bKbHOK2YU55amnnio/OgIjiuvr4s4770xzn0D+9NNPl7urMCn4zDjj6bzmhrXRlq7RhvQB91hG85fccsstqU1IhhlA64jTTz+9cdQ77TFq7R88Z+YQKR7nnHNOelZduHctDmD9aEdStmFgcvHeqHH33XcPpptuus6kA4aQ8plIICDYX3/99YMrr7wytb6occcdd4wYFvJnr7rqqvS/VivmWht/+MMf0jstYz367DhJG02ef/75wWyz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RfbLL7/cP5wHzQEnnnii7fanQYBGgbR0DBoYDjvssNj1SbMD35PXyKRBgwaxe5CxCDNnzoyckVkwoiHbKIdA+fLlLeEgGxIN+DlFREREREREfGoWEBERERER2UOMICBWnJ3+P/zwg63RIEChnoJnsCP/9ddft53UAYqARYoUsSLlKaecYqMAKJzut99+YRIAqQBlypSxue38j1tuucWde+65bt9997VmAUYRZNoJTdw/hc0g1cDHqASO08SQhOIriQGrV6/2D4WIb89W4L/zzjtdhw4d/OU8+vbta5Hzad577z17319//bV/SP4fa926dcZmExpapk6d6i/HMILjqquu8pfdkiVLbLQGiQIgvp/rPxc0FlC4J32D+zIN13bFihXD70NBnxEEaUghGDVqVGytRo0aiT8r74fvEYze4D5iXEGmBgkfoxCCRqNs3nnnHXvdpASRKJo4brzxRn9ZRERERERERM0CIiIiIiIiv8fixYutcH/ddde5QYMGWcw3u/+XLl0ansOM8Ggh/OWXX7ZC6Keffmo7iCkg8pgGgwDNAuy+JnaflAFQrGR8Ad8v+DdjxozwOYHZs2fbLuYkpB4QqZ6G1zjzzDP95ZggWSEJO675PChopqG4SxNAMMohCYXooUOH+svyf2Dy5MmuYcOG/rI77bTTrDkmDWM6/B32RPlzDSxcuNC+ZvQA130uxXXQKMB9t27dOv9QHo899piNBQENKNxnpB0koWGhQoUKsQQBGg1IV8hUpCdlhHt52bJl4doVV1zhhg0bFjkrM16P5qCVK1f6hzLiPu7Ro4e/nBH3M+NHRERERERERHxqFhAREREREfmd2OlPIb9Pnz5W/I8WCdGiRQsrrgbYbU+Bb8yYMWFkOsXBqlWrhucws53dzsT4B00EFC0vvfRSV7hwYUshoFkgU0G/adOmbuzYsf6yIdWA8QU0IaRh9vu0adP85ZjKlSuHxd1MKAjnMqP93nvvtWJqGua+lyhRIkxwkP9bjJXgWvfTK0qXLu0++OCD2FoU19+BBx7ovvvuO/v6q6++cs2aNbNracOGDeF5NNdwn+SCkQXcD0FSQBoK/kTxL1q0yArzNNU88MAD/mkh0jdI2KDBJ8BrkGDwwgsvRM78XzQOdenSJfx669at9lnlkojBaAM+i1yQkECySS4NEqSc0EyRKYlERERERERERM0CIiIiIiIivxNjCCjCUUQsWLBgGD0eoNi4cePG8OvzzjvPzZkzx11yySVhjDk7+S+++OLwHAqqI0eOdDt37rTiPmhCqFSpkjUJ5M+f35oUChQoED4Hu3fvdkWLFrX/M5k4caLNdU/DeyURIGkWO958801LP8i0szrAvPlsDQd8j1KlSmVNH6CpQqkC/15GjBhh1/Ivv/wSrhUrVswaAJIEqRoUumloYewASRfRIjYNIRTXP/nkk8gzM6NpgXulZcuW/qGMxo0b52rXrm2PScYgYYD3koQRBTTfRPG84DV8b7zxhitZsqS9rwA/X/fu3SNnJWvVqpW7//77/eWMaCyINhilmTBhQp6fQ0RERERERCSgZgEREREREZHfieI8u4ajIwMCwY7eoKhOIZTiJsV81jmOhx9+2LVr184ef/vtty5fvnzutddes9flPPD6FGP/9re/2Q5umgVoHOD8AGkF7NROwpz1559/3l+OYa75gAED/OWYtm3bpsaqkwRAOoLfOOGbMmWKa9Cggb8c8/7771tEffTnlP97jAhgNARNIZ9//rmt0cSSNjqgX79+lphB08vZZ59t4wZ8FLZppMmGlALGHhQpUiSnHfOcw/1Jowu7/Rk/sH79ev+0EKNBaNTh3ADXIEkfb731VuTMf+LnJhUgaAACjRO5Nj4wviBbs0VUmzZtbMRJLmgQir4vERERERERkSg1C4iIiIiIiPxORIEz8/zVV1+1WPModv9Go/hJFKC4+sorr7jq1auH6z179nSDBw+2xzNmzLAGgRUrVlhzAWMHQCQ6DQKMCCCFgKYBmgWikefslE5qBqDAecwxx6TupP7++++tML9jxw7/UIgGBoqaX3zxhX8o1KlTJ3f77bf7yzE0UFA0Xrp0qX8ohsYEdnjLvx+uJX7PFN6HDBniDjjggHDEQBSFcMZNcC2feOKJidcozj33XPfMM8/4yzEU/uvWrevKli3r7rjjDv9wRowKoQmB64578K677vJPiaF5h3EhUYwaoUifCYX7Cy64ILbGPZ10vi+XcRwB/i5wDwZNGmlIOeDviZptREREREREJImaBURERERERH6nU0891Qr7kydPzlPsI6qdnfqB9u3b24783r17u759+4br7NBm9jquvPJKi+Zn7AA785nHDkYS0CAwadIkd9FFF9kubpoFDjnkEDu+adMmV6JEicTxARQ/Bw4c6C/HkHDA909DTHpa7DtFSXZTszM7zdy5c213eZotW7bY7u6ksQry74HRFVdffbVdnzTHcH0zNoL/Kf5TrGaUBCkANA4koemG33d0tIGPY6RRkFDAtZ/WtBLgOTT1rFq1ysZ70NST1jRDmgUNENFd/sG1+PHHH0fO/CeSAzif5wVIPiCFYN26dZEzk5100knWcJSLxx9/3P4G5IJzc0lqEBERERERkb2XmgVERERERER+J3b5z54923YRkxAQRfPAxIkT7THFSYqHmzdvdqeccoqNGQgQp868cwr9FNqZRc7XIE2A3dCPPvqojTB44YUX3PHHH++qVKkSNgywe5gd3jfddFP4mlEU8CmsZtuJXKFChfD7JuEckhGSjB492jVp0sRfzoPd3fwsaWiuYDe3/Gfgmrz77rvdoEGD7F4gEWLevHm2E54xGkceeaT/lBh2+wfjODLhdUgU4Prie9CgkIuxY8dacZ3xGBT1P/zwQ/+UGEZ5kJQQxX3urwVo9vGTNO677z5raMgF6RokLuSKdJEnn3zSX86ocePG1mAkIiIiIiIikkTNAiIiIiIiIr8TyQEkCHTu3NkKhFEVK1Z0q1evtseLFi2yYiq75A866KBYAgCFfJIDOKdatWrWTLBy5Uo7tv/++1vs+mWXXWYFxYULF9oaKQFBs8D48ePdscceG34v30MPPeSaNm3qL8fQAECTQpolS5ZkLWrSTMDPkWb58uXu5JNP9pdj2K1N48SuXbv8Q/Jv6tprr7V0ikyee+45d+GFF/rLMZUrV07cXc99w5gNGgS4H44++mgbrZHNb7/95sqUKWMjQbg2J0yY4J8SQ/pAyZIlrTEh8NRTT9nOf5I+fDT9MN6DJIEA74/GiKT70ceoAv6G5GLr1q2WcMD3yIaxIqQ6RBMSRERERERERHxqFhAREREREfmd2EnPbmiK8dOmTQvXKVIWKlQoLCISw87cdOa1R2ebs9uf4h9IBhgwYIArV66c27Bhg61R7CNqvWjRoha/PmPGDItUp4DJ82gWILGAxoQk1atXtx3eaXj/48aN85djGFFAjHsSCqe892zYGc7YhjRdunRx3bt395fl3xhNKRS+MyE14JZbbvGXQ8T8Fy9ePON4AMYTcH3ffPPNlrIxc+bMrCMsAo899piNQqDJoHXr1v7hPNi1H214+Prrr60xIVMTA++FMSTBCJHAAw88kHP0P69frFgxaxbKxZ133uk6derkL2c0ffp0S2IQERERERERSaNmARERERERkd+J2H6SACheRuP5mV/OjmawS570AHb49ujRw+LZA+zCZ4Y6Spcu7dauXWs7ldlBjMMOO8wix88880xrShgzZoztsGanNM0IzImnYYAmg0zWr19vO6VpXkgSzFyP7qb2scOfombazHmaCe655x5/OWbTpk1WfM20SztAc0QuYxPk3wujBpIK/jfccIMV0ZPcf//9rm3btv6yJWxw/Uavq3POOceaZrKhmE8iAE0n5cuXt532aRgHwD0YTf1glEjHjh0jZ/0v4v1PP/10+z6BX375xa7vFStWRM5MxmfSokULfzkjvk+pUqVySlQAYxCCMSgiIiIiIiIiSdQsICIiIiIi8jv99NNP7oADDrCI8zVr1oTrzz77rM05B0XQPn362OOaNWvGYvopFrZv396tW7fORgmAwn2w05gUAZ7PvHTmwA8ePNi1bNnSdkzTpFCkSBFrFkgq0tOcwPPS9O3b11IN0rAzPFMxN0AjRLZmAlx//fVu2LBh/nIMu6fTZtfLv6+kUQLcC7Nnz/aXQ+yAnzVrVmyNe4hmGf4PvPvuu9Y8EC3oJ5k7d66NzeB+4nnZ1KtXL5auQZMOz4+OGAjQeMCogTfffDO2TrrCRRddFFtLwzgOGn9ywQiSbKNCAoxtII3km2++8Q+JiIiIiIiIxKhZQERERERE5A84//zzrSAZpAFg6NChFrvOrHaSAr799lubM05xP1p8JB6dtACaAYKCfeHChcNd/scdd5w9n0YEiuy8Jg0ANA0wI/6II46wZgGKmj7SBCisBiMNMmEnNGMMNm7c6B8KsVOcHc3s8k5y77332i7sNCQFUPwlej0JzRclSpRIfc/y74sxFSRM+GgiSNoRz/1w4IEHuu+++y5co/mFYrx/zXXu3NndfvvtsbUkjB8goSI6HiTJ8uXLY4kX3MukJPjfP8B7YLRIFD9HpvecZNmyZe7444+PJROkoUkoLZ0havz48TbuQ0RERERERCQbNQuIiIiIiIj8Acw432+//WJF8Ouuu8527FNwDHYfUxz0dwZTRCWynDhzEgco8OfPnz8sIDLKgNcABUCaCx588EHXoUMHN3r0aGsU4B/jCGhIiGJndY0aNWJrPuatX3DBBf5yDDu7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wemnn27NAzQKHHPMMa5AgQL2HB+FR75vmssuu8yNHz/eXw699dZbNgYhLeadpgeaG/Yknl32HtwzXGf16tULR1nkz58/dXc/DQJ333237ebv0qWL+/XXX/1TrAHHHwOShAQC7pfNmzf7h7KaNGmSJYF8//33/qFEjBvh7wRNCrnibwr30Z48R0RERERERCSNmgVERERERET+ZOz0Z6Y4xcrorvxly5a5U089Nfy6VatW7v7777fHPOeRRx6xx88//7wVThkBwA7roAhJjH8wDoAiaZ06ddxjjz3mbr/9dtu1//DDD7vrrrvOZqCzW3vfffd1RYsWtcLrrFmz/vlN/38U8A855BC3ffv22HoUzQ0HH3yw7d5O0rlz56wx748//rj9PCJJaAy45ZZbXPHixa3xheuO6y8T4vsp7BcrVsyu/yQ33HCDGzp0qL+cx/Lly91+++3nhg0b5h/KihEe//Vf/+XWrVvnH0rVpEkTd9ddd/nLqbjXevTo4S+LiIiIiIiI/G5qFhAREREREfmTzZw504rjixcvdmeffXa4zg7kyy+/3B4zp5xi/VdffWVfn3zyyW7lypX2mCIiEetvvPFGmDyAv//9727nzp3h+RRUP//8czdixAg7nyQD4thpGmB+O69fsmRJd9JJJ7mzzjorfB3wHmvXrh1b85FO0KhRI3859PPPP1uh9KOPPvIPxTCKYfr06f6ySB5r1651V1xxhTW6nHbaaa579+7WePPQQw+53r17W1IH6RyM6eDaT0LSRYkSJdyHH37oH4pZs2aNXcM01UTHIOTihx9+sHtr4sSJ/qFUNCeQDPLjjz/6hxLt2LHD7ue0n1lERERERERkT6lZQERERERE5E/GrPWDDjrIkgWqVasWrvfp08f179/fHl9//fXhLmGK7sxL53/QUEChnnSAYDQBOIcCJYg9P+644+zxuHHj3LXXXms7rg8//HBrMthnn33cJZdc4k488UTbxcwoAuLeA40bN3YTJkwIv87kwgsvdE8++aS/HOLYBRdc4C/HbNmyxYqxwc8mkguaW4YMGWKNMyQE8I97Z968ee7pp5+2VI00q1atsrEdaRjpwf3SvHlzG2WwpxgBQiLInqKhJ0gRydWtt97qOnXq5C+LiIiIiIiI/CFqFhAREREREfkXoIg+atQoK+oH2DE9efJkt3DhQnfkkUeGqQIr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2223uOmmm0rLv0kK6zRu3Dj/fv0nJk2alMcPvPbaa6VbAAAA8IcSFgAAAPiDbLrppvHwww/ndeoa0LVr16L9oUOHxmabbZbX6Y3jNIc9dQc4++yzi9r833zzzfnSM0kt1u+///5YccUV8wz0CltuuWUOFaRuBmkEQcWc9tRpYM8998znhw0blkcUpFEEFTPeK0st29Os95+TggcDBgwoLcOf5uWXX/7BiI8KKUQzduzY0vKvljp5pKDAmDFjSrd+lRS8WWONNfLvFgAAAPzZhAUAAAD+IHvssUfceOONeZ0uHXv06FG0f/XVV0evXr3y+pFHHokOHTrkdbrcv/baawvnLr/88jjooINyi/V69erFzJkzc7AgjTGosPfee8ell16agwBffPFFnuOezj/55JPRvn37/J3rrLNOHmGQOgNcdNFFhc9WSN0Lfukt7BQ6SCMVoCpJozFS14tSqYvG9OnTS8u/yp133pmDAqNGjSrd+tUOPvjgQtAHAAAA/mzCAgAAAH+QyvPSUyvzDTfcsGj/9NNPj2OPPTavd99997jkkkvyevXVV49nn322cO7MM8/M59JlaEXHgDRWIIUGKhx++OHRu3fv6NmzZ35Ol/qp7fmnn34aiy++eG7VvsACC8SFF14YTZo0yV0PKksBgxRE+Pzzz4vqlaWRCq1bty4tw58u/S795S9/KS3n35OPP/64tPyLzjnnnGjWrNmPBhB+rdtvvz1atmwZn332WekWAAAA/CmEBQAAAP4g6U3/ilnqPzaGoF+/fnHBBRfEBx98ULj8nzNnTu4K8M033xTOpdBBCgxUns2eznz11VeFMwMHDoxOnTrFqaeemp8333zzuPfee/O6YcOG8eCDD0atWrVyeKBRo0Y5QDBr1qzC59MIg9IwQ6mjjz46jj/++NIy/OlmzJgRSy65ZLz55ptF9dLfk1+SLvZTR5B27drF22+/Xbr9q02ePDl3JUgBGwAAAKgqhAUAAAD+IOPGjSuMFhg/fnyst956RftpdMB1110Xxx13XBx66KG5luavpzEBle277755LEFqZ57Oz5s3L2rWrJn/rpDGCiy99NIxcuTI/Jw6DZx//vl5ncYQnHfeeTksMHv27Nh+++1z94K777678PnDDjsszjrrrMLzj1lhhRXiueeeKy1DlXDKKafEjjvuWFRbcMEF8ziOX2PMmDHR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u3AujSSo+J4jjjgijylIUligsvQWdPqepPLPTl0Ghg4dGttvv33+7v/93/+N3XbbrfJHs8MOOyzOOuus0jKUpddeey0HZe6+++7SrR+VQgJHH310HmGQ/tZhAwAAgHInLAAAAPAnueSSS+Kvf/1rXo8aNSo22GCDov10sT9kyJB8SdmwYcOYOXNmvPrqq/nSv7J99903rr322rzu1KlTjBgxIncUqFmzZtG5JZZYIrdfT1I3gr/97W953a9fvzj33HPz+IF0efrAAw/kdeWuBEnr1q2LOhpAuXvmmWeiWbNmccwxx8SHH35Yuh0zZsyIW265JXbcccdo0KBB9O3bN956663SYwAAAFCWhAUAAAD+JGPGjIl11103r8ePHx8dO3Ys2u/Zs2c8+OCDcfzxx8fBBx+ca6kDQKpXttFGG8XDDz8cc+fOjbp168asWbPis88+i3r16hXOfP3117HQQgvlMQXJ9ddfH3vttVdep1bs6TK0RYsW0atXr7jyyiujTZs2MWHChMLnp06dGksvvfQPAgRQ7t55553cNSP97qRATOrwkcZxpP/vKWCzxRZbxDXXXJN/pwAAAGB+IiwAAADwJ0kX+OlC/5NPPolnn3021lprraL9ddZZJ4cFllpqqXjjjTdy7aKLLopDDjmk6NwKK6wQr7/+ejz33HPRtm3bXEtvP6c3piuMHTs26tevH/fff39+fuihh2KTTTYp7K244oqx55575m4Hffr0iUMPPTR3H6hw+eWXxz777FN4hvnNd999F5MnT86dOVJ4J4UIAAAAYH4mLAAAAPAn2mWXXfJF/MsvvxyrrLJK0V4aN7D11lvHgAEDCrX0BvSFF15YeP7mm2+iTp06uavA1VdfHXvvvXeuv/TSS4XgQHLBBRfE8ssvH8OGDcvPKViwxhpr5HUKKyy88MJx2WWX5UvS9u3bx+233x5bbrll4fPbb799HokAAAAAwPxBWAAAAOBPNHz48BwSePPNN6Np06ZFexVt0b/66qtCLbVEv++++wrPTz31VLRr1y6vU8eBFApIHnvssejUqVPh3G677RarrrpqPPLII/n5/fffjyZNmhT204iC1MUgdTtYdNFF81vVaUb7t99+m4MIaf1jM90BAAAAKE/CAgAAAH+yNCP9/PPPzyMJKqRL/QUWWCB3CKgsXfi/8MILhefBgwfHfvvtl9cdO3aM0aNH5/Wtt94aO+20U+FcGlWw7rrrxqhRo/JzCgGkbgKp9XrqLJDCAkOHDs17q6++ekyYMCFWW221HEYYN27cD0YkAAAAAFDehAUAAAD+ZK+88ko0btw4atasGfPmzcsjAJZaaqn8hn+p9Ib/zJkzC88HHnhgXHzxxfnt/8UWWyxmzZqV62lUQd++ffP6448/jvr16+cwQRozUKFRo0a5W8BDDz2UuxoMGjQo1/faa6+45ppr4tBDD41zzz03zjzzzOjXr1/hcwAAAACUP2EBAACAKmDYsGFRo0aN6NChQ7Rq1SqPBFhmmWWKznzxxRd5NEFlbdq0iWeffTZefvnlWGmllQr1o446Ks4666y8fvTRR6Nr1655XEE6WyGNP5g0aVL8/e9/j4033jiHA5JzzjknhwP+9a9/xdZbbx2bb7553HnnnYXPAQAAAFD+hAUAAACqiGWXXTbuvffe+Oabb+LVV18tuvxPJk+eHK1bty48v/POO7k7QOpGkC72t99++8LeLrvsEjfddFNeX3DBBTkIkMIBKVRQYYMNNshjCbbYYos4/vjjo2fPnrmeOg1suOGG8cEHH0TDhg1zV4KPPvqo8DkAAAAAyp+wAAAAQBXRtm3b/KZ/MmHChFhrrbWK9ocPHx49evQoPF933XWx88475/XJJ5+cL/wrpA4FTz75ZF736tUr/vd//zdWWGGFmDJlSuHMDjvsELfddlsOHIwdOzZatmyZ6ykksOSSS+b1qquuGmussUbhMwAAAADMH4QFAAAAqojOnTvH+PHj8/qJJ56I9dZbr2h/yJAhscceexSed9xxxxwYSFJooKKTQNKgQYP4+OOP87p9+/Y5ONC0adPcjaDCgQceGKeccko0b9485s6dG4ssskjMmTMn7y299NLx1ltvRZ8+feLggw8ufAYAAACA+YOwAAAAQBWx5ZZbxrBhw/L68ccfj06dOhXtX3jhhdG3b9+8/vrrr/N4gIpAQOpK8Pzzz+d1GhmQxgck3333XdStWzc+++yz3EFgxowZ33/Z/2/AgAE5ZJBGFiRp7EEadZCkkQT3339/bLXVVrHrrrsWPgMAAADA/EFYAAAAoIrYa6+9cveAZPTo0dG1a9ei/TRmIHUCSO64447YaKON8jp1A0hdAWbPnp2f00iBjh075nUaO7Dsssvm9eKLLx6ff/55XidnnXVW7jpw3nnn5efNNtssBwSSfv36xTnnnJM7FCy//PKFzwAAAAAwfxAWAAAAqCL69+9fuLgfOXJkdO/evWg/jQ24/PLL8zqNILjqqqvy+rXXXosVV1yxcC7V991337xOl/89evTI69q1axcCBclll10WjRs3zuGCJH1/qlXs7bTTTrnbQJMmTfJIAgAAAADmH8ICAAAAVcTFF18chxxySF6PGTMmunTpUrS/ww47xG233RYzZ87Mb/x/+umnuf7ggw/GJptsUjh39NFHxxlnnJHX5557bhx00EF5XbNmzcKZ5Nprr42FFloojzRITjvttDj22GPz+tFHH43WrVvn0MF2220Xt956a+WPAgAAAFDmhAUAAACqiNRNYP3118/r8ePHx3rrrVe0nzoNjBgxIi699NLYbbfdCvV//OMfhUBAss022+QxBUmfPn3iwgsvzKMKatWqVTiTpCBB/fr1C8833HBD7LHHHnn97rvvRp06dXIngzSuII0lAAAAAGD+ISwAAABQRXz11VdRr169+OSTT2LChAnRvn37ov127drleocOHWLYsGGF+hFHHBHnnHNO4XnllVeOSZMm5XUaQfDAAw/EF198EYsttljhTJICAMsss0zhefTo0UXdDFIngjSiINVLgwsAAAAAlDdhAQAAgCpk1113jcsuuyxf9rdt27Zor0WLFnH77bfHSiutFPPmzSvUt91227jzzjvzOnUQWGSRRfLfSbNmzWLKlCl5dEHDhg0Ln0m23nrraN68eeF52rRpsfzyy+f1Rx99FAsuuGAOC6QxBXXr1i2MKwAAAACg/AkLAAAAVCGPPvpotGnTJl/cp4v+yho0aBCbbLJJHkNQWUXHgeTVV1+Nli1b5vWXX34Ziy66aHz33Xfx/vvvR5MmTSp/LIcOKs4mc+fOzaMKvv3227jvvvty14Hrrrsu76VuBuPGjSucBQAAAKC8CQsAAABUMd27d4/zzz8/jySokDoJpDf9W7duXegaUKFRo0bx4Ycf5vXQoUOjZ8+eef3CCy/EqquumtdTp07NnQkqpLEEKUiw4oorFmpJ48aN44MPPoj/+Z//iW7dusVJJ52U63/9619j0KBBRWcBAAAAKF/CAgAAAFXM5MmT86X9QgstlN/2T2/6X3zxxVGjRo2YOHFi0dmvvvoq6tSpUxhLcNFFF8UhhxyS12k0wTbbbJPXL774YiE4kIwZMybat28fTZs2LdSSdCaFDDbeeOM44ogjYu+99871a665Jvbcc8+iswAAAACUL2EBAACAKujBBx+MmjVrxjrrrJMv9Dt37hxLLrlk6bE8dqBVq1aF5759+8YFF1yQ1+eee270798/r8ePHx/rrbde4dwll1wS++233w++s0ePHvHII4/kkQf33ntvdOnSJddT2CB1NQAAAABg/iAsAAAAUEWtu+66cemll8a0adPijTfe+MHIgOTRRx/NYwsqbLHFFvmSP0mjA1IoIBk+fHhstNFGhXMHHnhgHnWw2GKLFWrJrrvumustW7aMt956K5Zddtlc/+677/JYhJkzZxadBwAAAKA8CQsAAABUUbvsskv885//zOvnn38+Vl999ZITEUOGDIk99tij8JwCBa+88kpeb7rpprlDQXLHHXfE9ttvXziXOhU8/PDDeYRBZYcddljstdde+TtTQCDtp1EHSeo6MGzYsKLzAAAAAJQnYQEAAIAq6u9//3scd9xxef30009Hhw4dSk5EHjlw+OGH5/WsWbOibt26+ZI/ScGB1157La8HDx4cBxxwQOFzaczAe++9F7Vr1y7UkoEDB8baa68dF154YX5u06ZNTJo0Ka+PPvroOPXUUysfBwAAAKBMCQsAAABUUXfffXceK5CMHz8+OnbsWHIiYsCAAXHaaafl9bhx42KdddbJ67lz5+YgwJw5c/Lz6aefHscee2xeT58+PY8XSGcWWmih77/o/0khgSZNmsTjjz+enzfbbLO4//778/rWW2+N7bbbrvJxAAAAAMqUsAAAAEAV9fbbb8dSSy0V8+bNi8ceeyy6dOlSeiR69+4dV155ZV6fffbZceihh+b1G2+8ES1atCic+9vf/hbnnntuXqfL/zSiIHUgqFmzZuFMcsUVV+QAwddff52fDzzwwLjsssvyOn3ncsstV/k4AAAAAGVKWAAAAKAKa9WqVbz44osxcuTI6NatW+l2bLPNNnHXXXfl9UYbbRT33XdfXj/yyCPRo0ePwrndd989hgwZktfnnXde9OvXL69r1KhROJOceeaZeURBhdS1oGIUQrLEEkvEBx98UHgGAAAAoDwJCwAAAFRhqXPAxRdfHGPGjImuXbuWbuduA6NHj44PP/wwX/J/8cUXuZ66Dey///6Fc507d87fkfTp0ycuvfTSPIZg4YUXLpxJUoigadOmhecbbrgh9thjj8LzxhtvHEOHDi08AwAAAFCehAUAAACqsNtvvz169uwZ48aNi/XXX790O1ZfffV4/vnnY+DAgXlkQIUBAwbEKaecUnhO4wPefPPNvO7evXvuPJBGDdSpU6dwJtlhhx1ihRVWKDynIELl8QfHHHNM0fcCAAAAUJ6EBQAAAKqwWbNmRf369WP48OGx9tprl27H8ssvHxMnTowmTZrE5MmTC/U0duDGG2/M69mzZ8ciiyySOwkkyy67bEyfPj0+//zOWQByAAAbb0lEQVTzWHzxxQufSdZcc808+qDCtGnT8s+ocOutt8Z2221XeAYAAACgPAkLAAAAVHG77bZbHH/88bHaaquVbuUgwZ577hn9+/cvqnfq1Ckee+yxvH7uuedi1VVXzesUPqhbt27MmzcvZs6cGQ0bNix85rvvvst7bdq0KdRSwKB27dqFoMEbb7xRFB4AAAAAoDwJCwAAAFRxI0aMiJYtW/7gkj5d+NesWTNWWmmlHAKorHnz5jF16tS8Th0GUuAgeeaZZ6Jdu3Z5/d5778XSSy9d8ZHcmSD9jPSzKqs8wiD9zHr16uWgAQAAAADlS1gAAACgDHTp0iXq1KlTVHvggQeiRo0a8dJLLxXVU4eA1A0gjR9IjjnmmDj11FPzOo0R2HHHHfP69ddfLwoG3HLLLbHFFltEs2bNCrWkc+fOMWbMmMJz6lowatSoSicAAAAAKDfCAgAAAGUgBQIWWGCBePzxx/PzPffcE40aNYoGDRqUnPy+Y0CTJk0Kz927d48HH3wwr88888w46qij8nrixImx5pprFs4NHDgwjjjiiFhqqaUKtWT33XePIUOGFJ4POuiguPjiiyudAAAAAKDcCAsAAACUiXSJv+SSS8b6668fLVq0iLvvvjuPGyj19NNPR/v27fN6zpw5sfjii8dnn32Wn/v06ROXX355Xo8dOzZ3CaiQRhUMHjw46tevX6glRx99dJxxxhmF50svvTR/DwAAAADlS1gAAACgTKSL/Yceeihf8n/99dcxadKkWGWVVUqP5RDB1ltvndfjxo0rBAeSjTbaKH9HMmzYsNh0000Le6nLwGOPPRaLLbZYoZZccsklcfDBBxee00iCjh07VjoBAAAAQLkRFgAAACgTaRzAjTfeWHhOYwTatWtX6cT3rrzyyujdu3den3rqqdG/f//C3gorrBCvv/56Xt900025m0Dy3XffxaKLLhofffRR1KlTp3A+SSMPttpqq8Lzp59+mrsVzJs3r9IpAAAAAMqJsAAAAECZSBf/xxxzTOH5qaeeinXWWafSie+dfvrpcdxxx+V1586dC50E5s6dG7Vr186jCZLUMeCQQw7J6zfeeCOPNpg9e3bUqlXr+y/6fyZMmPCDUMJyyy0XU6dOLaoBAAAAUD6EBQAAAMpEesN/iy22KDyncQRpNEGpfv36xfnnnx8ff/xx1K9fP7755ptcnzJlSjRv3rxw7uSTT44TTzwxr++7777YbLPN4ttvv40FF1ywcCaZMWNGLLnkkkW1yuMMAAAAACg/wgIAAABl4u23346lllqq0P5/1KhR0a1bt+JD/78999wzbrjhhrjuuuti++23L9RHjBhRdP6www6Liy66KK8vuOCCOPzww/O6Ro0ahTMV0miCr776qvB80EEHxT/+8Y9KJwAAAAAoJ8ICAAAAZaRly5YxadKkvB49enR07dq15ETEpptuGg8++GBsvfXWMWTIkEL9mmuuiX333bfwvOOOO8a//vWvvD700ENj0KBBP9pZIGnVqlW8+uqrhefUuaAiXAAAAABA+REWAAAAKCP77bdf4Y3+nxpDsN5668XDDz+cRxB89tlnhXoaOZBGD1To2LFjjBs3Lq8333zzuP/++2P27NlRq1atwpkKG2ywQYwcObLwfO+99xaNRAAAAACgvAgLAAAAlJHbbrstNttss7x+4okncjCg1CqrrBIDBw6MnXfeuai+zz77xLXXXlt4btasWbz11lt53bp165g8eXIeNZBGDpTadddd46abbio8v/LKK7nbAAAAAADlSVgAAACgjMyaNSsaNGgQH330UUycODHWXHPN0iPRtGnTWHvtteOee+4pqnfv3j0effTRvJ47d27Url07jx1IfxZZZJH45ptv8vcvtthiRZ9L+vXrl0cPVJgzZ07h8wAAAACUH2EBAACAMrP//vvHWWedFVOnTo0WLVqUbkfdunVj+eWX/8FFfsuWLeO1117L6ylTpkTz5s3zOn1Pxfrjjz+OJZZY4v994t/OPPPMOProo4tqyyyzTLzzzjtFNQAAAADKg7AAAABAmZk0aVI0btw4XnzxxdxloLJ58+ZFjRo1iroAVNTTeIE0ZiAZMWJEdOvWLa8feeSR6NGjR16/+eabOWhQ6uqrr4799tuvqNahQ4d46qmnimoAAAAAlAdhAQAAgDI0aNCgWHnllWOhhRbKIwUqDBkyJIcFZs+eXel0xIcffhiNGjUqPF9zzTWx77775vVVV11VCAK89NJL0bZt28K5CnfddVdsu+22RbWtt976B6MOAAAAACgPwgIAAABl6sorr4yaNWvG3nvvHddee22ceOKJORBQv3790qPxzDPPxFprrVV4Pumkk/Kf5IQTToiBAwfm9RNPPBHrrbde4VyFMWPGRJcuXYpqffr0icsvv7yoBgAAAEB5EBYAAAAoY2uvvXYcfPDB0atXr+jfv38eC9C0adPSY7kDQOoEUKEiYJDss88+hXUaSbDRRhsVzlX4sY4Dxx9/fJxyyilFNQAAAADKg7AAAABAGdtll13ipptuKjy/9tpr0apVq0onvpe6EPTu3bvwnLoHPP7443m9wQYbxIgRI/L6lltuyd9Zavr06bH88ssX1c4555w48sgji2oAAAAAlAdhAQAAgDL2P//zP4URAskLL7wQq6++eqUT3zv11FNjwIABhecGDRrERx99lNfNmzePqVOn5vUll1wShxxySOFchRkzZuQRB5UNHjw4DjjggKIaAAAAAOVBWAAAAKCM3XDDDbH77rsXnp9++uno0KFDpRPf69u3bwwaNCivP/jgg8LF/9y5c6N27dr57+Tkk0+Ok046qeJjBV9++WUsuuiiRbWbb745dt1116IaAAAAAOVBWAAAAKCMPfXUU7HWWmsVnseNGxcdO3asdOJ7u+22W2FcwSOPPJJHDyRTpkzJnQUqpK4CqbtAqXnz5kXNmjWLag888EBsttlmRTUAAAAAyoOwAAAAQBn7+uuvo27duvnvZMyYMdG1a9eSUxEbbrhhDB8+PK9PP/30+Nvf/pbXI0aMiG7duhXObb/99nH77bcXniv8WFhg5MiR0b1796IaAAAAAOVBWAAAAKDMtW/fPsaPH5/XP3WBn0YTpBEFycYbbxz33HNPXl9zzTWx7777Fs6tu+66he+q7Ntvv42FFlqoqJa6GKy//vpFNQAAAADKg7AAAABAmTv44IPjvPPOy+uf6izQunXreOWVV2LGjBnRoEGD+OKLL3L9pJNOyn8qNG3aNN56663Cc4U5c+bEwgsvXFR79tlni0YgAAAAAFA+hAUAAADK3N133527BSQ/9bb/sssuG++++24eQdC7d+9CvVevXnH11Vfn9dy5c6N27dq5i0Cp2bNn573KJk2aFG3bti2qAQAAAFAehAUAAADKXOoSkLoFfPTRR3nUQBo5UGrxxRfPYYEUGnj++ecL9W7dusWjjz6a19OmTYvllluusFfZl19+GYsuumhR7bXXXotWrVoV1QAAAAAoD8ICAAAA84H9998/zjjjjHj99dejZcuWpdtRs2bN+Otf/xoHHXRQUb158+YxZcqUvB49enR06dKlaL/Chx9+GI0bNy6qTZ06NVZYYYWiGgAAAADlQVgAAABgPvDyyy/ny/wXXnghllhiidLtqFGjRr7Y//TTTwu1irED6e/khhtuiD333LOwX9kbb7wRK664YlFt+vTpP9mJAAAAAICqTVgAAABgPnHBBRdEmzZtolatWjF79uxCPY0ZWGCBBWLixImVTn/fGSB1FqhwyimnxIABA/59oJLnnnsu1lhjjaJaxVgDAAAAAMqPsAAAAMB85IorrogFF1wwdtlll9wp4OSTT84dB9IYgm+//bbobOnYgTTK4Morr6x04t/Gjh0bnTp1Kqr92GgCAAAAAMqDsAAAAMB8Zvvtt49dd9019tlnnzjssMPyuICFF164MG6gwpAhQ2K33XYrPHft2jVGjhxZ6cS/DR06NDbffPOi2syZM6Nhw4ZFNQAAAADKg7AAAADAfOaMM86II444oqhWr169+Oyzz4pqZ511Vhx11FGF56WXXjrefvvtSif+7frrr4+99967qPb555/H4osvXlQDAAAAoDwICwAAAMxnnnnmmVh55ZWLas2aNYu33nqrqNa3b9+48MIL8zqNFPi5LgHnn39+9O/fv6j29ddfR506dYpqAAAAAJQHYQEAAID5zLx582K55ZaLyZMnF2qrrLJKTJo0qdKpiN133z3++c9/5vXDDz8cPXr0KNqvbMCAAXHaaacV1dJYg4UWWqioBgAAAEB5EBYAAACYDx122GFxyimnFJ7XW2+9GD9+fKUTERtttFEOCSSnnnpqHHnkkUX7lR1wwAExePDg0nLUqFEjhxMAAAAAKC/CAgAAAPOhNIpgxRVXLFzkb7HFFnHfffcVnVljjTVi4sSJed29e/d44IEHivYr22qrreKee+4pLcciiywS33zzTWkZAAAAgCpOWAAAAGA+1a5duxg+fHhe77fffnH11VcX7Tdv3jymTZsWM2fOjPr168eXX35ZtF9Zhw4d4umnny4tR4MGDeLTTz8tLQMAAABQxQkLAAAAzKcuvvji2GOPPfL62GOPjTPOOKNof6mllooPP/wwBg0aFHvttVfRXqllllkm3nnnndJyLL300vH++++XlgEAAACo4oQFAAAA5lOpY0DDhg3z3xdccEEcfvjhRft169aNWbNmRdu2bWPUqFFFe5XNnTs3atWqFd9++23pVrRo0SJ3JwAAAACgvAgLAAAAzMf23HPP3Dng1ltvjZ122qlor2bNmnHDDTdEp06diuql3nzzzWjWrFlpOWvTpk1Mnjy5tAwAAABAFScsAAAAMB8bM2ZMrLTSSvHYY49Fx44di/ZSWGDFFVf82a4CydixY2P99dcvLWdrrrlmTJw4sbQMAAAAQBUnLAAAADCf69GjR5x55pk/6A6QwgKp88Avufnmm2OXXXYpLWcdOnSIp556qrQMAAAAQBUnLAAAADCfe+mll6Jx48ZRq1atmDt3bq7deeedUaNGjXjvvfdKTv/QGWecEUcffXRpOVt33XVz5wEAAAAAyouwAAAAQDVw7733xoILLhgHH3xwDBo0KIcHateuHV999VXp0R/o3bt3XHHFFaXlLI0nGDlyZGkZAAAAgCpOWAAAAKCaSBf7O++8c/Tq1SsmT54c9evXj08//bT02A+kMQaPPPJIaTnr0qVLjBgxorQMAAAAQBUnLAAAAFBN7L///nHllVcWnps2bRpvv/12pRM/bplllonp06eXlrPu3bvHo48+WloGAAAAoIoTFgAAAKgmzjnnnOjfv3/huU2bNrnDwM/58MMPY4klligtF3Tr1i1GjRpVWgYAAACgihMWAAAAqCaGDh0aPXv2LDyvvfba8dRTT1U68UMPP/xw7h7wUzp06BDPPPNMaRkAAACAKk5YAAAAoJpIIwcaN25ceE4hgBEjRvz7wI8YOHBgHHPMMaXlgtatW8err75aWgYAAACgihMWAAAAqEZatGhRuNzfcccd41//+lfJiWIbbLBBDBs2rLRcsMwyy8S7775bWgYAAACgihMWAAAAqEb22muvuPLKK/P6oIMOissuu6zkxL99/PHHUb9+/fjyyy9LtwoWX3zxmDVrVmkZAAAAgCpOWAAAAKAaufnmm2PLLbfM6xNOOCH+/ve/l5z4t/POOy/23Xff0nLBnDlzolatWjFv3rzSLQAAAACqOGEBAACAauTzzz+PBg0a5K4BgwYNir59+5Yeyb744oto3rx5PPnkk6VbBWmcQcuWLUvLAAAAAJQBYQEAAIBqJo0iuPDCC+PWW2+NnXbaqXQ7O/LII2PvvfcuLRcZOnRo9OzZs7QMAAAAQBkQFgAAAKhmxo4dG61atYrHHnssOnbsWLodt99+e+4qMGPGjNKtIqkzwaGHHlpaBgAAAKAMCAsAAABUQz169IgzzzwzmjVrVlQfPnx4NG7cOCZMmFBU/zG9evWKwYMHl5YBAAAAKAPCAgAAANXQiy++mEMBtWrVitmzZ+fakCFDcm306NElp3/cKqusEs8991xpGQAAAIAyICwAAABQTd1zzz2x4IILRvv27aNNmzbRrl27eP7550uP/ahPPvkk6tWrF99++23pFgAAAABlQFgAAACgGtt2223jxBNPjKeffrp062fde++9sfHGG5eWAQAAACgTwgIAAADV2LnnnhuHHnpoafkX9e3bN84888zSMgAAAABlQlgAAACgGksdBdIIgt+qbdu28cwzz5SWAQAAACgTwgIAAADVXIsWLeKFF14oLf+kadOmRZMmTeK7774r3QIAAACgTAgLAAAAVHNHHnlknHjiiaXln3TJJZfEfvvtV1oGAAAAoIwICwAAAFRzTz75ZLRu3bq0/JM222yzuP3220vLAAAAAJQRYQEAAABitdVWi5EjR5aWf+Czzz6L+vXrx6xZs0q3AAAAACgjwgIAAADEoEGDYq+99iot/8ANN9wQ2267bWkZAAAAgDIjLAAAAEB8/PHH0bBhw/z3z9l8881jyJAhpWUAAAAAyoywAAAAANnee+8d559/fmm54NVXX40mTZrE119/XboFAAAAQJkRFgAAACAbN25ctGzZMubOnVu6le22227x97//vbQMAAAAQBkSFgAAAKBgww03jMGDB5eW47bbbosVV1wxvvrqq9ItAAAAAMqQsAAAAAAFL7zwQh418OyzzxZqN998czRu3LioBgAAAEB5ExYAAACgyN133x2NGjWKLl26RNu2bWO11VaL5557rvQYAAAAAGVMWAAAAIAf+OKLL2LUqFHx5JNPlm4BAAAAMB8QFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAAAAAAAAKhmhAUAAAAAAAAAoJoRFgAAAAAAAACAakZYAAAAAAAAAACqGWEBAAD4/9q1AwEAAAAAQf7Wg1wcAQAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMyAIAAAAAAAAAMCMLAAAAAAAAAMCMLAAAAAAAAAAAM7IAAAAAAAAAAMzIAgAAAAAAAAAwIwsAAAAAAAAAwIwsAAAAAAAAAAAzsgAAAAAAAAAAzMgCAAAAAAAAADAjCwAAAAAAAADAjCwAAAAAAAAAADOyAAAAAAAAAADMBCm/ofAfJ7KEAAAAAElFTkSuQmCC">
      <figcaption>Figure 15: A set of cycloids showing five-fold symmetry</figcaption>
    </figure>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c">> using dep org.creativescala::doodle:0.30.0</span><br><br><span style="color: #d73948">import</span> cats.Monoid<br><span style="color: #d73948">import</span> cats.syntax.all.*<br><span style="color: #d73948">import</span> cats.effect.unsafe.implicits.global<br><span style="color: #d73948">import</span> doodle.core.*<br><span style="color: #d73948">import</span> doodle.core.format.{Pdf, Png}<br><span style="color: #d73948">import</span> doodle.interact.syntax.interpolation.*<br><span style="color: #d73948">import</span> doodle.random.{*, given}<br><span style="color: #d73948">import</span> doodle.syntax.all.*<br><span style="color: #d73948">import</span> doodle.java2d.*<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">cycloid</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span> {<br>  given <span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>] with {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">combine</span>(a: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>, b: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>): <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span> <span style="color: #d73948">=</span><br>      angle <span style="color: #d73948">=></span> a(angle) + b(angle)<br><br>    <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span> <span style="color: #d73948">=</span> angle <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>.zero<br>  }<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Reverse the rolling direction of the cycloid. </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">val</span> reverse: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=</span> angle <span style="color: #d73948">=></span> -angle<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Multiply the angle by the given speed, which determines how rapidly the</span><br><span style="color: #74747c">    </span><span style="color: #74747c">*</span><span style="color: #74747c"> cycloid rotates.</span><br><span style="color: #74747c">    </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">speed</span>(speed: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=</span><br>    angle <span style="color: #d73948">=></span> angle * speed<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Increment the angle by the given amount. In other words move it out of</span><br><span style="color: #74747c">    </span><span style="color: #74747c">*</span><span style="color: #74747c"> phase.</span><br><span style="color: #74747c">    </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">phase</span>(p: <span style="color: #4b69c6">Angle</span>): <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=</span><br>    angle <span style="color: #d73948">=></span> p - angle<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Set the radius of the cycloid </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">radius</span>(r: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span> <span style="color: #d73948">=</span><br>    angle <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>(r, angle)<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Cycloid is speed of rotation and radius (+ve or -ve) </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">cycloid</span>(v: <span style="color: #d73948">Double</span>, r: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span> <span style="color: #d73948">=</span><br>    speed(v).andThen(radius(r))<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Inspired by "Creating Symmetry" by Frank Farris. </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">c1</span>(amplitude: <span style="color: #d73948">Double</span>) <span style="color: #d73948">=</span><br>    cycloid(<span style="color: #b60157">1</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>, amplitude) |+| cycloid(<span style="color: #b60157">6</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>, <span style="color: #b60157">0</span><span style="color: #b60157">.</span><span style="color: #b60157">5</span> * amplitude) |+| (speed(<span style="color: #b60157">14</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>)<br>      .andThen(phase(<span style="color: #b60157">90</span>.degrees))<br>      .andThen(radius(<span style="color: #b60157">0</span><span style="color: #b60157">.</span><span style="color: #b60157">33</span> * amplitude)))<br><br>  <span style="color: #d73948">val</span> randomCycloid: <span style="color: #4b69c6">Random</span>[<span style="color: #d73948">Double</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>] =<br>    <span style="color: #d73948">for</span> {<br>      d <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Random</span>.int(<span style="color: #b60157">3</span>, <span style="color: #b60157">25</span>) <span style="color: #74747c">//</span><span style="color: #74747c"> Degree of symmetry</span><br>      n <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Random</span>.natural(d) <span style="color: #74747c">//</span><span style="color: #74747c"> Offset from d</span><br>      m1 <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Random</span>.int(<span style="color: #b60157">1</span>, <span style="color: #b60157">5</span>)<br>      m2 <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">Random</span>.int(m1, m1 + <span style="color: #b60157">5</span>)<br>    } <span style="color: #d73948">yield</span> amplitude <span style="color: #d73948">=</span>><br>      cycloid(n, amplitude) |+| cycloid(<br>        m1 * d + n,<br>        <span style="color: #b60157">0</span><span style="color: #b60157">.</span><span style="color: #b60157">5</span> * amplitude<br>      ) |+| phase(<span style="color: #b60157">90</span>.degrees).andThen(cycloid(m2 * d + n, <span style="color: #b60157">0</span><span style="color: #b60157">.</span><span style="color: #b60157">33</span> * amplitude))<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">drawCycloid</span>(<br>      cycloid: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>,<br>      start: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=</span> <span style="color: #b60157">0</span>.degrees,<br>      stop: <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=</span> <span style="color: #b60157">720</span>.degrees,<br>      steps: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span> <span style="color: #b60157">1000</span><br>  ): <span style="color: #4b69c6">Picture</span>[<span style="color: #d73948">Unit</span>] <span style="color: #d73948">=</span><br>    interpolatingSpline[<span style="color: #4b69c6">Algebra</span>](<br>      (start)<br>        .upTo(stop)<br>        .forSteps(steps)<br>        .map(angle <span style="color: #d73948">=></span> cycloid(angle).toPoint)<br>        .toList<br>    )<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> Repeatedly draw a cycloid with increasing size and a slow turn </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">drawCycloids</span>(cycloid: <span style="color: #d73948">Double</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Angle</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Vec</span>): <span style="color: #4b69c6">Picture</span>[<span style="color: #d73948">Unit</span>] <span style="color: #d73948">=</span><br>    (<span style="color: #b60157">0</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>)<br>      .upTo(<span style="color: #b60157">1</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>)<br>      .forSteps(<span style="color: #b60157">30</span>)<br>      .map { m <span style="color: #d73948">=</span>><br>        drawCycloid(cycloid(<span style="color: #b60157">350</span> * m + <span style="color: #b60157">100</span>)).rotate(<span style="color: #b60157">30</span>.degrees * m)<br>      }<br>      .toList<br>      .allOn<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> val picture = drawCycloids(c1)</span><br>  <span style="color: #d73948">val</span> picture <span style="color: #d73948">=</span> randomCycloid.map(drawCycloids).run<br><br>  <span style="color: #d73948">val</span> frame <span style="color: #d73948">=</span> <span style="color: #4b69c6">Frame</span>.default<br><br>  picture.drawWithFrame(frame)<br>  picture.write[<span style="color: #4b69c6">Png</span>](<span style="color: #198810">"</span><span style="color: #198810">cycloid.png</span><span style="color: #198810">"</span>, frame)<br>  picture.write[<span style="color: #4b69c6">Pdf</span>](<span style="color: #198810">"</span><span style="color: #198810">cycloid.pdf</span><span style="color: #198810">"</span>, frame)<br>}</code></pre>
    <h2 id="loc-367">15. Tagless Final Interpreters</h2>
    <p>In this chapter we’ll explore the codata approach to interpreters, building up to a strategy known as <strong>tagless final</strong>. Along the way we will build two interpreters: one for terminal interaction and one for user interfaces.</p>
    <p>We’ve seen the duality between data and codata in many places, starting with <a href="#loc-77">Chapter 4</a>. This chapter will begin by applying that duality to build an interpreter using codata, which contrasts with the data approach we saw in <a href="#loc-130">Section 6.2</a>. This will illustrate the technique and give us a concrete example to discuss its shortcoming. In particular we’ll see that extensibility is limited, a problem we first encountered in <a href="#loc-85">Section 4.5</a>.</p>
    <p>Solving the problem of extensibility, otherwise known as the <strong>expression problem</strong>, will lead us to tagless final. In the context of interpreters, solving the expression problem means allowing extensibility of both the programs we write and the interpreters that run them. We’ll start with the standard encoding of tagless final in Scala, and see that it is a bit painful to use in practice. We’ll then develop an alternative encoding that is easier to use. Solving the expression problem allows for very expressive code but it adds complexity, so we’ll finish by talking about when tagless final is appropriate and when it’s best to use a different strategy.</p>
    <h3 id="loc-368">15.1. Codata Interpreters</h3>
    <p>In this section we’ll explore codata interpreters, using a DSL for terminal interaction as a case study. The terminal is familiar to most programmers, and terminal applications are common for developer focused tools. Most terminal features are controlled by writing so-called escape codes to the terminal. However, applications benefit from higher-level abstractions, motivating textual user interface (TUI) libraries that present a more ergonomic interface[^tuis]. Our library will showcase codata interpreters, monads, and the central role of designing for composition and reasoning.</p>
    <h4 id="loc-369">15.1.1. The Terminal</h4>
    <p>The modern terminal is an accretion of features that started with the VT-100 in 1978 and continues [to this day][kitty-kp]. Most terminal features are accessed by reading and writing ANSI escape codes, which are sequence of characters starting with the escape character. We will work only with escape codes that change the text style. This allows us to produce interesting output, and raises all the design issues we want to address, but keeps the system simple. The ideas here are extended to a more complete system in the <a href="https://www.creativescala.org/terminus/">Terminus</a> library.</p>
    <p>The code below is written so that with a single change it can pasted into a file and run with any recent version of Scala with just <code>scala &lt;filename></code>. The required change is to add the <code>@main</code> annotation before the method <code>go</code>. That is, change</p>
    <p><code>def go(): Unit =</code></p>
    <p>to</p>
    <p><code>@main def go(): Unit =</code></p>
    <p>(This is due to a limitation of the software that compiles the code in the book.)</p>
    <p>The examples should work with any terminal from the last 40 odd years. If you’re on Windows you can use Windows Terminal, <a href="https://learn.microsoft.com/en-us/windows/wsl/about">WSL</a>, or another terminal that runs on Windows such as <a href="https://wezfurlong.org/wezterm/index.html">WezTerm</a>.</p>
    <h4 id="loc-370">15.1.2. Color Codes</h4>
    <p>We will start by writing color codes straight to the terminal. This will introduce us to controlling the terminal, and show the problems of using ANSI escape codes directly. Here’s our starting point:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> csiString <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #1d6c76">\u001b</span><span style="color: #198810">[</span><span style="color: #198810">"</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printRed</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(csiString)<br>  print(<span style="color: #198810">"</span><span style="color: #198810">31</span><span style="color: #198810">"</span>)<br>  print(<span style="color: #198810">"</span><span style="color: #198810">m</span><span style="color: #198810">"</span>)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printReset</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(csiString)<br>  print(<span style="color: #198810">"</span><span style="color: #198810">0</span><span style="color: #198810">"</span>)<br>  print(<span style="color: #198810">"</span><span style="color: #198810">m</span><span style="color: #198810">"</span>)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">go</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(<span style="color: #198810">"</span><span style="color: #198810">Normal text, </span><span style="color: #198810">"</span>)<br>  printRed()<br>  print(<span style="color: #198810">"</span><span style="color: #198810">now red text, </span><span style="color: #198810">"</span>)<br>  printReset()<br>  println(<span style="color: #198810">"</span><span style="color: #198810">and now back to normal.</span><span style="color: #198810">"</span>)</code></pre>
    <p>Try running the above code (e.g. add the <code>@main</code> annotation to <code>go</code>, save it to a file <code>ColorCodes.scala</code> and run <code>scala ColorCodes.scala</code>.) You should see text in the normal style for your terminal, followed by text colored red, and then some more text in the normal style. The change in color is controlled by writing escape codes. These are strings starting with <code>ESC</code> (which is the character <code>'\u001b'</code>) followed by <code>'['</code>. This is the value of <code>csiString</code> (where CSI stands for Control Sequence Introducer). The CSI is followed by a string indicating the text style to use, and ended with a <code>"m"</code> The string <code>"\u001b[31m"</code> tells the terminal to set the text foreground color to red, and the string <code>"\u001b[0m"</code> tells the terminal to reset all text styling to the default.</p>
    <h4 id="loc-371">15.1.3. The Trouble with Escape Codes</h4>
    <p>Escape codes are simple for the terminal to process but lack useful structure for the programmer generating them. The code above shows one potential problem: we must remember to reset the color when we finish a run of styled text. This problem is no different to that of remembering to free manually allocated memory, and the long history of memory safety problems in C programs show us that we cannot expect to do this reliably. Luckily, we’re unlikely to crash our program if we forget an escape code!</p>
    <p>To solve this problem we might decide to write functions like <code>printRed</code> below, which prints a colored string and resets the styling afterwards.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> csiString <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #1d6c76">\u001b</span><span style="color: #198810">[</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> redCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">31m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> resetCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">0m</span><span style="color: #198810">"</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printRed</span>(output: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(redCode)<br>  print(output)<br>  print(resetCode)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">go</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(<span style="color: #198810">"</span><span style="color: #198810">Normal text, </span><span style="color: #198810">"</span>)<br>  printRed(<span style="color: #198810">"</span><span style="color: #198810">now red text, </span><span style="color: #198810">"</span>)<br>  println(<span style="color: #198810">"</span><span style="color: #198810">and now back to normal.</span><span style="color: #198810">"</span>)</code></pre>
    <p>Changing color is the not the only way that we can style terminal output. We can also, for example, turn text bold. Continuing the above design gives us the following.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> csiString <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #1d6c76">\u001b</span><span style="color: #198810">[</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> redCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">31m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> resetCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">0m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> boldOnCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">1m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> boldOffCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">22m</span><span style="color: #198810">"</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printRed</span>(output: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(redCode)<br>  print(output)<br>  print(resetCode)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printBold</span>(output: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(boldOnCode)<br>  print(output)<br>  print(boldOffCode)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">go</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(<span style="color: #198810">"</span><span style="color: #198810">Normal text, </span><span style="color: #198810">"</span>)<br>  printRed(<span style="color: #198810">"</span><span style="color: #198810">now red text, </span><span style="color: #198810">"</span>)<br>  printBold(<span style="color: #198810">"</span><span style="color: #198810">and now bold.</span><span style="color: #1d6c76">\n</span><span style="color: #198810">"</span>)</code></pre>
    <p>This works, but what if we want text that is <em>both</em> red and bold? We cannot express this with our current design, without creating methods for every possible combination of styles. Concretely this means methods like</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">printRedAndBold</span>(output: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  print(redCode)<br>  print(boldOnCode)<br>  print(output)<br>  print(resetCode)</code></pre>
    <p>This is not feasible to implement for all possible combinations of styles. The root problem is that our design is not compositional: there is no way to build a combination of styles from smaller pieces.</p>
    <h4 id="loc-372">15.1.4. Programs and Interpreters</h4>
    <p>To solve the problem above we need <code>printRed</code> and <code>printBold</code> to accept not a <code>String</code> to print but a program to run. We don’t need to know what these programs do; we just need a way to run them. Then the combinators <code>printRed</code>, <code>printBold</code>, and so on, can also return programs. These programs will set the style appropriately before running their program parameter, and reset it after the parameter program has finished running. By accepting and returning programs the combinators have the property of closure, meaning that type of the input (a program) is the same as the type of the output. Closure in turn makes composition possible.</p>
    <p>How should we represent a program? We will choose codata and in particular functions, the simplest form of codata. In the code below we define the type <code>Program[A]</code>, which is a function <code>() => A</code>. The interpreter, which is the thing that runs programs, is just function application. To make it clearer when we are running programs I have a created method <code>run</code> that does just that.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span><br><br><span style="color: #d73948">val</span> csiString <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #1d6c76">\u001b</span><span style="color: #198810">[</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> redCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">31m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> resetCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">0m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> boldOnCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">1m</span><span style="color: #198810">"</span><br><span style="color: #d73948">val</span> boldOffCode <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">22m</span><span style="color: #198810">"</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">run</span>[<span style="color: #4b69c6">A</span>](program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> program()<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>(output: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Program</span>[<span style="color: #d73948">Unit</span>] <span style="color: #d73948">=</span><br>  () <span style="color: #d73948">=></span> <span style="color: #4b69c6">Console</span>.print(output)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printRed</span>[<span style="color: #4b69c6">A</span>](output: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  () <span style="color: #d73948">=></span> {<br>    run(print(redCode))<br>    <span style="color: #d73948">val</span> result <span style="color: #d73948">=</span> run(output)<br>    run(print(resetCode))<br>    <br>    result<br>  }<br><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">printBold</span>[<span style="color: #4b69c6">A</span>](output: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <br>  () <span style="color: #d73948">=></span> {<br>    run(print(boldOnCode))<br>    <span style="color: #d73948">val</span> result <span style="color: #d73948">=</span> run(output)<br>    run(print(boldOffCode))<br>    <br>    result<br>  }<br><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">go</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span><br>  run(() <span style="color: #d73948">=></span> {<br>    run(print(<span style="color: #198810">"</span><span style="color: #198810">Normal text, </span><span style="color: #198810">"</span>))<br>    run(printRed(print(<span style="color: #198810">"</span><span style="color: #198810">now red text, </span><span style="color: #198810">"</span>)))<br>    run(printBold(print(<span style="color: #198810">"</span><span style="color: #198810">and now bold </span><span style="color: #198810">"</span>)))<br>    run(printBold(printRed(print(<span style="color: #198810">"</span><span style="color: #198810">and now bold and red.</span><span style="color: #1d6c76">\n</span><span style="color: #198810">"</span>))))<br>  })</code></pre>
    <p>Notice that we have the usual structure for an algebra, which we first met in <a href="#loc-131">Section 6.2.1</a>:</p>
    <ol>
      <li>we have a constructor in <code>print</code>;</li>
      <li>we have two combinators in <code>printRed</code> and <code>printBold</code>; and</li>
      <li>we have an interpreter in <code>run</code>.</li>
    </ol>
    <p>This code works, for the example we have chosen, but there are two issues: composition and ergonomics. That we have a problem with composition is perhaps surprising, as that’s the problem we set out to solve. We have made the system compositional in some aspects, but there are still ways in which it does not work correctly. For example, take the following code:</p>
    <pre><code data-lang="scala">run(printBold(() <span style="color: #d73948">=></span> {<br>  run(print(<span style="color: #198810">"</span><span style="color: #198810">This should be bold, </span><span style="color: #198810">"</span>))<br>  run(printBold(print(<span style="color: #198810">"</span><span style="color: #198810">as should this </span><span style="color: #198810">"</span>)))<br>  run(print(<span style="color: #198810">"</span><span style="color: #198810">and this.</span><span style="color: #1d6c76">\n</span><span style="color: #198810">"</span>))<br>}))</code></pre>
    <p>We would expect output like</p>
    <p><strong>This should be bold, as should this and this</strong></p>
    <p>but we get</p>
    <p><strong>This should be bold, as should this</strong> and this.</p>
    <p>The inner call to <code>printBold</code> resets the bold styling when it finishes, which means the surrounding call to <code>printBold</code> does not have effect on later statements.</p>
    <p>The issue with ergonomics is that this code is tedious and error-prone to write. We have to pepper calls to <code>run</code> in just the right places, and even in these small examples I found myself making mistakes. This is actually another failing of composition, because we don’t have methods to combine together programs. For example, we don’t have methods to say that the program above is the sequential composition of three sub-programs.</p>
    <p>We can solve the first problem by keeping track of the state of the terminal. If <code>printBold</code> is called within a state that is already printing bold it should do nothing, otherwise it should update the state to indicate bold styling has been turned on. This means the type of programs changes from <code>() => A</code> to <code>Terminal => (Terminal, A)</code>, where <code>Terminal</code> holds the current state of the terminal.</p>
    <p>To solve the second problem we’re looking for a way to sequentially compose programs. Remember programs have type <code>Terminal => (Terminal, A)</code> and pass around the state in <code>Terminal</code>. When you hear the phrase “sequentially compose”, or see that type, your monad sense might start tingling. You are correct: this is an instance of the state monad, which we first met in <a href="#loc-272">Section 10.9</a>.</p>
    <p>Using Cats we can define</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.State<br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">Terminal</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>assuming some suitable definition of <code>Terminal</code>. Let’s accept this definition for now, and focus on defining <code>Terminal</code>.</p>
    <p><code>Terminal</code> has two pieces of state: the current bold setting and the current color. (The real terminal has much more state, but these are representative and modelling additional state does not introduce any new concepts.) The bold setting could simply be a toggle that is either on or off, but when we come to the implementation it will be easier to work with a counter that records the depth of the nesting. The current color must be a stack. We can nest color changes, and the color should change back to the surrounding color when a nested level exits. Concretely, we should be able to write code like</p>
    <pre><code data-lang="scala">printBlue(.... printRed(...) ...)</code></pre>
    <p>and have output in blue or red as we would expect.</p>
    <p>Given this we can define <code>Terminal</code> as</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Terminal</span>(bold: <span style="color: #d73948">Int</span>, color: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">boldOn</span>: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(bold <span style="color: #d73948">=</span> bold + <span style="color: #b60157">1</span>)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">boldOff</span>: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(bold <span style="color: #d73948">=</span> bold - <span style="color: #b60157">1</span>)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pushColor</span>(c: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(color <span style="color: #d73948">=</span> c :: color)<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Only call this when we know there is at least one color on the</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> stack</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">popColor</span>: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(color <span style="color: #d73948">=</span> color.tail)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">peekColor</span>: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.color.headOption<br>}</code></pre>
    <p>where we use <code>List</code> to represent the stack of color codes. (We could also use a mutable stack, as working with the state monad ensures the state will be threaded through our program.) I’ve also defined some convenience methods to simplify working with the state.</p>
    <p>With this in place we can write the rest of the code, which is shown below. Compared to the previous code I’ve shortened a few method names and abstracted the escape codes. Remember this code can be directly executed by <code>scala</code>. Just copy it into a file (e.g. <code>Terminal.scala</code>), add the <code>@main</code> annotation to <code>go</code>, and run <code>scala Terminal.scala</code>.</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c">> using dep org.typelevel::cats-core:2.13.0</span><br><br><span style="color: #d73948">import</span> cats.data.State<br><span style="color: #d73948">import</span> cats.syntax.all.*<br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> AnsiCodes</span> {<br>  <span style="color: #d73948">val</span> csiString: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #1d6c76">\u001b</span><span style="color: #198810">[</span><span style="color: #198810">"</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">csi</span>(arg: <span style="color: #4b69c6">String</span>, terminator: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">${</span>csiString<span style="color: #198810">}</span><span style="color: #198810">${</span>arg<span style="color: #198810">}</span><span style="color: #198810">${</span>terminator<span style="color: #198810">}</span><span style="color: #198810">"</span><br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> SGR stands for Select Graphic Rendition. </span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> All the codes that change formatting are SGR codes.</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">sgr</span>(arg: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    csi(arg, <span style="color: #198810">"</span><span style="color: #198810">m</span><span style="color: #198810">"</span>)<br><br>  <span style="color: #d73948">val</span> reset: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> sgr(<span style="color: #198810">"</span><span style="color: #198810">0</span><span style="color: #198810">"</span>)<br>  <span style="color: #d73948">val</span> boldOn: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> sgr(<span style="color: #198810">"</span><span style="color: #198810">1</span><span style="color: #198810">"</span>)<br>  <span style="color: #d73948">val</span> boldOff: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> sgr(<span style="color: #198810">"</span><span style="color: #198810">22</span><span style="color: #198810">"</span>)<br>  <span style="color: #d73948">val</span> red: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> sgr(<span style="color: #198810">"</span><span style="color: #198810">31</span><span style="color: #198810">"</span>)<br>  <span style="color: #d73948">val</span> blue: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> sgr(<span style="color: #198810">"</span><span style="color: #198810">34</span><span style="color: #198810">"</span>)<br>}<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Terminal</span>(bold: <span style="color: #d73948">Int</span>, color: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">boldOn</span>: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(bold <span style="color: #d73948">=</span> bold + <span style="color: #b60157">1</span>)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">boldOff</span>: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(bold <span style="color: #d73948">=</span> bold - <span style="color: #b60157">1</span>)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">pushColor</span>(c: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(color <span style="color: #d73948">=</span> c :: color)<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Only call this when we know there is at least one color on the</span><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> stack</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">popColor</span>: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.copy(color <span style="color: #d73948">=</span> color.tail)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">peekColor</span>: <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.color.headOption<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Terminal</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Terminal</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Terminal</span>(<span style="color: #b60157">0</span>, <span style="color: #4b69c6">List</span>.empty)<br>}<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">Terminal</span>, <span style="color: #4b69c6">A</span>]<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Program</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>(output: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Program</span>[<span style="color: #d73948">Unit</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">Terminal</span>, <span style="color: #d73948">Unit</span>](<br>      terminal <span style="color: #d73948">=></span> (terminal, <span style="color: #4b69c6">Console</span>.print(output))<br>    )<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">bold</span>[<span style="color: #4b69c6">A</span>](program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">for</span> {<br>      <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">State</span>.modify[<span style="color: #4b69c6">Terminal</span>] { terminal <span style="color: #d73948">=</span>><br>        <span style="color: #d73948">if</span> terminal.bold <span style="color: #d73948">==</span> <span style="color: #b60157">0</span> then <span style="color: #4b69c6">Console</span>.print(<span style="color: #4b69c6">AnsiCodes</span>.boldOn)<br>        terminal.boldOn<br>      }<br>      a <span style="color: #d73948">&lt;-</span> program<br>      <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">State</span>.modify[<span style="color: #4b69c6">Terminal</span>] { terminal <span style="color: #d73948">=</span>><br>        <span style="color: #d73948">val</span> newTerminal <span style="color: #d73948">=</span> terminal.boldOff<br>        <span style="color: #d73948">if</span> terminal.bold <span style="color: #d73948">==</span> <span style="color: #b60157">0</span> then <span style="color: #4b69c6">Console</span>.print(<span style="color: #4b69c6">AnsiCodes</span>.boldOff)<br>        newTerminal<br>      }<br>    } <span style="color: #d73948">yield</span> a<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Helper to construct methods that deal with color</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">withColor</span>[<span style="color: #4b69c6">A</span>](code: <span style="color: #4b69c6">String</span>)(program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">for</span> {<br>      <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">State</span>.modify[<span style="color: #4b69c6">Terminal</span>] { terminal <span style="color: #d73948">=</span>><br>        <span style="color: #4b69c6">Console</span>.print(code)<br>        terminal.pushColor(code)<br>      }<br>      a <span style="color: #d73948">&lt;-</span> program<br>      <span style="color: #d73948">_</span> <span style="color: #d73948">&lt;-</span> <span style="color: #4b69c6">State</span>.modify[<span style="color: #4b69c6">Terminal</span>] { terminal <span style="color: #d73948">=</span>><br>        <span style="color: #d73948">val</span> newTerminal <span style="color: #d73948">=</span> terminal.popColor<br>        newTerminal.peekColor <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> <span style="color: #4b69c6">Console</span>.print(<span style="color: #4b69c6">AnsiCodes</span>.reset)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(c) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Console</span>.print(c)<br>        }<br>        newTerminal<br>      }<br>    } <span style="color: #d73948">yield</span> a<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">red</span>[<span style="color: #4b69c6">A</span>](program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    withColor(<span style="color: #4b69c6">AnsiCodes</span>.red)(program)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">blue</span>[<span style="color: #4b69c6">A</span>](program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    withColor(<span style="color: #4b69c6">AnsiCodes</span>.blue)(program)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">run</span>[<span style="color: #4b69c6">A</span>](program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span><br>    program.runA(<span style="color: #4b69c6">Terminal</span>.empty).value<br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">go</span>(): <span style="color: #d73948">Unit</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> program <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Program</span>.blue(<br>      <span style="color: #4b69c6">Program</span>.print(<span style="color: #198810">"</span><span style="color: #198810">This is blue </span><span style="color: #198810">"</span>) >><br>        <span style="color: #4b69c6">Program</span>.red(<span style="color: #4b69c6">Program</span>.print(<span style="color: #198810">"</span><span style="color: #198810">and this is red </span><span style="color: #198810">"</span>)) >><br>        <span style="color: #4b69c6">Program</span>.bold(<span style="color: #4b69c6">Program</span>.print(<span style="color: #198810">"</span><span style="color: #198810">and this is blue and bold </span><span style="color: #198810">"</span>))<br>    ) >><br>      <span style="color: #4b69c6">Program</span>.print(<span style="color: #198810">"</span><span style="color: #198810">and this is back to normal.</span><span style="color: #1d6c76">\n</span><span style="color: #198810">"</span>)<br><br>  <span style="color: #4b69c6">Program</span>.run(program)<br>}<br></code></pre>
    <p>Having defined the structure of <code>Terminal</code>, the majority of the remaining code manipulates the <code>Terminal</code> state. Most of the methods on <code>Program</code> have a common structure that specifies a state change before and after the main program runs.</p>
    <p>Notice we don’t need to implement combinators like <code>flatMap</code> or <code>>></code> because we get them from the <code>State</code> monad. This is one of the big benefits of reusing abstractions like monads: we get a full library of methods without doing additional work.</p>
    <h4 id="loc-373">15.1.5. Composition and Reasoning</h4>
    <p>In <a href="#loc-25">Section 1.2.1</a> I argued that the core of functional programming is reasoning and composition. Both of these are central to this case study. We’ve explicitly designed the DSL for ease of reasoning. Indeed that’s the whole point of creating a DSL instead of just spitting control codes at the terminal. An example is how we paid attention to making sure nested calls work as we’d expect. Composition comes in at two levels: both our design and our implementation are compositional. Within the case study we discussed compositionality in the design. Implementationally, a <code>Program</code> is a composition of the state monad and the functions inside the state monad. The state monad provides the sequential flow of the <code>Terminal</code> state, and the functions provide the domain specific actions.</p>
    <h4 id="loc-374">15.1.6. Codata and Extensibility</h4>
    <p>We made a seemingly arbitrary choice to use a codata interpreter. Let’s now explore this choice and its implications.</p>
    <p>We described codata as programming to an interface. The interface for functions is essentially one method: the ability to apply them. This corresponds to the single interpretation we have for <code>Program</code>: run it and carry out the effects therein. If we wanted to have multiple interpretations (such as logging the <code>Terminal</code> state or saving the output to a buffer) we would need to have a richer interface. In Scala this would be a <code>trait</code> or <code>class</code> exposing more than one method.</p>
    <p>Keen readers will recall that data makes it easy to add new interpreters but hard to add new operations, while codata makes it easy to add new operations but hard to add new interpreters. We see that in action here. For example, it’s trivial to add a new color combinator by defining a method like the below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">green</span>[<span style="color: #4b69c6">A</span>](program: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  withColor(<span style="color: #4b69c6">AnsiCodes</span>.sgr(<span style="color: #198810">"</span><span style="color: #198810">32</span><span style="color: #198810">"</span>))(program)</code></pre>
    <p>However, changing <code>Program</code> to something that allows more interpretations requires changing all of the existing code.</p>
    <p>Another advantage of codata is that we can mix in arbitrary other Scala code. For example, we can use <code>map</code> like shown below.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Program</span>.print(<span style="color: #198810">"</span><span style="color: #198810">Hello</span><span style="color: #198810">"</span>).map(<span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #b60157">42</span>)</code></pre>
    <p>Using the native representation of programs (i.e. functions) gives us the entire Scala language for free. In a data representation we have to reify every kind of expression we wish to support. There is a downside to this as well: we get Scala semantics whether we like them or not. A codata representation would not be appropriate if we wanted to make an exotic language that worked in a different way.</p>
    <p>We could factor the interpreter in different ways, and it would still be a codata interpreter. For example, we could put a method to write to the terminal on the <code>Terminal</code> type. This would give us a bit more flexibility as changing the implementation of <code>Terminal</code> could, say, write to a network socket or a terminal embedded in a browser. We still have the limitation that we cannot create truly different interpretations, such as serializing programs to disk, with the codata approach. We’ll address this limitation in the next section where we look at tagless final.</p>
    <p>[^tuis]: If you’re interested in <a href="https://en.wikipedia.org/wiki/Text-based_user_interface">TUI</a> libraries you might like to look at the brilliantly named <a href="https://github.com/ratatui/ratatui">ratatui</a> for Rust, <a href="https://github.com/jtdaugherty/brick">brick</a> for Haskell, or <a href="https://textual.textualize.io/">Textual</a> for Python.</p>
    <h3 id="loc-375">15.2. Tagless Final Interpreters</h3>
    <p>We’ll now explore tagless final, an extension to the basic codata interpreter. In the terminal DSL case study we used an ad-hoc process to produce the DSL, fixing problems as we uncovered them. In this section we will be more systematic, illustrating how we can apply strategies to derive code. This will in turn make it clearer how we can derive tagless final for the basic codata interpreter.</p>
    <p>We’ll start by being explicit about the role of the different types in the codata interpreter. Following <a href="#loc-131">Section 6.2.1</a>, remember there are three different kinds of methods in an algebra:</p>
    <ul>
      <li>constructors, with type <code>A => Program</code>,</li>
      <li>combinators, with type <code>Program => Program</code>, and</li>
      <li>interpreters, with type <code>Program => A</code>.</li>
    </ul>
    <p>In the terminal DSL we defined the <code>Program</code> type as</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">State</span>[<span style="color: #4b69c6">Terminal</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>There is a single constructor, <code>print</code>, with type <code>String => Program[Unit]</code>. All of the methods that change the output style, such as <code>bold</code>, <code>red</code>, and <code>blue</code>, are combinators with the type <code>Program[A] => Program[A]</code>. Finally, there is a single interpreter, function application, with type <code>Program[A] => A</code>.</p>
    <p>In a codata interpreter the available interpretations are limited to the methods available on the <code>Program</code> type. The terminal DSL represents programs as functions, and therefore only has a single interpretation available. The key idea in tagless final, to get around this restriction, is to parameterize the <code>Program</code> type by the program operations. It’s not entirely clear what this means, so let’s see a simple example of tagless final to illustrate it.</p>
    <p>Our example will be arithmetic expressions. This is not a particularly compelling example, but it is familiar. This means we can focus on the details of tagless final without any confusion about the domain. We’ll see a more compelling example soon.</p>
    <p>We’ll start with a data interpreter, convert it to a codata interpreter, and then apply tagless final. Here’s our program type, defined using an algebraic data type. We don’t need to explicitly define constructors as they come as part of the ADT.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Expr</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Add</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Sub</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Mul</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Div</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>)<br>  <br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value: <span style="color: #d73948">Double</span>)<br>}</code></pre>
    <p>We will now define two interpreters, one that evaluates <code>Expr</code> to a <code>Double</code> and one that prints them to <code>String</code>. They are implemented using structural recursion.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> EvalInterpreter</span> {<br>  <span style="color: #d73948">import</span> Expr.*<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>(expr: <span style="color: #4b69c6">Expr</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>    expr <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Add</span>(l, r) <span style="color: #d73948">=></span> eval(l) + eval(r)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Sub</span>(l, r) <span style="color: #d73948">=></span> eval(l) - eval(r)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Mul</span>(l, r) <span style="color: #d73948">=></span> eval(l) * eval(r)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Div</span>(l, r) <span style="color: #d73948">=></span> eval(l) / eval(r)<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value) <span style="color: #d73948">=></span> value<br>    }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> PrintInterpreter</span> {<br>  <span style="color: #d73948">import</span> Expr.*<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>(expr: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    expr <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Add</span>(l, r) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>print(l)<span style="color: #198810">}</span><span style="color: #198810"> + </span><span style="color: #198810">${</span>print(r)<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Sub</span>(l, r) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>print(l)<span style="color: #198810">}</span><span style="color: #198810"> - </span><span style="color: #198810">${</span>print(r)<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Mul</span>(l, r) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>print(l)<span style="color: #198810">}</span><span style="color: #198810"> * </span><span style="color: #198810">${</span>print(r)<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Div</span>(l, r) <span style="color: #d73948">=></span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>print(l)<span style="color: #198810">}</span><span style="color: #198810"> / </span><span style="color: #198810">${</span>print(r)<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value) <span style="color: #d73948">=></span> value.toString<br>    }<br>}</code></pre>
    <p>Finally, let’s see a quick example. We start by defining an expression, in this case representing <code>1 + 2</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> onePlusTwo <span style="color: #d73948">=</span> <span style="color: #4b69c6">Expr</span>.<span style="color: #4b69c6">Add</span>(<span style="color: #4b69c6">Expr</span>.<span style="color: #4b69c6">Literal</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Expr</span>.<span style="color: #4b69c6">Literal</span>(<span style="color: #b60157">2</span>))</code></pre>
    <p>Now we can interpret this expression in two different ways.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">EvalInterpreter</span>.eval(onePlusTwo)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Double = 3.0</span><br><span style="color: #4b69c6">PrintInterpreter</span>.print(onePlusTwo)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: String = "(1.0 + 2.0)"</span></code></pre>
    <p>We have the usual trade-off for data: we can easily add more interpreters, but we cannot extend the program type with new operations.</p>
    <p>Let’s now convert this to codata. The interpreters become methods on the <code>Expr</code> type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Expr</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span><br>}</code></pre>
    <p>The constructors and combinators create instances of <code>Expr</code>. We could define explicit subtypes of <code>Expr</code> but here I’ve used anonymous subtypes to keep the code more compact. The implementation uses structural corecursion.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Expr</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(that: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Expr</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> self.eval + that.eval<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>self.print<span style="color: #198810">}</span><span style="color: #198810"> + </span><span style="color: #198810">${</span>that.print<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>    }<br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">-</span>(that: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Expr</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> self.eval - that.eval<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>self.print<span style="color: #198810">}</span><span style="color: #198810"> - </span><span style="color: #198810">${</span>that.print<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>    }<br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>(that: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Expr</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> self.eval * that.eval<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>self.print<span style="color: #198810">}</span><span style="color: #198810"> * </span><span style="color: #198810">${</span>that.print<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>    }<br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">/</span>(that: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> self <span style="color: #d73948">=</span> <span style="color: #d73948">this</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Expr</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> self.eval / that.eval<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span><span style="color: #198810">${</span>self.print<span style="color: #198810">}</span><span style="color: #198810"> / </span><span style="color: #198810">${</span>that.print<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>    }<br>  }<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Expr</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">literal</span>(value: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">new</span> <span style="color: #4b69c6">Expr</span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> value<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> value.toString<br>    }<br>}</code></pre>
    <p>Now we can create the same example as before</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> onePlusTwo <span style="color: #d73948">=</span> <span style="color: #4b69c6">Expr</span>.literal(<span style="color: #b60157">1</span>) + <span style="color: #4b69c6">Expr</span>.literal(<span style="color: #b60157">2</span>)</code></pre>
    <p>and interpret it as before</p>
    <pre><code data-lang="scala">onePlusTwo.eval<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Double = 3.0</span><br>onePlusTwo.print<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: String = "(1.0 + 2.0)"</span></code></pre>
    <p>As expected we have the opposite extensibility. We can add new program operations such as <code>sin</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">sin</span>(expr: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Expr</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Math</span>.sin(expr.eval)<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">print</span>: <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">sin(</span><span style="color: #198810">${</span>expr.print<span style="color: #198810">}</span><span style="color: #198810">)</span><span style="color: #198810">"</span><br>  }<br>}</code></pre>
    <p>However we are restricted to the two interpretations we have defined on <code>Expr</code>, <code>eval</code> and <code>print</code>.</p>
    <p>We now need to introduce a bit of terminology, so we can talk more precisely. We will use the term <strong>program algebras</strong> to refer to constructors and combinators, as they are the portion of the algebra used to create programs. We must also distinguish between programs and the <strong>program type</strong>. In the example above, <code>Expr</code> is the program type. A program is an expression that produces a value of the program type.</p>
    <p>The core of tagless final is to:</p>
    <ol>
      <li>define program algebras parameterized by their program type, and</li>
      <li>parameterize programs by the program algebras they depend on.</li>
    </ol>
    <p>For the example we have just seen we could define a program algebra as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Arithmetic</span>[<span style="color: #4b69c6">Expr</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">-</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">/</span>(l: <span style="color: #4b69c6">Expr</span>, r: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span><br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">literal</span>(value: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">Expr</span><br>}</code></pre>
    <p>Notice how it is parameterized by a type <code>Expr</code>. This is the program type.</p>
    <p>Now we can create a program. Here’s the same example we saw above, but written in tagless final style.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">onePlusTwo</span>[<span style="color: #4b69c6">Expr</span>](arithmetic: <span style="color: #4b69c6">Arithmetic</span>[<span style="color: #4b69c6">Expr</span>]): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span><br>  arithmetic.+(arithmetic.literal(<span style="color: #b60157">1</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>), arithmetic.literal(<span style="color: #b60157">2</span><span style="color: #b60157">.</span><span style="color: #b60157">0</span>))</code></pre>
    <p>Notice the distinction between a program and the program type: a program creates a value of the program type, but a program is not itself of the program type. In tagless final a program is a function from program algebras to the program type.</p>
    <p>We can finish our example by creating an instance of <code>Arithmetic</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> DoubleArithmetic</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Arithmetic</span>[<span style="color: #d73948">Double</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(l: <span style="color: #d73948">Double</span>, r: <span style="color: #d73948">Double</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>    l + r<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">-</span>(l: <span style="color: #d73948">Double</span>, r: <span style="color: #d73948">Double</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>    l - r<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>(l: <span style="color: #d73948">Double</span>, r: <span style="color: #d73948">Double</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> <br>    l * r<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">/</span>(l: <span style="color: #d73948">Double</span>, r: <span style="color: #d73948">Double</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> <br>    l / r<br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">literal</span>(value: <span style="color: #d73948">Double</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>    value<br>}</code></pre>
    <p>Now we can run our example.</p>
    <pre><code data-lang="scala">onePlusTwo(<span style="color: #4b69c6">DoubleArithmetic</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Double = 3.0</span></code></pre>
    <p>Tagless final gives us both forms of extensibility. We can add a new interpreter.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> PrintArithmetic</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Arithmetic</span>[<span style="color: #4b69c6">String</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(l: <span style="color: #4b69c6">String</span>, r: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span>$l<span style="color: #198810"> + </span>$r<span style="color: #198810">)</span><span style="color: #198810">"</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">-</span>(l: <span style="color: #4b69c6">String</span>, r: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span>$l<span style="color: #198810"> - </span>$r<span style="color: #198810">)</span><span style="color: #198810">"</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>(l: <span style="color: #4b69c6">String</span>, r: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span>$l<span style="color: #198810"> * </span>$r<span style="color: #198810">)</span><span style="color: #198810">"</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">/</span>(l: <span style="color: #4b69c6">String</span>, r: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> <br>    <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">(</span>$l<span style="color: #198810"> / </span>$r<span style="color: #198810">)</span><span style="color: #198810">"</span><br>  <br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">literal</span>(value: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span><br>    value.toString<br>}</code></pre>
    <p>This works in the same way.</p>
    <pre><code data-lang="scala">onePlusTwo(<span style="color: #4b69c6">PrintArithmetic</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: String = "(1.0 + 2.0)"</span></code></pre>
    <p>We can also define new program algebras</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Trigonometry</span>[<span style="color: #4b69c6">Expr</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">sin</span>(expr: <span style="color: #4b69c6">Expr</span>): <span style="color: #4b69c6">Expr</span><br>}</code></pre>
    <p>and use them in a program.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">sinOnePlusTwo</span>[<span style="color: #4b69c6">Expr</span>](<br>    arithmetic: <span style="color: #4b69c6">Arithmetic</span>[<span style="color: #4b69c6">Expr</span>],<br>    trigonometry: <span style="color: #4b69c6">Trigonometry</span>[<span style="color: #4b69c6">Expr</span>]<br>  ): <span style="color: #4b69c6">Expr</span> <span style="color: #d73948">=</span><br>  trigonometry.sin(onePlusTwo(arithmetic))</code></pre>
    <p>Notice that we are using composition here; the program <code>sinOnePlusTwo</code> reuses <code>onePlusTwo</code>.</p>
    <p>A few notes before we move on.</p>
    <p>In this example the program type is the same as the type we interpret to. We can use <code>Double</code> as the program type when we want to interpret to <code>Double</code>, and likewise with <code>String</code>. This is usually <em>not</em> the case. It’s just a coincidence of using arithmetic that we don’t need any additional information to calculate the final result, and hence the program type and interpreter result type are the same.</p>
    <p>There is quite a high notational overhead of tagless final, compared to the data and codata interpreters. We’ll address this later, and end up with an encoding of tagless final in Scala that looks like ordinary code. First, however, we’ll introduce a more compelling example: cross-platform user interfaces.</p>
    <h3 id="loc-376">15.3. Algebraic User Interfaces</h3>
    <p>Changing the interpretation of our terminal programs is more a theoretical than a practical problem. While it is true that different interpretations, such as saving to a text buffer, or tracing the state changes, will have niche uses, the vast majority of the time we’ll use the default interpretation. A much more motivating example is a cross-platform user interface library. Frameworks such as <a href="https://flutter.dev/">Flutter</a>, <a href="https://reactnative.dev/">React Native</a>, and <a href="https://capacitorjs.com/">Capacitor</a> derive a lot of their value by allowing programmers to define a single interface that works across web and mobile. We will build such a library here, but our ambitions are a bit reduced: we will create a terminal backend but leave other backends up to your inspiration and perspiration.</p>
    <p>Broadly speaking, there are two kinds of user interfaces. When operating, say, a digital musical instrument, we require a continuous stream of values from the user interface. In contrast, when working with a form we only require the values once, when the form is submitted. Modelling a continuous stream of values is certainly doable (see functional reactive programming) but it adds inessential complexity. Therefore we will stick with the simpler kind of interface where the user submits values once.</p>
    <p>We’ll consider each of constructors, combinators, and interpreters in turn.</p>
    <p>Constructors will define the atomic units of user interface for our library. The granularity we use here trades off expressivity and convenience. At the very lowest level we could work with vertex buffers and the like, which would make our library a general purpose graphics library. This gives us the ultimate flexibility but is far too low level for this case study. At a higher level we might think of atomic units as user interface elements like labels, buttons, text inputs, and so on. This is the level at which HTML operates. At this level we still usually require multiple elements to construct a complete control. For example, in HTML what is conceptually a single form field will often consist of separate DOM elements for the label, the input control, and the control to show validation errors, plus some Javascript to add interactivity. We will go even higher level. Our atomic elements will specify the kind of user input we wants, such as a choice between a number of elements, and leave it up to the interpreter to decide how to render this using the platform’s available controls. For example, we could render a one-of-many control using either radio buttons or a dropdown, or choose between the two depending on the number of choices. We’ll also add labels, and optional validation rules, to each element. Let’s model two such elements, to illustrate the idea.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Validation</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> The validation rule that always succeeds</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">succeed</span>[<span style="color: #4b69c6">A</span>](value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Right</span>(value)<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Controls</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">textInput</span>(<br>      label: <span style="color: #4b69c6">String</span>,<br>      placeholder: <span style="color: #4b69c6">String</span>,<br>      validation: <span style="color: #4b69c6">Validation</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> succeed<br>  ): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">String</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">choice</span>[<span style="color: #4b69c6">A</span>](label: <span style="color: #4b69c6">String</span>, options: <span style="color: #4b69c6">Seq</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>)]): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>Here we defined two controls:</p>
    <ul>
      <li><code>textInput</code>, which creates a text input where the user can enter any text that passes the validation rule; and</li>
      <li><code>choice</code>, which gives the user a choice of one of the given items.</li>
    </ul>
    <p>Notice how our modelling decisions restrict our expressivity. For example, <code>textInput</code> has a placeholder, which is displayed before the user enters input, but does not have a default value. By reducing expressivity we gain convenience. If the user’s requirements fit our model it is very easy to create controls. Also notice that we don’t have any way to control the appearance of controls. This is deliberate; we are pushing that concern into the interpreters.</p>
    <p>These controls generate an element of the program type <code>Ui</code>. Each particular interpreter, corresponding to a backend, will choose a concrete type for <code>Ui</code> corresponding to the needs of the user interface toolkit it is working with.</p>
    <p>These two constructors are enough to illustrate the idea, so we will move on to combinators. In the context of user interfaces the most common combinators will specify the layout of elements. As with the constructors there are a number of possible designs: we could allow a lot of precision in layout, as CSS does for HTML, or we could provide a few pre-defined layouts, or we could even push layout into the interpreter. In keeping with our design for the constructors, and with the need to keep things simple, we will go with a very high-level design. Our single combinator, <code>and</code>, only specifies that two elements should occur together. It leaves it up to the interpreter how this should be rendered on the screen.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Layout</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](first: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>], second: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>}</code></pre>
    <p>You might have noticed that <code>and</code> is another name for <code>product</code> from <code>Semigroupal</code>, which we encountered in <a href="#loc-296">Section 12.1</a>. It has exactly the same signature, apart from the name, and it represents the same concept as applied to user interfaces.</p>
    <p>At this point we have defined two program algebras, <code>Controls</code> and <code>Layout</code>, and shown examples of both constructors and combinators. The next step is to create an interpreter. Here we are going to create an extremely simple interpreter to illustrate the idea and to allow us to show how to write programs using our algebras. More full featured interpreters are certainly possible, but they don’t introduce any new concepts and take considerably more code.</p>
    <p>Our interpreter will use the Console IO features of the standard library to interact with the user.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.syntax.all.*<br><span style="color: #d73948">import</span> scala.io.StdIn<br><span style="color: #d73948">import</span> scala.util.Try<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span>() <span style="color: #d73948">=></span> <span style="color: #4b69c6">A</span><br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Simple</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Controls</span>[<span style="color: #4b69c6">Program</span>], <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Program</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](first: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>], second: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Program</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)] <span style="color: #d73948">=</span><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> Use Cats Semigroupal for Function0</span><br>    (first, second).tupled<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">textInput</span>(<br>      label: <span style="color: #4b69c6">String</span>,<br>      placeholder: <span style="color: #4b69c6">String</span>,<br>      validation: <span style="color: #4b69c6">Validation</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> succeed<br>  ): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>    () <span style="color: #d73948">=></span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(): <span style="color: #4b69c6">String</span> <span style="color: #d73948">=</span> {<br>        println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$label<span style="color: #198810"> (e.g. </span>$placeholder<span style="color: #198810">):</span><span style="color: #198810">"</span>)<br>        <span style="color: #d73948">val</span> input <span style="color: #d73948">=</span> <span style="color: #4b69c6">StdIn</span>.readLine<br><br>        validation(input).fold(<br>          msg <span style="color: #d73948">=></span> {<br>            println(msg)<br>            loop()<br>          },<br>          value <span style="color: #d73948">=></span> value<br>        )<br>      }<br><br>      loop()<br>    }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">choice</span>[<span style="color: #4b69c6">A</span>](label: <span style="color: #4b69c6">String</span>, options: <span style="color: #4b69c6">Seq</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>)]): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    () <span style="color: #d73948">=></span> {<br>      <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(): <span style="color: #4b69c6">A</span> <span style="color: #d73948">=</span> {<br>        println(label)<br>        options.zipWithIndex.foreach { <span style="color: #d73948">case</span> ((desc, <span style="color: #d73948">_</span>), idx) <span style="color: #d73948">=></span><br>          println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span>$idx<span style="color: #198810">: </span>$desc<span style="color: #198810">"</span>)<br>        }<br><br>        <span style="color: #4b69c6">Try</span>(<span style="color: #4b69c6">StdIn</span>.readInt).fold(<br>          <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> {<br>            println(<span style="color: #198810">"</span><span style="color: #198810">Please enter a valid number.</span><span style="color: #198810">"</span>)<br>            loop()<br>          },<br>          idx <span style="color: #d73948">=></span> {<br>            <span style="color: #d73948">if</span> idx >= <span style="color: #b60157">0</span> &amp;&amp; idx &lt; options.size then options(idx)(<span style="color: #b60157">1</span>)<br>            <span style="color: #d73948">else</span> {<br>              println(<span style="color: #198810">"</span><span style="color: #198810">Please enter a valid number.</span><span style="color: #198810">"</span>)<br>              loop()<br>            }<br>          }<br>        )<br>      }<br><br>      loop()<br>    }<br>}</code></pre>
    <p>Now we can implement a simple example.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">quiz</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]](<br>    controls: <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>],<br>    layout: <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>]<br>): <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] <span style="color: #d73948">=</span><br>  layout.and(<br>    controls.textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>),<br>    controls.choice(<br>      <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>      <span style="color: #4b69c6">Seq</span>(<br>        <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>      )<br>    )<br>  )</code></pre>
    <p>We can run this example with code like the following.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> (name, rating) <span style="color: #d73948">=</span> quiz(<span style="color: #4b69c6">Simple</span>, <span style="color: #4b69c6">Simple</span>)()<br>println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Hello </span>$name<span style="color: #198810">!</span><span style="color: #198810">"</span>)<br>println(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">You gave tagless final a rating of </span>$rating<span style="color: #198810">.</span><span style="color: #198810">"</span>)</code></pre>
    <p>Here is an example of interaction.</p>
    <pre><code data-lang="sh"><span style="color: #4b69c6">What</span> is your name<span style="color: #d73948">?</span> (e.g. John Doe)<span style="color: #4b69c6">:</span><br><span style="color: #4b69c6">Noel</span> Welsh<br><span style="color: #4b69c6">Tagless</span> final is the greatest thing ever<br><span style="color: #4b69c6">0:</span> Strongly disagree<br><span style="color: #4b69c6">1:</span> Disagree<br><span style="color: #4b69c6">2:</span> Neutral<br><span style="color: #4b69c6">3:</span> Agree<br><span style="color: #4b69c6">4:</span> Strongly agree<br><span style="color: #4b69c6">4</span><br><span style="color: #4b69c6">Hello</span> Noel Welsh!<br><span style="color: #4b69c6">You</span> gave tagless final a rating of 5.</code></pre>
    <p>We have a basic example working, but it is not very nice to work with. The way in which we write code in tagless final style is very convoluted compared to normal code. In the next section we’ll see a different encoding of tagless final that gives the user a much better experience.</p>
    <h3 id="loc-377">15.4. A Better Encoding</h3>
    <p>The basic implementation of tagless final has quite a poor developer experience. Consider the refactoring of our example below.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">name</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]](controls: <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>]): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>  controls.textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>)<br>  <br><span style="color: #d73948">def</span> <span style="color: #4b69c6">rating</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]](controls: <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>]): <span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  controls.choice(<br>    <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>    <span style="color: #4b69c6">Seq</span>(<br>      <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>    )<br>  )<br>  <br><span style="color: #d73948">def</span> <span style="color: #4b69c6">quiz</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]](<br>    controls: <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>],<br>    layout: <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>]<br>): <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] <span style="color: #d73948">=</span><br>  layout.and(name(controls), rating(controls))</code></pre>
    <p>This style of code quickly becomes tedious to write. The method signatures are quite involved, and passing the program algebras from method to method is annoying busy work.</p>
    <p>An improvement is to make the program algebras <code>given</code> instances. If we define accessors</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Controls</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]](using controls: <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>]): <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>] <span style="color: #d73948">=</span><br>    controls<br>}<br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Layout</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]](using layout: <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>]): <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>] <span style="color: #d73948">=</span><br>    layout<br>}</code></pre>
    <p>we can then write</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">name</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Controls</span>]: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>].textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>)<br>  <br><span style="color: #d73948">def</span> <span style="color: #4b69c6">rating</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Controls</span>]: <span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>].choice(<br>    <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>    <span style="color: #4b69c6">Seq</span>(<br>      <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>      <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>    )<br>  )<br>  <br><span style="color: #d73948">def</span> <span style="color: #4b69c6">quiz</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Controls</span><span style="color: #d73948">:</span> <span style="color: #4b69c6">Layout</span>]: <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>].and(name, rating)</code></pre>
    <p>This is the encoding of tagless final that is common in the Scala community, but there is still a lot of notational overhead for the developer who has to write this code. We can use Scala language features to reduce the overhead of writing code using a tagless final style to the point where is a simple as standard code.</p>
    <p>We’ll use a combination of five techniques:</p>
    <ol>
      <li>creating a base type for program algebras;</li>
      <li>making the program type a type member;</li>
      <li>defining a type for programs;</li>
      <li>defining constructors on companion objects; and</li>
      <li>using extension methods for combinators.</li>
    </ol>
    <p>This is quite involved, but each step is relatively simple. Let’s see how it works.</p>
    <p>Our first step is to create a base type for algebras. This is just a trait like</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Algebra</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]]</code></pre>
    <p>Our program algebras extend this trait.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Controls</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Algebra</span>[<span style="color: #4b69c6">Ui</span>]{<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">textInput</span>(<br>      label: <span style="color: #4b69c6">String</span>,<br>      placeholder: <span style="color: #4b69c6">String</span>,<br>      validation: <span style="color: #4b69c6">Validation</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> succeed<br>  ): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">String</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">choice</span>[<span style="color: #4b69c6">A</span>](label: <span style="color: #4b69c6">String</span>, options: <span style="color: #4b69c6">Seq</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>)]): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>]<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Layout</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Algebra</span>[<span style="color: #4b69c6">Ui</span>]{<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](first: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>], second: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>}</code></pre>
    <p>Now we make the program type a type member.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Algebra</span> {<br>  <span style="color: #d73948">type</span> <span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Controls</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Algebra</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">textInput</span>(<br>      label: <span style="color: #4b69c6">String</span>,<br>      placeholder: <span style="color: #4b69c6">String</span>,<br>      validation: <span style="color: #4b69c6">Validation</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> succeed<br>  ): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">String</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">choice</span>[<span style="color: #4b69c6">A</span>](label: <span style="color: #4b69c6">String</span>, options: <span style="color: #4b69c6">Seq</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>)]): <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>]<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Layout</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Algebra</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](first: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>], second: <span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)]<br>}</code></pre>
    <p>At this point we’ve made sufficient changes that our example program is meaningfully changed. Our starting point was</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">quiz</span>[<span style="color: #4b69c6">Ui</span>[<span style="color: #d73948">_</span>]<span style="color: #d73948">:</span> <span style="color: #4b69c6">Controls</span><span style="color: #d73948">:</span> <span style="color: #4b69c6">Layout</span>](<br>    controls: <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>],<br>    layout: <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>]<br>): <span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Layout</span>[<span style="color: #4b69c6">Ui</span>].and(<br>    <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>].textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>),<br>    <span style="color: #4b69c6">Controls</span>[<span style="color: #4b69c6">Ui</span>].choice(<br>      <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>      <span style="color: #4b69c6">Seq</span>(<br>        <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>      )<br>    )<br>  )</code></pre>
    <p>With the changes above we can instead write</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">quiz</span>(using alg: <span style="color: #4b69c6">Controls</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Layout</span>): <span style="color: #4b69c6">alg</span>.<span style="color: #4b69c6">Ui</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] <span style="color: #d73948">=</span><br>  alg.and(<br>    alg.textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>),<br>    alg.choice(<br>      <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>      <span style="color: #4b69c6">Seq</span>(<br>        <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>        <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>      )<br>    )<br>  )</code></pre>
    <p>The key changes are:</p>
    <ol>
      <li>the program algebras are a single parameter to the method, which is possible because they extend a common base type;</li>
      <li>the <code>Ui</code> type parameter is no longer needed, as it has become a type member; and</li>
      <li>we must now use a dependent method to specify the result type.</li>
    </ol>
    <p>Our next step is to define a type for programs. Programs are conceptually functions from an algebra to a program type, so we can define such a type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Program</span>[<span style="color: #d73948">-</span><span style="color: #4b69c6">Alg</span> <span style="color: #d73948">&lt;:</span> <span style="color: #4b69c6">Algebra</span>, <span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(alg: <span style="color: #4b69c6">Alg</span>): <span style="color: #4b69c6">alg</span>.<span style="color: #4b69c6">Ui</span>[<span style="color: #4b69c6">A</span>]<br>}</code></pre>
    <p>Pay particular attention to the result type, <code>alg.Ui[A]</code>. As <code>Program</code> requires a dependent method type it cannot be a standard function.</p>
    <p>The example now becomes</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> quiz <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Controls</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Layout</span>, (<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(alg: <span style="color: #4b69c6">Controls</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Layout</span>) <span style="color: #d73948">=</span><br>      alg.and(<br>        alg.textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>),<br>        alg.choice(<br>          <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>          <span style="color: #4b69c6">Seq</span>(<br>            <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>            <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>            <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>            <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>            <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>          )<br>        )<br>      )<br>  }</code></pre>
    <p>Programs are now values instead of methods. Notice that first type parameter of <code>Program</code> declares all the program algebras the program requires. It’s still quite involved to write this code, though we can simplify it a bit by using the <em>single abstract method</em> technique, which means a <code>trait</code> with a single abstract method (like <code>Program</code>) can be implemented with a function.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> quiz: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Controls</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Layout</span>, (<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>)] =<br>  (alg: <span style="color: #4b69c6">Controls</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Layout</span>) <span style="color: #d73948">=</span>><br>    alg.and(<br>      alg.textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>),<br>      alg.choice(<br>        <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>        <span style="color: #4b69c6">Seq</span>(<br>          <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>        )<br>      )<br>    )</code></pre>
    <p>Programs-as-values is the key that unlocks the next two improvements. The first is to define constructors as methods on companion objects.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">object</span><span style="color: #4b69c6"> Controls</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">textInput</span>(<br>      label: <span style="color: #4b69c6">String</span>,<br>      placeholder: <span style="color: #4b69c6">String</span>,<br>      validation: <span style="color: #4b69c6">Validation</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span> succeed<br>  ): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Controls</span>, <span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>    alg <span style="color: #d73948">=></span> alg.textInput(label, placeholder, validation)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">choice</span>[<span style="color: #4b69c6">A</span>](<br>    label: <span style="color: #4b69c6">String</span>, <br>    options: <span style="color: #4b69c6">Seq</span>[(<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>)]<br>  ): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Controls</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    alg <span style="color: #d73948">=></span> alg.choice(label, options)<br>}</code></pre>
    <p>This works because methods can now return programs.</p>
    <p>The second and final improvement is to define extension methods for combinators. Since we only have one combinator, <code>and</code>, that means a single extension method.</p>
    <pre><code data-lang="scala">extension [<span style="color: #4b69c6">Alg</span> &lt;: <span style="color: #4b69c6">Algebra</span>, <span style="color: #4b69c6">A</span>](p: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Alg</span>, <span style="color: #4b69c6">A</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>[<span style="color: #4b69c6">Alg2</span> <span style="color: #d73948">&lt;:</span> <span style="color: #4b69c6">Algebra</span>, <span style="color: #4b69c6">B</span>](<br>    second: <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Alg2</span>, <span style="color: #4b69c6">B</span>]<br>  ): <span style="color: #4b69c6">Program</span>[<span style="color: #4b69c6">Alg</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Alg2</span> <span style="color: #4b69c6">&amp;</span> <span style="color: #4b69c6">Layout</span>, (<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>)] <span style="color: #d73948">=</span><br>    alg <span style="color: #d73948">=></span> alg.and(p(alg), second(alg))<br>}</code></pre>
    <p>Pay particular attention to how the types are defined for this extension method. We define the extension on a <code>Program</code> requiring algebras <code>Alg</code>. The parameter to the <code>and</code> method is a <code>Program</code> requiring algebras <code>Alg2</code>. The result requires algebras <code>Alg &amp; Alg2 &amp; Layout</code>, which is the union of the algebras required by the two programs and the <code>Layout</code> algebra. In this way the combinators build up the algebras required for the program.</p>
    <p>The net result is that users can write</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> quiz  <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Controls</span><br>    .textInput(<span style="color: #198810">"</span><span style="color: #198810">What is your name?</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>)<br>    .and(<br>      <span style="color: #4b69c6">Controls</span>.choice(<br>        <span style="color: #198810">"</span><span style="color: #198810">Tagless final is the greatest thing ever</span><span style="color: #198810">"</span>,<br>        <span style="color: #4b69c6">Seq</span>(<br>          <span style="color: #198810">"</span><span style="color: #198810">Strongly disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">1</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Disagree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Neutral</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">4</span>,<br>          <span style="color: #198810">"</span><span style="color: #198810">Strongly agree</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span><br>        )<br>      )<br>    )</code></pre>
    <p>which looks just like normal code. The type of <code>quiz</code> shows that type inference has correctly inferred all the needed program algebras.</p>
    <pre><code data-lang="scala">quiz<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: Program[Controls &amp; Layout, Tuple2[String, Int]] = repl.MdocSession$MdocApp$$Lambda/0x00000000600f3a50@84d45f</span></code></pre>
    <p>This encoding requires more work from the library developer. However this is a one off cost, and result is that library users write much simpler code. For most applications of tagless final I think this is an appropriate trade off.</p>
    <h3 id="loc-378">15.5. Conclusions</h3>
    <p>In this chapter we looked at codata interpreters, and their extension to tagless final. Tagless final is particularly interesting because it solves the expression problem, allowing us to extend both the operations a program can perform and the interpretations of that program.</p>
    <p>Our exploration of tagless final nicely illustrates the distinction between theory and craft introduced in <a href="#loc-23">Section 1.1</a>. We saw two different encoding of tagless final in Scala (three, if we count using context bounds as a different encoding). They are both tagless final at the theory level, but are very different to implement or use as a programmer. The “standard” encoding is relatively easy to implement for the library author, but tedious and potentially confusing for the user. The improved encoding places more work on the library author, but the user writes code in a natural style.</p>
    <p>Tagless final is very powerful and it can be tempting to use it everywhere. I want to caution against this urge. Tagless final can cause problems, both for the author and the user. From the user’s point of view everything works fine until they make a mistake. Then the errors can be confusing. Consider this code, where we have missed a parameter to <code>and</code>.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Controls</span>.textInput(<span style="color: #198810">"</span><span style="color: #198810">Name</span><span style="color: #198810">"</span>, <span style="color: #198810">"</span><span style="color: #198810">John Doe</span><span style="color: #198810">"</span>).and()<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> missing argument for parameter second of method and in object MdocApp: (second: repl.MdocSession.MdocApp.Program[Alg2, B]):</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   repl.MdocSession.MdocApp.Program[</span><br><span style="color: #74747c">//</span><span style="color: #74747c">     Alg &amp; Alg2 &amp; repl.MdocSession.MdocApp.Layout, (String, B)]</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Controls.textInput("Name", "John Doe").and()</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                                        ^^^</span></code></pre>
    <p>The error message <em>does</em> tell us the problem, but it exposes a lot of the internal machinery that the user is not normally exposed to, and hence they’ll probably have difficult understanding. A straightforward data or codata interpreter does not have this problem.</p>
    <p>From the library author’s point of view, it is a lot more work to create tagless final code. It can also be difficult to onboard new developers to this code, as the techniques are not familiar to most.</p>
    <p>As always, the applicability of tagless final comes down to the context in which it is used. In cases where the extensibility is truly justified it is a powerful tool. In other cases it just introduces unwarranted complexity.</p>
    <p>The term “expression problem” was first introduced in an email by Phil Wadler <span id="loc-379">[</span><a href="#loc-565" role="doc-biblioref">89</a>], but there are much earlier sources that discuss the same issue. (One example is <a id="loc-380" href="#loc-492" role="doc-biblioref">William Cook. [16]</a>.) Tagless final was first introduced in <a id="loc-381" href="#loc-486" role="doc-biblioref">Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan. [10]</a> and expanded on in <a id="loc-382" href="#loc-521" role="doc-biblioref">Oleg Kiselyov. [45]</a>. It is just one of many solutions that have been proposed to the expression problem. I’m no expert on the wider field of solutions to the expression problem, but of the papers I’ve read the ones I’d like to highlight are object algebras <span id="loc-383">[</span><a href="#loc-539" role="doc-biblioref">63</a>] and data types à la carte <span id="loc-384">[</span><a href="#loc-558" role="doc-biblioref">82</a>]. Object algebras are, in all essentials, the same as tagless final. They were developed in object-oriented languages rather than functional programming languages, making an interesting case of convergent evolution in two distinct, but connected, fields of research. The object algebras paper is also a good read for a more formal, if brief, discussion of the theory behind the concepts we’ve been dealing with. Data types à la carte is a data, rather than codata, approach to the expression problem, and so makes an interesting contrast to tagless final. I find tagless final much simpler, so we have not explored data types à la carte in this book. Another noteworthy paper is <a id="loc-385" href="#loc-510" role="doc-biblioref">Jeremy Gibbons and Nicolas Wu. [34]</a>, which discuss the duality between data and codata and its implication for embedded domain specific languages.</p>
    <p>Tagless final was introduced using Haskell as the implementation language. The standard encoding in Scala is a direct translation of the Haskell implementation. The improved Scala encoding is my own creation. The use of the single abstract method shortcut was suggested by Jakub Kozłowski.</p>
    <h2 id="loc-386">16. Optimizing Interpreters and Compilers</h2>
    <p>In a previous chapter we introduced interpreters as a key strategy in functional programming. In many cases simple structurally recursive interpreters are sufficient. However, in a few cases we need more performance than they can offer so in this chapter we’ll turn to optimization. This is a huge subject, which we cannot hope to cover in just one book chapter. Instead we’ll focus on two techniques that I believe use key ideas found in more complex techniques: algebraic manipulation and compilation to a virtual machine.</p>
    <p>We’ll start looking at algebraic manipulation, returning to the regular expression example we used earlier. We’ll then move to virtual machine, this time using a simple arithmetic interpreter example. We’ll see how we can compile code to a stack machine, and then look at some of the optimizations that are available when we use a virtual machine.</p>
    <h3 id="loc-387">16.1. Algebraic Manipulation</h3>
    <p>Reifying a program represents it as a data structure. We can <strong>rewrite</strong> this data structure to several ends: as a way to simplify and therefore optimize the program being interpreted, but also as a general form of computation implementing the interpreter. In this section we’re going to return to our regular expression example, and show how rewriting can be used perform both of these tasks.</p>
    <p>We will use a technique known as regular expression derivatives. Regular expression derivatives provide a simple way to match a regular expression against input (with the correct semantics for union, which you may recall we didn’t deal with in the previous chapter). The derivative of a regular expression, with respect to a character, is the regular expression that remains after matching that character. Say we have the regular expression that matches the string <code>"osprey"</code>. In our library this would be <code>Regexp("osprey")</code>. The derivative with respect to the character <code>o</code> is <code>Regexp("sprey")</code>. In other words it’s the regular expression that is looking for the string <code>"sprey"</code>. The derivative with respect to the character <code>a</code> is the regular expression that matches nothing, which is written <code>Regexp.empty</code> in our library. To take a more complicated example, the derivative with respect to <code>c</code> of <code>Regexp("cats").repeat</code> is <code>Regexp("ats") ++ Regexp("cats").repeat</code>. This indicates we’re looking for the string <code>"ats"</code> followed by zero or more repeats of <code>"cats"</code></p>
    <p>All we need to do to determine if a regular expression matches some input is to calculate successive derivatives with respect to the characters in the input in the order in which they occur. If the resulting regular expression matches the empty string then we have a successful match. Otherwise it has failed to match.</p>
    <p>To implement this algorithm we need three things:</p>
    <ol>
      <li>an explicit representation of the regular expression that matches the empty string;</li>
      <li>a method that tests if a regular expression matches the empty string; and</li>
      <li>a method that computes the derivative of a regular expression with respect to a given character.</li>
    </ol>
    <p>Our starting point is the basic reified interpreter we developed in the previous chapter. This is the simplest code and therefore the easiest to work with.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span> : <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>      regexp <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>          loop(left, idx).flatMap(i <span style="color: #d73948">=></span> loop(right, i))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>          loop(first, idx).orElse(loop(second, idx))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>          loop(source, idx)<br>            .flatMap(i <span style="color: #d73948">=></span> loop(regexp, i))<br>            .orElse(<span style="color: #4b69c6">Some</span>(idx))<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>          <span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size)<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>          <span style="color: #4b69c6">None</span><br>      }<br><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>    loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>).map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size).getOrElse(<span style="color: #d73948">false</span>)<br>  }<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left: <span style="color: #4b69c6">Regexp</span>, right: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first: <span style="color: #4b69c6">Regexp</span>, second: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Empty</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <p>We want to explicitly represent the regular expression that matches the empty string, as it plays an important part in the algorithms that follow. This is simple to do: we just reify it and adjust the constructors as necessary. I’ve called this case “epsilon”, which matches the terminology used in the literature.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> ...</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> epsilon: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Epsilon</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">if</span> string.isEmpty() then <span style="color: #4b69c6">Epsilon</span><br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <p>Next up we will create a predicate that tells us if a regular expression matches the empty string. Such a regular expression is called “nullable”. The code is so simple it’s easier to read it than try to explain it in English.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">nullable</span>: <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span> left.nullable &amp;&amp; right.nullable<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span> first.nullable || second.nullable<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span> <span style="color: #d73948">true</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span> <span style="color: #d73948">false</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">=></span> <span style="color: #d73948">true</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #d73948">false</span><br>  }</code></pre>
    <p>Now we can implement the actual regular expression derivative. It consists of two parts: the method to calculate the derivative which in turn depends on a method that handles a nullable regular expression. Both parts are quite simple so I’ll give the code first and then explain the more complicated parts.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">delta</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">if</span> nullable then <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Empty</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">derivative</span>(ch: <span style="color: #d73948">Char</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>      (left.derivative(ch) ++ right).orElse(left.delta ++ right.derivative(ch))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>      first.derivative(ch).orElse(second.derivative(ch))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>      source.derivative(ch) ++ <span style="color: #d73948">this</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>      <span style="color: #d73948">if</span> string.size <span style="color: #d73948">==</span> <span style="color: #b60157">1</span> then<br>        <span style="color: #d73948">if</span> string.charAt(<span style="color: #b60157">0</span>) <span style="color: #d73948">==</span> ch then <span style="color: #4b69c6">Epsilon</span><br>        <span style="color: #d73948">else</span> <span style="color: #4b69c6">Empty</span><br>      <span style="color: #d73948">else</span> <span style="color: #d73948">if</span> string.charAt(<span style="color: #b60157">0</span>) <span style="color: #d73948">==</span> ch then <span style="color: #4b69c6">Apply</span>(string.tail)<br>      <span style="color: #d73948">else</span> <span style="color: #4b69c6">Empty</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>  }</code></pre>
    <p>I think this code is reasonably straightforward, except perhaps for the cases for <code>OrElse</code> and <code>Append</code>. The case for <code>OrElse</code> is trying to match both regular expressions simultaneously, which gets around the problem in our earlier implementation. The definition of <code>nullable</code> ensures we match if either side matches. The case for <code>Append</code> is attempting to match the <code>left</code> side if it is still looking for characters; otherwise it is attempting to match the <code>right</code> side.</p>
    <p>With this we redefine <code>matches</code> as follows.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> r <span style="color: #d73948">=</span> input.foldLeft(<span style="color: #d73948">this</span>){ (regexp, ch) <span style="color: #d73948">=></span> regexp.derivative(ch) }<br>  r.nullable<br>}</code></pre>
    <p>We can show the code works as expected.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> regexp <span style="color: #d73948">=</span> <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">Sca</span><span style="color: #198810">"</span>) ++ <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">la</span><span style="color: #198810">"</span>) ++ <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">la</span><span style="color: #198810">"</span>).repeat</code></pre>
    <pre><code data-lang="scala">regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalalalala</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: Boolean = true</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Sca</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: Boolean = false</span><br>regexp.matches(<span style="color: #198810">"</span><span style="color: #198810">Scalal</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res4: Boolean = false</span></code></pre>
    <p>It also solves the problem with the earlier implementation.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">cat</span><span style="color: #198810">"</span>).orElse(<span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">cats</span><span style="color: #198810">"</span>)).matches(<span style="color: #198810">"</span><span style="color: #198810">cats</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res5: Boolean = true</span></code></pre>
    <p>This is a nice result for a very simple algorithm. However there is a problem. You might notice that regular expression matching can become very slow. In fact we can run out of heap space trying a simple match like</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">cats</span><span style="color: #198810">"</span>).repeat.matches(<span style="color: #198810">"</span><span style="color: #198810">catscatscatscats</span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> java.lang.OutOfMemoryError: Java heap space</span></code></pre>
    <p>This happens because the derivative of the regular expression can grow very large. Look at this example, after only a few derivatives.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">cats</span><span style="color: #198810">"</span>).repeat.derivative(<span style="color: #b60157">'c'</span>).derivative(<span style="color: #b60157">'a'</span>).derivative(<span style="color: #b60157">'t'</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Regexp = OrElse(OrElse(Append(Apply(s),Repeat(Apply(cats))),Append(Empty,Append(Empty,Repeat(Apply(cats))))),OrElse(Append(Empty,Append(Empty,Repeat(Apply(cats)))),Append(Empty,OrElse(Append(Empty,Repeat(Apply(cats))),Append(Empty,Append(Empty,Repeat(Apply(cats))))))))</span></code></pre>
    <p>The root cause is that the derivative rules for <code>Append</code>, <code>OrElse</code>, and <code>Repeat</code> can produce a regular expression that is larger than the input. However this output often contains redundant information. In the example above there are multiple occurrences of <code>Append(Empty, ...)</code>, which is equivalent to just <code>Empty</code>. This is similar to adding zero or multiplying by one in arithmetic, and we can use similar algebraic simplification rules to get rid of these unnecessary elements.</p>
    <p>We can implement this simplification in one of two ways: we can make simplification a separate method that we apply to an existing <code>Regexp</code>, or we can do the simplification as we construct the <code>Regexp</code>. I’ve chosen to do the latter, modifying <code>++</code>, <code>orElse</code>, and <code>repeat</code> as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> {<br>  (<span style="color: #d73948">this</span>, that) <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> (<span style="color: #4b69c6">Epsilon</span>, re2) <span style="color: #d73948">=></span> re2<br>    <span style="color: #d73948">case</span> (re1, <span style="color: #4b69c6">Epsilon</span>) <span style="color: #d73948">=></span> re1<br>    <span style="color: #d73948">case</span> (<span style="color: #4b69c6">Empty</span>, <span style="color: #d73948">_</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>    <span style="color: #d73948">case</span> (<span style="color: #d73948">_</span>, <span style="color: #4b69c6">Empty</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>    <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br>  }<br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> {<br>  (<span style="color: #d73948">this</span>, that) <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> (<span style="color: #4b69c6">Empty</span>, re) <span style="color: #d73948">=></span> re<br>    <span style="color: #d73948">case</span> (re, <span style="color: #4b69c6">Empty</span>) <span style="color: #d73948">=></span> re<br>    <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br>  }<br>}<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span> <span style="color: #d73948">this</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Epsilon</span><br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>    <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br>  }<br>}</code></pre>
    <p>With this small change in-place, our regular expressions stay at a reasonable size for any input.</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">cats</span><span style="color: #198810">"</span>).repeat.derivative(<span style="color: #b60157">'c'</span>).derivative(<span style="color: #b60157">'a'</span>).derivative(<span style="color: #b60157">'t'</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Regexp = Append(Apply(s),Repeat(Apply(cats)))</span></code></pre>
    <p>Here’s the final code.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> {<br>    (<span style="color: #d73948">this</span>, that) <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> (<span style="color: #4b69c6">Epsilon</span>, re2) <span style="color: #d73948">=></span> re2<br>      <span style="color: #d73948">case</span> (re1, <span style="color: #4b69c6">Epsilon</span>) <span style="color: #d73948">=></span> re1<br>      <span style="color: #d73948">case</span> (<span style="color: #4b69c6">Empty</span>, <span style="color: #d73948">_</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>      <span style="color: #d73948">case</span> (<span style="color: #d73948">_</span>, <span style="color: #4b69c6">Empty</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>      <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br>    }<br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> {<br>    (<span style="color: #d73948">this</span>, that) <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> (<span style="color: #4b69c6">Empty</span>, re) <span style="color: #d73948">=></span> re<br>      <span style="color: #d73948">case</span> (re, <span style="color: #4b69c6">Empty</span>) <span style="color: #d73948">=></span> re<br>      <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br>    }<br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span> <span style="color: #d73948">this</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Epsilon</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>      <span style="color: #d73948">case</span> <span style="color: #d73948">_</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br>    }<br>  }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span> : <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br><br>  <span style="color: #74747c">/**</span><span style="color: #74747c"> True if this regular expression accepts the empty string </span><span style="color: #74747c">*/</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">nullable</span>: <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span> left.nullable &amp;&amp; right.nullable<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span> first.nullable || second.nullable<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span> <span style="color: #d73948">true</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span> <span style="color: #d73948">false</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">=></span> <span style="color: #d73948">true</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #d73948">false</span><br>    }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">delta</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">if</span> nullable then <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">else</span> <span style="color: #4b69c6">Empty</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">derivative</span>(ch: <span style="color: #d73948">Char</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>        (left.derivative(ch) ++ right).orElse(left.delta ++ right.derivative(ch))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>        first.derivative(ch).orElse(second.derivative(ch))<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>        source.derivative(ch) ++ <span style="color: #d73948">this</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">if</span> string.size <span style="color: #d73948">==</span> <span style="color: #b60157">1</span> then<br>          <span style="color: #d73948">if</span> string.charAt(<span style="color: #b60157">0</span>) <span style="color: #d73948">==</span> ch then <span style="color: #4b69c6">Epsilon</span><br>          <span style="color: #d73948">else</span> <span style="color: #4b69c6">Empty</span><br>        <span style="color: #d73948">else</span> <span style="color: #d73948">if</span> string.charAt(<span style="color: #b60157">0</span>) <span style="color: #d73948">==</span> ch then <span style="color: #4b69c6">Apply</span>(string.tail)<br>        <span style="color: #d73948">else</span> <span style="color: #4b69c6">Empty</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Empty</span><br>    }<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">val</span> r <span style="color: #d73948">=</span> input.foldLeft(<span style="color: #d73948">this</span>){ (regexp, ch) <span style="color: #d73948">=></span> regexp.derivative(ch) }<br>    r.nullable<br>  }<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left: <span style="color: #4b69c6">Regexp</span>, right: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first: <span style="color: #4b69c6">Regexp</span>, second: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Epsilon</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Empty</span><br><br>  <span style="color: #d73948">val</span> epsilon: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Epsilon</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">if</span> string.isEmpty() then <span style="color: #4b69c6">Epsilon</span><br>    <span style="color: #d73948">else</span> <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <p>Notice that our implementation is tail recursive. The only “looping” is the call to the tail recursive <code>foldLeft</code> in <code>matches</code>. No continuation-passing style transform is necessary here! (Calculating the derivatives is not tail recursive but it very unlikely this would overflow the stack.) This may not be surprising if you’ve studied theory of computation. A key result from that field is the equivalence between regular expressions and finite state machines. If you know this you may have found it a bit surprising we had to use a stack at all in our prior implementations. But hold on a minute. If we think carefully about regular expression derivatives we’ll see that they actually are continuations! A continuation means “what comes next”, which is exactly what a regular expression derviative defines for a regular expression and a particular character. So our interpreter does use CPS, but reified as a regular expression not a function, and derived through a different route.</p>
    <p>Continuations reify control-flow. That is, they give us an explicit representation of how control moves through our program. This means we can change the control flow by applying continuations in a different order. Let’s make this concrete. A regular expression derivative represents a continuation. So imagine we’re running a regular expression on data that arrives asynchronously; we want to match as much data as we have available, and then suspend the regular expression and continue matching when more data arrives. This is trival. When we run out of data we just store the current derivative. When more data arrives we continue processing using the derivative we stored. Here’s an example.</p>
    <p>Start by defining the regular expression.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> cats <span style="color: #d73948">=</span> <span style="color: #4b69c6">Regexp</span>(<span style="color: #198810">"</span><span style="color: #198810">cats</span><span style="color: #198810">"</span>).repeat</code></pre>
    <p>Process the first piece of data and store the continuation.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> next <span style="color: #d73948">=</span> <span style="color: #198810">"</span><span style="color: #198810">catsca</span><span style="color: #198810">"</span>.foldLeft(cats){ (regexp, ch) <span style="color: #d73948">=></span> regexp.derivative(ch) }</code></pre>
    <p>Continue processing when more data arrives.</p>
    <pre><code data-lang="scala"><span style="color: #198810">"</span><span style="color: #198810">tscats</span><span style="color: #198810">"</span>.foldLeft(next){ (regexp, ch) <span style="color: #d73948">=></span> regexp.derivative(ch) }</code></pre>
    <p>Notice that we could just as easily go back to a previous regular expression if we wanted to. This would give us backtracking. We don’t need backtracking for regular expressions, but for more general parsers we do. In fact with continuations we can define any control flow we like, including backtracking search, exceptions, cooperative threading, and much much more.</p>
    <p>In this section we’ve also seen the power of rewrites. Regular expression matching using derivatives works solely by rewriting the regular expression. We also used rewriting to simplify the regular expressions, avoiding the explosion in size that derivatives can cause. The abstract type of these methods is <code>Program => Program</code> so we might think they are combinators. However the implementation uses structural recursion and they serve the role of interpreters. Rewrites are the one place where the types alone can lead us astray.</p>
    <p>I hope you find regular expression derivatives interesting and a bit surprising. I certainly did when I first read about them. There is a deeper point here, which runs throughout the book: most problems have already been solved and we can save a lot of time if we can just find those solutions. I elevate this idea of the status of a strategy, which I call <strong>read the literature</strong> for reasons that will soon be clear. Most developers read the occasional blog post and might attend a conference from time to time. Many fewer, I think, read academic papers. This is unfortunate. Part of the fault is with the academics: they write in a style that is hard to read without some practice. However I think many developers think the academic literature is irrelevant. One of the goals of this book is to show the relevance of academic work, which is why each chapter conclusion sketches the development of its main ideas with links to relevant papers.</p>
    <h3 id="loc-388">16.2. From Continuations to Stacks</h3>
    <p>In the previous section we explored regular expression derivatives. We saw that they are continuations, but reified as data structures rather than the functions we used when we first worked with continuation-passing style. In this section we’ll reify continuations-as-functions as data. In doing so we’ll find continuations implicitly encode a stack structure. Explicitly reifying this structure is a step towards implementing a stack machine.</p>
    <p>We’ll start with the CPSed regular expression interpreter (not using derivatives), shown below.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Regexp</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">++</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Append</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">orElse</span>(that: <span style="color: #4b69c6">Regexp</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">OrElse</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">repeat</span>: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Repeat</span>(<span style="color: #d73948">this</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">`*`</span> : <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #d73948">this</span>.repeat<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #74747c">//</span><span style="color: #74747c"> Define a type alias so we can easily write continuations</span><br>    <span style="color: #d73948">type</span> <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]<br><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(regexp: <span style="color: #4b69c6">Regexp</span>, idx: <span style="color: #d73948">Int</span>, cont: <span style="color: #4b69c6">Continuation</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>      regexp <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>          <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> cont(<span style="color: #4b69c6">None</span>)<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(right, i, cont)<br>          }<br>          loop(left, idx, k)<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>          <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>            <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span> <span style="color: #d73948">=></span> loop(second, idx, cont)<br>            <span style="color: #d73948">case</span> some <span style="color: #d73948">=></span> cont(some)<br>          }<br>          loop(first, idx, k)<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>          <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> =<br>            <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>              <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> cont(<span style="color: #4b69c6">Some</span>(idx))<br>              <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(regexp, i, cont)<br>            }<br>          loop(source, idx, k)<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>          cont(<span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size))<br><br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>          cont(<span style="color: #4b69c6">None</span>)<br>      }<br><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>    loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>, identity).map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size).getOrElse(<span style="color: #d73948">false</span>)<br>  }<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left: <span style="color: #4b69c6">Regexp</span>, right: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first: <span style="color: #4b69c6">Regexp</span>, second: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source: <span style="color: #4b69c6">Regexp</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string: <span style="color: #4b69c6">String</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span><br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Regexp</span> {<br>  <span style="color: #d73948">val</span> empty: <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Empty</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(string: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Regexp</span> <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Apply</span>(string)<br>}</code></pre>
    <p>To reify the continuations we can apply the same recipe as before: we create a case for each place in which we construct a continuation. In our interpreter loop this is for <code>Append</code>, <code>OrElse</code>, and <code>Repeat</code>. We also construct a continuation using the identity function when we first call <code>loop</code>, which represents the continuation to call when the loop has finished. This gives us four cases.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Continuation</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">AppendK</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElseK</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RepeatK</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">DoneK</span><br>}</code></pre>
    <p>What data does each case next to hold? Let’s let look at the structure of the cases within the CPS interpreter. The case for <code>Append</code> is typical.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>  <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Cont</span> <span style="color: #d73948">=</span> <span style="color: #d73948">_</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> cont(<span style="color: #4b69c6">None</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(right, i, cont)<br>  }<br>  loop(left, idx, k)</code></pre>
    <p>The continuation <code>k</code> refers to the <code>Regexp</code> <code>right</code>, the method <code>loop</code>, and the continuation <code>cont</code>. Our reification should reflect this by holding the same data. If we consider all the cases we end up with the following definition. Notice that I implemented an <code>apply</code> method so we can still call these continuations like a function.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Loop</span> <span style="color: #d73948">= </span>(<span style="color: #4b69c6">Regexp</span>, <span style="color: #d73948">Int</span>, <span style="color: #4b69c6">Continuation</span>) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]<br>enum <span style="color: #4b69c6">Continuation</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">AppendK</span>(right: <span style="color: #4b69c6">Regexp</span>, loop: <span style="color: #4b69c6">Loop</span>, next: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElseK</span>(second: <span style="color: #4b69c6">Regexp</span>, index: <span style="color: #d73948">Int</span>, loop: <span style="color: #4b69c6">Loop</span>, next: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">RepeatK</span>(regexp: <span style="color: #4b69c6">Regexp</span>, index: <span style="color: #d73948">Int</span>, loop: <span style="color: #4b69c6">Loop</span>, next: <span style="color: #4b69c6">Continuation</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">DoneK</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(idx: <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>]): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] =<br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">AppendK</span>(right, loop, next) <span style="color: #d73948">=></span><br>        idx <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> next(<span style="color: #4b69c6">None</span>)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(right, i, next)<br>        }<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElseK</span>(second, index, loop, next) <span style="color: #d73948">=></span><br>        idx <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span> <span style="color: #d73948">=></span> loop(second, index, next)<br>          <span style="color: #d73948">case</span> some <span style="color: #d73948">=></span> next(some)<br>        }<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">RepeatK</span>(regexp, index, loop, next) <span style="color: #d73948">=></span><br>        idx <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">None</span>    <span style="color: #d73948">=></span> next(<span style="color: #4b69c6">Some</span>(index))<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Some</span>(i) <span style="color: #d73948">=></span> loop(regexp, i, next)<br>        }<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">DoneK</span> <span style="color: #d73948">=></span><br>        idx<br>    }<br>}</code></pre>
    <p>Now we can rewrite the interpreter loop using the <code>Continuation</code> type.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">matches</span>(input: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Boolean</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(<br>      regexp: <span style="color: #4b69c6">Regexp</span>,<br>      idx: <span style="color: #d73948">Int</span>,<br>      cont: <span style="color: #4b69c6">Continuation</span><br>  ): <span style="color: #4b69c6">Option</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>    regexp <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Append</span>(left, right) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">AppendK</span>(right, loop, cont)<br>        loop(left, idx, k)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">OrElse</span>(first, second) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">OrElseK</span>(second, idx, loop, cont)<br>        loop(first, idx, k)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Repeat</span>(source) <span style="color: #d73948">=></span><br>        <span style="color: #d73948">val</span> k: <span style="color: #4b69c6">Continuation</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">RepeatK</span>(regexp, idx, loop, cont)<br>        loop(source, idx, k)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Apply</span>(string) <span style="color: #d73948">=></span><br>        cont(<span style="color: #4b69c6">Option</span>.when(input.startsWith(string, idx))(idx + string.size))<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Empty</span> <span style="color: #d73948">=></span><br>        cont(<span style="color: #4b69c6">None</span>)<br>    }<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> Check we matched the entire input</span><br>  loop(<span style="color: #d73948">this</span>, <span style="color: #b60157">0</span>, <span style="color: #4b69c6">DoneK</span>)<br>    .map(idx <span style="color: #d73948">=></span> idx <span style="color: #d73948">==</span> input.size)<br>    .getOrElse(<span style="color: #d73948">false</span>)<br>}</code></pre>
    <p>The point of this construction is that we’ve reified the stack: it’s now explicitly represented as the <code>next</code> field in each <code>Continuation</code>. The stack is a last-in first-out (LIFO) data structure: the last element we add to the stack is the first element we use. (This is exactly the same as efficient use of a <code>List</code>.) We construct continuations by adding elements to the front of the existing continuation, which is exactly how we construct lists or stacks. We use continuations from front-to-back; in other words in last-in first-out (LIFO) order. This is the correct access pattern to use a list efficiently, and also the access pattern that defines a stack. Reifying the continuations as data has reified the stack. In the next section we’ll use this fact to build a compiler that targets a stack machine.</p>
    <h3 id="loc-389">16.3. Compilers and Virtual Machines</h3>
    <p>We’ve reified continuations and seen they contain a stack structure: each continuation contains a references to the next continuation, and continuations are constructed in a last-in first-out order. We’ll now, once again, reify this structure. This time we’ll create an explicit stack, giving rise to a stack-based <strong>virtual machine</strong> to run our code. We’ll also introduce a compiler, transforming our code into a sequence of operations that run on this virtual machine. We’ll then look at optimizing our virtual machine. As this code involves benchmarking, there is an [accompanying repository][stack-machine] that contains benchmarks you can run on your own computer.</p>
    <h4 id="loc-390">16.3.1. Virtual and Abstract Machines</h4>
    <p>A virtual machine is a computational machine implemented in software rather than hardware. A virtual machine runs programs written in some <strong>instruction set</strong>. The Java Virtual Machine (JVM), for example, runs programs written in Java bytecode. Closely related are <strong>abstract machines</strong>. The two terms are sometimes used interchangeably but I’ll make the distinction that a virtual machine has an implementation in software, while an abstract machine is a theoretical model without an implementation. Thus we can think of an abstract machine as a concept, and a virtual machine as a realization of a concept. This is a distinction we’ve made in many other parts of the book.</p>
    <p>As an abstract machine, stack machines are represented by models such as push down automata and the SECD machine. From abstract stack machines we firstly get the concept itself of a stack machine. The two core operations for a stack are pushing a value on to the top of the stack, and popping the top value off the stack. Function arguments and results are both passed via the stack. So, for example, a binary operation like addition will pop the top two values off the stack, add them, and push the result onto the stack. Abstract stack machines also tell us that stack machines with a single stack are not universal computers. In other words, they are not as powerful as Turing machines. If we add a second stack, or some other form of additional memory, we have a universal computer. This informs the design of virtual machines based on a stack machine.</p>
    <p>Stack machines are also very common virtual machines. The Java Virtual Machine is a stack machine, as are the .Net and WASM virtual machines. They are easy to implement, and to write compilers for. We’ve already seen how easy it is to implement an interpreter so why should we care about stack machines, or virtual machines in general? The usual answer is performance. Implementing a virtual machine opens up opportunities for optimizations that are difficult to implement in interpreters. Virtual machines also give us a lot of flexibility. It’s simple to trace or otherwise inspect the execution of a virtual machine, which makes debugging easier. They are easy to port to different platforms and languages. Virtual machines are often very compact, as is the code they run. This makes them suitable for embedded devices. Our focus will be on performance. Although we won’t go down the rabbit-hole of compiler and virtual machine optimizations, which would easily take up an entire book, we’ll at least tip-toe to the edge and peek down.</p>
    <h4 id="loc-391">16.3.2. Compilation</h4>
    <p>Let’s now briefly talk about compilation. A compiler transforms a program from one representation to another. In our case we will transform our programs represented as an algebraic data type of reified constructors and combinators into the instruction set for our virtual machine. The virtual machine itself is an interpreter for its instruction set. Computation always bottoms out in interpretation: a hardware CPU is nothing but an interpreter for it’s machine code.</p>
    <p>Notice there are two notions of program here, and two corresponding instruction sets: there is the program the structurally recursive interpreter executes, with an instruction set consisting of reified constructors and combinators, and there is the program we compile this into for the stack machine using the stack machine’s instruction set. We will call these the interpreter program and instruction set, and stack machine program and instruction set respectively.</p>
    <p>The structurally recursive interpreter is an example of a <strong>tree-walking interpreter</strong> or <strong>abstract syntax tree (AST) interpreter</strong>. The stack machine is an example of a <strong>byte-code interpreter</strong>.</p>
    <h3 id="loc-392">16.4. From Interpreter to Stack Machine</h3>
    <p>There are three parts to transforming an interpreter to a stack machine:</p>
    <ol>
      <li>creating the instruction set the stack machine will run;</li>
      <li>creating the compiler from interpreter programs to stack machine programs; and</li>
      <li>implementing the stack machine to execute stack machine instructions.</li>
    </ol>
    <p>Let’s make this concrete by returning to our arithmetic interpreter.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Expression</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">+</span>(that: <span style="color: #4b69c6">Expression</span>): <span style="color: #4b69c6">Expression</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Addition</span>(<span style="color: #d73948">this</span>, that)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">*</span>(that: <span style="color: #4b69c6">Expression</span>): <span style="color: #4b69c6">Expression</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Multiplication</span>(<span style="color: #d73948">this</span>, that)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">-</span>(that: <span style="color: #4b69c6">Expression</span>): <span style="color: #4b69c6">Expression</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Subtraction</span>(<span style="color: #d73948">this</span>, that)<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">/</span>(that: <span style="color: #4b69c6">Expression</span>): <span style="color: #4b69c6">Expression</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Division</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value)              <span style="color: #d73948">=></span> value<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Addition</span>(left, right)       <span style="color: #d73948">=></span> left.eval + right.eval<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Subtraction</span>(left, right)    <span style="color: #d73948">=></span> left.eval - right.eval<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Multiplication</span>(left, right) <span style="color: #d73948">=></span> left.eval * right.eval<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Division</span>(left, right)       <span style="color: #d73948">=></span> left.eval / right.eval<br>    }<br><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value: <span style="color: #d73948">Double</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Addition</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Subtraction</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Multiplication</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Division</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>}<br><span style="color: #d73948">object</span><span style="color: #4b69c6"> Expression</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">literal</span>(value: <span style="color: #d73948">Double</span>): <span style="color: #4b69c6">Expression</span> <span style="color: #d73948">=</span> <span style="color: #4b69c6">Literal</span>(value)<br>}</code></pre>
    <p>Interpreter programs are defined by the interpreter instruction set</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Expression</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value: <span style="color: #d73948">Double</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Addition</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Subtraction</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Multiplication</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Division</span>(left: <span style="color: #4b69c6">Expression</span>, right: <span style="color: #4b69c6">Expression</span>)<br>}</code></pre>
    <p>Transforming the interpreter instruction set to the stack machine instruction set works as follows:</p>
    <ul>
      <li>each constructor interpreter instruction corresponds to stack machine instruction carrying exactly the same data; and</li>
      <li>each combinator interpreter instruction has a corresponding stack machine instruction that carries only non-recursive data. Recursive data, which is executed by recursive calls to the interpreter, will be represented by data on the stack machine’s stack.</li>
    </ul>
    <p>Turning to the arithmetic interpreter’s instruction set, we see that <code>Literal</code> is our sole constructor and thus has a mirror in our stack machine’s instruction set. Here I’ve named the interpreter instruction set <code>Op</code> (short for “operation”), and shortened the name from <code>Literal</code> to <code>Lit</code> to make it clearer which instruction set we are using.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Op</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Lit</span>(value: <span style="color: #d73948">Double</span>)<br>}</code></pre>
    <p>The other instructions are all combinators. They also all only contain values of type <code>Expression</code>, and hence in the stack machine the corresponding values will be found on the stack. This gives us the complete stack machine instruction set.</p>
    <pre><code data-lang="scala">enum <span style="color: #4b69c6">Op</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Lit</span>(value: <span style="color: #d73948">Double</span>)<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Add</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Sub</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Mul</span><br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">Div</span><br>}</code></pre>
    <p>This completes the first step of the process. The second step is to implement the compiler. The secret to compiling for a stack machine is to transfrom instructions into <strong>reverse polish notation (RPN)</strong>. In RPN operations follow their operands. So, instead of writing <code>1 + 2</code> we write <code>1 2 +</code>. This is exactly the order in which a stack machine works. To evaluate <code>1 + 2</code> we should first push <code>1</code> onto the stack, then push <code>2</code>, and finally pop both these values, perform the addition, and push the result back to the stack. RPN also does not need nesting. To represent <code>1 + (2 + 3)</code> in RPN we simply use <code>2 3 + 1 +</code>. Doing away with brackets means that stack machine programs can be represented as a linear sequence of instructions, not a tree. Concretely, we can use <code>List[Op]</code>.</p>
    <p>How we should we implement the conversion to RPN. We are performing a transformation on an algebraic data type, our interpreter instruction set and therefore we can use structural recursion. The following code shows one way to implement this. It’s not very efficient (appending lists is a slow operation) but this doesn’t matter for our purposes.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">compile</span>: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Op</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Literal</span>(value) <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Lit</span>(value))<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Addition</span>(left, right) <span style="color: #d73948">=></span><br>      left.compile ++ right.compile ++ <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Add</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Subtraction</span>(left, right) <span style="color: #d73948">=></span><br>      left.compile ++ right.compile ++ <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Sub</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Multiplication</span>(left, right) <span style="color: #d73948">=></span><br>      left.compile ++ right.compile ++ <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Mul</span>)<br>    <span style="color: #d73948">case</span> <span style="color: #4b69c6">Division</span>(left, right) <span style="color: #d73948">=></span><br>      left.compile ++ right.compile ++ <span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Div</span>)<br>  }</code></pre>
    <p>We now are left to implement the stack machine. We’ll start by sketching out the interface for the stack machine.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> StackMachine</span>(program: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Op</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br>}</code></pre>
    <p>In this design the program is fixed for a given <code>StackMachine</code> instance, but we can run the program multiple times.</p>
    <p>Now we’ll implement <code>eval</code>. It is a structural recursion over an algebraic data type, in this case the <code>program</code> of type <code>List[Op]</code>. It’s a little bit more complicated than some of the structural recursions we have seen, because we need to implement the stack as well. We’ll represent the stack as a <code>List[Double]</code>, and define methods to push and pop the stack.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> StackMachine</span>(program: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Op</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">pop</span>(stack: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Double</span>]): (<span style="color: #d73948">Double</span>, <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Double</span>]) <span style="color: #d73948">=</span><br>      stack <span style="color: #d73948">match</span> {<br>        <span style="color: #d73948">case</span> head :: next <span style="color: #d73948">=></span> (head, next)<br>        <span style="color: #d73948">case</span> <span style="color: #4b69c6">Nil</span> <span style="color: #d73948">=></span><br>          <span style="color: #d73948">throw</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">IllegalStateException</span>(<br>            <span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">The data stack does not have any elements.</span><span style="color: #198810">"</span><br>          )<br>      }<br><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">push</span>(value: <span style="color: #d73948">Double</span>, stack: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Double</span>]): <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span><br>      value :: stack<br><br>    <span style="color: #d73948">???</span><br>  }<br>}</code></pre>
    <p>Now we can define the main stack machine loop. It takes as parameters the program and the stack, and is a structural recursion over the program.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> pop and push defined here ...</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(stack: <span style="color: #4b69c6">List</span>[<span style="color: #d73948">Double</span>], program: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Op</span>]): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>    program <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> head :: next <span style="color: #d73948">=></span><br>        head <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Lit</span>(value) <span style="color: #d73948">=></span> loop(push(value, stack), next)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Add</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> (a, s1) <span style="color: #d73948">=</span> pop(stack)<br>            <span style="color: #d73948">val</span> (b, s2) <span style="color: #d73948">=</span> pop(s1)<br>            <span style="color: #d73948">val</span> s <span style="color: #d73948">=</span> push(a + b, s2)<br>            loop(s, next)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Sub</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> (a, s1) <span style="color: #d73948">=</span> pop(stack)<br>            <span style="color: #d73948">val</span> (b, s2) <span style="color: #d73948">=</span> pop(s1)<br>            <span style="color: #d73948">val</span> s <span style="color: #d73948">=</span> push(a + b, s2)<br>            loop(s, next)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Mul</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> (a, s1) <span style="color: #d73948">=</span> pop(stack)<br>            <span style="color: #d73948">val</span> (b, s2) <span style="color: #d73948">=</span> pop(s1)<br>            <span style="color: #d73948">val</span> s <span style="color: #d73948">=</span> push(a + b, s2)<br>            loop(s, next)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Div</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> (a, s1) <span style="color: #d73948">=</span> pop(stack)<br>            <span style="color: #d73948">val</span> (b, s2) <span style="color: #d73948">=</span> pop(s1)<br>            <span style="color: #d73948">val</span> s <span style="color: #d73948">=</span> push(a + b, s2)<br>            loop(s, next)<br>        }<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Nil</span> <span style="color: #d73948">=></span> stack.head<br>    }<br><br>  loop(<span style="color: #4b69c6">List</span>.empty, program)<br>}</code></pre>
    <p>I’ve implemented a simple benchmark for this code (see [the repository][stack-machine]) and it’s roughly five times slower than the interpreter we started with. Clearly some optimization is needed.</p>
    <p>[stack-machine]: <a href="https://github.com/scalawithcats/stack-machine">https://github.com/scalawithcats/stack-machine</a></p>
    <h4 id="loc-393">16.4.1. Effectful Interpreters</h4>
    <p>One of the reasons for using the interpreter strategy is to isolate effects, such as state or input and output. An interpreter can be effectful without impacting the ability to reason about or compose the programs the interpreter runs. Sometimes the effects are the entire point of the interpreter as the program may describe effectful actions, such as parsing network data or drawing on a screen, which the interpreter then carries out. Sometimes effects may just be optimizations, which is how we are going to use them in our arithmetic stack machine.</p>
    <p>There are many inefficiencies in the stack machine we have just created. A <code>List</code> is a poor choice of data structure for both the stack and program. We can avoid a lot of pointer chasing and memory allocation by using a fixed size <code>Array</code>. The program never changes in size, and we can simply allocate a large enough stack that resizing it becomes very unlikely. We can also avoid the indirection of pushing and popping and operate directly on the stack array.</p>
    <p>The code below shows a simple implementation, which in my benchmarking is about thirty percent faster than the tree-walking interpreter.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> StackMachine</span>(program: <span style="color: #4b69c6">Array</span>[<span style="color: #4b69c6">Op</span>]) {<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> The data stack</span><br>  <span style="color: #d73948">private</span> <span style="color: #d73948">val</span> stack: <span style="color: #4b69c6">Array</span>[<span style="color: #d73948">Double</span>] <span style="color: #d73948">=</span> <span style="color: #4b69c6">Array</span>.ofDim[<span style="color: #d73948">Double</span>](<span style="color: #b60157">256</span>)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">eval</span>: <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span> {<br>    <span style="color: #74747c">//</span><span style="color: #74747c"> sp points to first free element on the stack</span><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> stack(sp - 1) is the first element with data</span><br>    <span style="color: #74747c">//</span><br>    <span style="color: #74747c">//</span><span style="color: #74747c"> pc points to the current instruction in program</span><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">loop</span>(sp: <span style="color: #d73948">Int</span>, pc: <span style="color: #d73948">Int</span>): <span style="color: #d73948">Double</span> <span style="color: #d73948">=</span><br>      <span style="color: #d73948">if</span> (pc <span style="color: #d73948">==</span> program.size) stack(sp - <span style="color: #b60157">1</span>)<br>      <span style="color: #d73948">else</span><br>        program(pc) <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Lit</span>(value) <span style="color: #d73948">=></span><br>            stack(sp) <span style="color: #d73948">=</span> value<br>            loop(sp + <span style="color: #b60157">1</span>, pc + <span style="color: #b60157">1</span>)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Add</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">1</span>)<br>            <span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">2</span>)<br>            stack(sp - <span style="color: #b60157">2</span>) <span style="color: #d73948">=</span> (a + b)<br>            loop(sp - <span style="color: #b60157">1</span>, pc + <span style="color: #b60157">1</span>)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Sub</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">1</span>)<br>            <span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">2</span>)<br>            stack(sp - <span style="color: #b60157">2</span>) <span style="color: #d73948">=</span> (a - b)<br>            loop(sp - <span style="color: #b60157">1</span>, pc + <span style="color: #b60157">1</span>)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Mul</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">1</span>)<br>            <span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">2</span>)<br>            stack(sp - <span style="color: #b60157">2</span>) <span style="color: #d73948">=</span> (a * b)<br>            loop(sp - <span style="color: #b60157">1</span>, pc + <span style="color: #b60157">1</span>)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Op</span>.<span style="color: #4b69c6">Div</span> <span style="color: #d73948">=></span><br>            <span style="color: #d73948">val</span> a <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">1</span>)<br>            <span style="color: #d73948">val</span> b <span style="color: #d73948">=</span> stack(sp - <span style="color: #b60157">2</span>)<br>            stack(sp - <span style="color: #b60157">2</span>) <span style="color: #d73948">=</span> (a / b)<br>            loop(sp - <span style="color: #b60157">1</span>, pc + <span style="color: #b60157">1</span>)<br>        }<br><br>    loop(<span style="color: #b60157">0</span>, <span style="color: #b60157">0</span>)<br>  }<br>}</code></pre>
    <h4 id="loc-394">16.4.2. Further Optimization</h4>
    <p>The above optimization is, to me, the most obvious and straightforward to implement. In this section we’ll attempt to go further, by looking at some of the optimizations described in the literature. We’ll see that there is not always a straight path to faster code.</p>
    <p>The benchmark I used is the simple recursive Fibonacci. Calculating the</p>
    <p>Fibonacci number produces a large expression for a modest choice of</p>
    <p>. I used a value of 25, and the expression has over one million elements. Notably the expressions only involve addition, and the only literals in use are zero and one. This limits the applicability of the optimizations to a wider range of inputs, but the intention is not to produce an optimized interpreter for this specific case but rather to discuss possible optimizations and issues that arise when attempting to optimize an interpreter in general.</p>
    <p>We’ll look at four different optimizations, which all use the optimized stack machine above as their base:</p>
    <ul>
      <li>
        <p><strong>Algebraic simplification</strong> performs simplifications at compile-time to produce smaller expressions. A small expression should require fewer interpreter steps and hence be faster. The only simplification I used was replacing</p>
        <p>or</p>
        <p>with</p>
        <p>. This occurs frequently in the Fibonacci series. Since the expressions we are working with have no variables or control flow we could simplify the entire expression to a single literal at compile-time. This would be an extremely good optimization but rather defeats the purpose of trying to generalize to other applications.</p>
      </li>
      <li>
        <p><strong>Byte code</strong> replaces the <code>Op</code> algebraic data type with a single byte. The hope here is that the smaller representation will lead to better cache utilization, and possibly a faster <code>match</code> expression, and therefore a faster overall interpreter. In this representation literals are also stored in a separate array of <code>Doubles</code>. More on this later.</p>
      </li>
      <li>
        <p><strong>Stack caching</strong> stores the top of the stack in a variable, which we hope will be allocated to a register and therefore be extremely fast to access. The remainder of the stack is stored in an array as above. Stack caching involves more work when pushing values on to the stack, as we must copy the value from the top into the array, but less work when popping values off the stack. The hope is that the savings will outweigh the costs.</p>
      </li>
      <li>
        <p><strong>Superinstructions</strong> replace common sequences of instructions with a single instruction. We already do this to an extent; a typical stack machine would have separate instructions for pushing and popping, but our instruction set merges these into the arithmetic operations. I used two superinstructions: one for incrementing a value, which frequently occurs in the Fibonacci, and one for adding two values from the stack and a literal.</p>
      </li>
    </ul>
    <p>Below are the benchmarks results obtained on an AMD Ryzen 5 3600 and an Apple M1, both running JDK 21. Results are shown in operations per second. The Baseline interpreter is the one using structural recursion. The Stack interpreter uses a <code>List</code> to represent the stack and program. The Optimized Stack represents the stack and program as arrays. The other interpreters build on the Optimized Stack interpreter and add the optimizations described above. The All interpreter has all the optimizations.</p>
    <p>There are a few lessons to take from this. The most important, in my opinion, is that <em>performance is not compositional</em>. The results of applying two optimizations is not simply the sum of applying the optimizations individually. You can see that most of the optimizations on their own make little or no change to performance relative to the Optimized Stack interpreter. Taken together, however, they make a significant improvement.</p>
    <p>Basic structural recursion, the Baseline interpreter, is surprisingly fast; a bit slower than the Optimized Stack interpreter on the Ryzen 5 but faster on the M1. A stack machine emulates the processor’s built-in call stack. The native call stack is extremely fast, so we need a good reason to avoid using it.</p>
    <p>Details really matter in optimization. We see the choice of data structure makes a massive difference between the Stack and Optimized Stack interpreters. An earlier version of the Byte Code interpreter had worse performance than the Optimized Stack. As best I could tell this was because I was storing literals alongside byte code, and loading a <code>Double</code> from an <code>Array[Byte]</code> (using a <code>ByteBuffer</code>) was slow. Superinstructions are very dependent on the chosen superinstructions. The superinstruction to add two values from the stack plus a literal had little effect on it’s own; in fact the interpreter with this single superinstruction was much slower on the Ryzen 5.</p>
    <p>Compilers, and JIT compilers in particular, are difficult to understand. I cannot explain why, for example, the Algebraic Simplification interpreter is so slow on the Ryzen 5. This interpreter does strictly less work than the Optimized Stack interpreter. Just like the interpreter optimizations I implemented, compiler optimizations apply in restricted cases that the algorithms recognize. If code does not match the patterns the algorithms look for, the optimizations will not apply, which can lead to strange performance cliffs. My best guess is that something about my implementation caused me to run afoul of such an issue.</p>
    <p>Finally, differences between platforms are also significant. It’s hard to know how much this due to differences in the computer’s architecture, and how much is down to differences in the JVM. Either way, be aware of which platform or platforms you expect the majority of users to run on, and don’t naively assume performance on one platform will directly translate to another.</p>
    <h3 id="loc-395">16.5. Conclusions</h3>
    <p>In this chapter we explored two main techniques for optimizing interpeters: algebraic simplification of programs, and interpretation in a virtual machine.</p>
    <p>Our regular expression derivative algorithm is taken from <a id="loc-396" href="#loc-543" role="doc-biblioref"><em>Regular-Expression Derivatives Re-Examined</em> [67</a>]. Regular expression derivatives are very easy to implement and nicely illustrate algebraic simplification. However we have to recompute the derivative on each input character. If we instead compile the regular expression to a finite state machine ahead of time, we save time when parsing input. The details of this algorithm are in the paper.</p>
    <p><a href="#loc-543" role="doc-biblioref"><em>Regular-Expression Derivatives Re-Examined</em> [67</a>] is in turn based on <a id="loc-397" href="#loc-484" role="doc-biblioref"><em>Derivatives of Regular Expressions</em> [8</a>], published in 1964. Although the style of the paper will be immediately recognizable to anyone familiar with the more theoretical end of computer science, anachronisms like “State Diagram Construction” are a reminder that this comes from the very beginnings of the discipline.</p>
    <p>Regular expression derivatives can be extended to context-free grammars and therefore used to implement parsers <span id="loc-398">[</span><a href="#loc-533" role="doc-biblioref">57</a>]. Other work has added additional operators to regular expression derivatives, such as anchors and restricted lookaround, and created best-in-class regular expression engines <span id="loc-399">[</span><a href="#loc-535" role="doc-biblioref">59</a>,<a href="#loc-562" role="doc-biblioref">86</a>]. The ease of algebraically manipulating regular expression derivatives a key to this advance.</p>
    <p>A lot of work has looked at systematically transforming an interpreter into a compiler and virtual machine. See, for example, <a id="loc-400" href="#loc-478" role="doc-biblioref"><em>From Interpreter to Compiler and Virtual Machine: A Functional Derivation</em> [2</a>] for some earlier work, and <a id="loc-401" href="#loc-479" role="doc-biblioref"><em>Calculating correct compilers</em> [3</a>] for more recent work. These are only a few examples; there is too much work in this field for me to adequately summarise.</p>
    <p>Interpreters and their optimization has a similarly enormous body of work. However, we spent a bit more time on this, and it’s also a personal interest, so I’ve been a bit more through in collecting references for this section.</p>
    <p>We looked at four techniques for optimization: algebraic simplification, byte code, stack caching, and superinstructions. Algebraic simplification is as old as algebra, and something familiar to any secondary school student. In the world of compilers, different aspects of algebraic simplification are known as constant folding, constant propagation, and common subexpression elimination. Byte code is probably as old as interpreters, and dates back to at least the 1960s in the form of <a href="https://en.wikipedia.org/wiki/P-code_machine">P-code<a id="loc-402" href="#loc-660" role="doc-noteref"><sup>84</sup></a></a>. <a id="loc-403" href="#loc-501" role="doc-biblioref"><em>Stack Caching for Interpreters</em> [25</a>] introduces the idea of stack caching, and shows some rather more complex realizations than the simple system I used. Superinstructions were introduced in <a id="loc-404" href="#loc-547" role="doc-biblioref"><em>Optimizing an ANSI C Interpreter with Superoperators</em> [71</a>]. <a id="loc-405" href="#loc-487" role="doc-biblioref"><em>Towards Superinstructions for Java Interpreters</em> [11</a>] is a nice example of applying superinstructions to an interpreted JVM.</p>
    <p>Let’s now talk about instruction dispatch, which is area we did not consider for optimization. Instruction dispatch is the process by which the interpreter chooses the code to run for a given interpreter instruction. <a id="loc-406" href="#loc-500" role="doc-biblioref"><em>The Structure and Performance of Efficient Interpreters</em> [24</a>] argues that instruction dispatch makes up a major portion of an interpreter’s execution time. The approach we used is known as switch dispatch in the literature. There are several alternative approaches. Direct threading <span id="loc-407">[</span><a href="#loc-481" role="doc-biblioref">5</a>] represents an instruction by the function that implements it. This requires first-class functions and full tail calls. It is generally considered the fastest form of dispatch. Notice that it leverages the duality between data and functions. Subroutine threading is like direct threading, but uses normal calls and returns instead of tail calls. Indirect threaded code <span id="loc-408">[</span><a href="#loc-495" role="doc-biblioref">19</a>] represents each bytecode as an index into a lookup table that points to the implementing function.</p>
    <p>Stack machines are not the only virtual machine used for implementing interpreters. Register machines are the most common alternative. The Lua virtual machine, for example, is a register machine. <a id="loc-409" href="#loc-555" role="doc-biblioref"><em>Virtual Machine Showdown: Stack versus Registers</em> [79</a>] compares the two and concludes that register machines are faster. However, register machines are more complex to implement.</p>
    <p>If you’re interested in the design considerations in a general purpose stack based instruction set, <a id="loc-410" href="#loc-515" role="doc-biblioref"><em>Bringing the Web up to Speed with WebAssembly</em> [39</a>] is the paper for you. It covers the design of WebAssembly, and the rationale behind the design choices. An interpreter for WebAssembly is described in <a id="loc-411" href="#loc-560" role="doc-biblioref"><em>A Fast In-Place Interpreter for WebAssembly</em> [84</a>]. Notice how often tail calls arise in the discussion!</p>
    <span id="loc-412"></span>
    <h2 id="loc-413">17. Creating Usable Code</h2>
    <p>APIs are interfaces and should be designed as such.</p>
    <p><code><span style="white-space: pre-wrap">&#x20;</span>scala.annotation.implicitNotFound</code> and <code>scala.annotation.implicitAmbiguous</code></p>
    <h2 id="loc-414">18. Case Study: Testing Asynchronous Code</h2>
    <p>We’ll start with a straightforward case study: how to simplify unit tests for asynchronous code by making them synchronous.</p>
    <p>Let’s return to the example from <a href="#loc-314">Chapter 13</a> where we’re measuring the uptime on a set of servers. We’ll flesh out the code into a more complete structure. There will be two components. The first is an <code>UptimeClient</code> that polls remote servers for their uptime:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.Future<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> UptimeClient</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getUptime</span>(hostname: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>]<br>}</code></pre>
    <p>We’ll also have an <code>UptimeService</code> that maintains a list of servers and allows the user to poll them for their total uptime:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.instances.future.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Applicative</span><br><span style="color: #d73948">import</span> cats.instances.list.<span style="color: #d73948">_</span>   <span style="color: #74747c">//</span><span style="color: #74747c"> for Traverse</span><br><span style="color: #d73948">import</span> cats.syntax.traverse.<span style="color: #d73948">_</span>  <span style="color: #74747c">//</span><span style="color: #74747c"> for traverse</span><br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global<br><br><span style="color: #d73948">class</span><span style="color: #4b69c6"> UptimeService</span>(client: <span style="color: #4b69c6">UptimeClient</span>) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getTotalUptime</span>(hostnames: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>]): <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>    hostnames.traverse(client.getUptime).map(<span style="color: #d73948">_</span>.sum)<br>}</code></pre>
    <p>We’ve modelled <code>UptimeClient</code> as a trait because we’re going to want to stub it out in unit tests. For example, we can write a test client that allows us to provide dummy data rather than calling out to actual servers:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">class</span><span style="color: #4b69c6"> TestUptimeClient</span>(hosts: <span style="color: #4b69c6">Map</span>[<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">UptimeClient</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getUptime</span>(hostname: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Future</span>.successful(hosts.getOrElse(hostname, <span style="color: #b60157">0</span>))<br>}</code></pre>
    <p>Now, suppose we’re writing unit tests for <code>UptimeService</code>. We want to test its ability to sum values, regardless of where it is getting them from. Here’s an example:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">testTotalUptime</span>() <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> hosts    <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<span style="color: #198810">"</span><span style="color: #198810">host1</span><span style="color: #198810">"</span> -> <span style="color: #b60157">10</span>, <span style="color: #198810">"</span><span style="color: #198810">host2</span><span style="color: #198810">"</span> -> <span style="color: #b60157">6</span>)<br>  <span style="color: #d73948">val</span> client   <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">TestUptimeClient</span>(hosts)<br>  <span style="color: #d73948">val</span> service  <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">UptimeService</span>(client)<br>  <span style="color: #d73948">val</span> actual   <span style="color: #d73948">=</span> service.getTotalUptime(hosts.keys.toList)<br>  <span style="color: #d73948">val</span> expected <span style="color: #d73948">=</span> hosts.values.sum<br>  assert(actual <span style="color: #d73948">==</span> expected)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> error:</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> Values of types scala.concurrent.Future[Int] and Int cannot be compared with == or !=</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   assert(actual == expected)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">          ^^^^^^^^^^^^^^^^^^</span></code></pre>
    <p>The code doesn’t compile because we’ve made a classic error[^warnings]. We forgot that our application code is asynchronous. Our <code>actual</code> result is of type <code>Future[Int]</code> and our <code>expected</code> result is of type <code>Int</code>. We can’t compare them directly!</p>
    <p>[^warnings]: Technically this is a <em>warning</em> not an error. It has been promoted to an error in our case because we’re using the <code>-Xfatal-warnings</code> flag on <code>scalac</code>.</p>
    <p>There are a couple of ways to solve this problem. We could alter our test code to accommodate the asynchronousness. However, there is another alternative. Let’s make our service code synchronous so our test works without modification!</p>
    <h3 id="loc-415">18.1. Abstracting over Type Constructors</h3>
    <p>We need to implement two versions of <code>UptimeClient</code>: an asynchronous one for use in production and a synchronous one for use in our unit tests:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> RealUptimeClient</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">UptimeClient</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getUptime</span>(hostname: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>]<br>}<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> TestUptimeClient</span> <span style="color: #d73948">extends</span> <span style="color: #8b41b1">UptimeClient</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getUptime</span>(hostname: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">Int</span><br>}</code></pre>
    <p>The question is: what result type should we give to the abstract method in <code>UptimeClient</code>? We need to abstract over <code>Future[Int]</code> and <code>Int</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> UptimeClient</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getUptime</span>(hostname: <span style="color: #4b69c6">String</span>): <span style="color: #d73948">?</span><span style="color: #d73948">?</span><span style="color: #d73948">?</span><br>}</code></pre>
    <p>At first this may seem difficult. We want to retain the <code>Int</code> part from each type but “throw away” the <code>Future</code> part in the test code. Fortunately, Cats provides a solution in terms of the <em>identity type</em>, <code>Id</code>, that we discussed way back in <a href="#loc-248">Section 10.3</a>. <code>Id</code> allows us to “wrap” types in a type constructor without changing their meaning:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">package</span> <span style="color: #4b69c6">cats</span><br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Id</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span></code></pre>
    <p><code>Id</code> allows us to abstract over the return types in <code>UptimeClient</code>. Implement this now:</p>
    <ul>
      <li>
        <p>write a trait definition for <code>UptimeClient</code> that accepts a type constructor <code>F[_]</code> as a parameter;</p>
      </li>
      <li>
        <p>extend it with two traits, <code>RealUptimeClient</code> and <code>TestUptimeClient</code>, that bind <code>F</code> to <code>Future</code> and <code>Id</code> respectively;</p>
      </li>
      <li>
        <p>write out the method signature for <code>getUptime</code> in each case to verify that it compiles.</p>
      </li>
    </ul>
    <p>You should now be able to flesh your definition of <code>TestUptimeClient</code> out into a full class based on a <code>Map[String, Int]</code> as before.</p>
    <h3 id="loc-416">18.2. Abstracting over Monads</h3>
    <p>Let’s turn our attention to <code>UptimeService</code>. We need to rewrite it to abstract over the two types of <code>UptimeClient</code>. We’ll do this in two stages: first we’ll rewrite the class and method signatures, then the method bodies. Starting with the method signatures:</p>
    <ul>
      <li>
        <p>comment out the body of <code>getTotalUptime</code> (replace it with <code>???</code> to make everything compile);</p>
      </li>
      <li>
        <p>add a type parameter <code>F[_]</code> to <code>UptimeService</code> and pass it on to <code>UptimeClient</code>.</p>
      </li>
    </ul>
    <p>Now uncomment the body of <code>getTotalUptime</code>. You should get a compilation error similar to the following:</p>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> &lt;console>:28: error: could not find implicit value for</span><br><span style="color: #74747c">//</span><span style="color: #74747c">               evidence parameter of type cats.Applicative[F]</span><br><span style="color: #74747c">//</span><span style="color: #74747c">            hostnames.traverse(client.getUptime).map(_.sum)</span><br><span style="color: #74747c">//</span><span style="color: #74747c">                              ^</span></code></pre>
    <p>The problem here is that <code>traverse</code> only works on sequences of values that have an <code>Applicative</code>. In our original code we were traversing a <code>List[Future[Int]]</code>. There is an applicative for <code>Future</code> so that was fine. In this version we are traversing a <code>List[F[Int]]</code>. We need to <em>prove</em> to the compiler that <code>F</code> has an <code>Applicative</code>. Do this by adding an implicit constructor parameter to <code>UptimeService</code>.</p>
    <p>Finally, let’s turn our attention to our unit tests. Our test code now works as intended without any modification. We create an instance of <code>TestUptimeClient</code> and wrap it in an <code>UptimeService</code>. This effectively binds <code>F</code> to <code>Id</code>, allowing the rest of the code to operate synchronously without worrying about monads or applicatives:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">testTotalUptime</span>() <span style="color: #d73948">=</span> {<br>  <span style="color: #d73948">val</span> hosts    <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<span style="color: #198810">"</span><span style="color: #198810">host1</span><span style="color: #198810">"</span> -> <span style="color: #b60157">10</span>, <span style="color: #198810">"</span><span style="color: #198810">host2</span><span style="color: #198810">"</span> -> <span style="color: #b60157">6</span>)<br>  <span style="color: #d73948">val</span> client   <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">TestUptimeClient</span>(hosts)<br>  <span style="color: #d73948">val</span> service  <span style="color: #d73948">=</span> <span style="color: #d73948">new</span> <span style="color: #4b69c6">UptimeService</span>(client)<br>  <span style="color: #d73948">val</span> actual   <span style="color: #d73948">=</span> service.getTotalUptime(hosts.keys.toList)<br>  <span style="color: #d73948">val</span> expected <span style="color: #d73948">=</span> hosts.values.sum<br>  assert(actual <span style="color: #d73948">==</span> expected)<br>}<br><br>testTotalUptime()</code></pre>
    <h3 id="loc-417">18.3. Summary</h3>
    <p>This case study provides an example of how Cats can help us abstract over different computational scenarios. We used the <code>Applicative</code> type class to abstract over asynchronous and synchronous code. Leaning on a functional abstraction allows us to specify the sequence of computations we want to perform without worrying about the details of the implementation.</p>
    <p>Back in <a href="#loc-310">Figure 11</a>, we showed a “stack” of computational type classes that are meant for exactly this kind of abstraction. Type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>Traverse</code> provide abstract implementations of patterns such as mapping, zipping, sequencing, and iteration. The mathematical laws on those types ensure that they work together with a consistent set of semantics.</p>
    <p>We used <code>Applicative</code> in this case study because it was the least powerful type class that did what we needed. If we had required <code>flatMap</code>, we could have swapped out <code>Applicative</code> for <code>Monad</code>. If we had needed to abstract over different sequence types, we could have used <code>Traverse</code>. There are also type classes like <code>ApplicativeError</code> and <code>MonadError</code> that help model failures as well as successful computations.</p>
    <p>Let’s move on now to a more complex case study where type classes will help us produce something more interesting: a map-reduce-style framework for parallel processing.</p>
    <h2 id="loc-418">19. Error Handling</h2>
    <h2 id="loc-419">20. Case Study: Map-Reduce</h2>
    <p>&lt;!– TODO:</p>
    <ul>
      <li>DONE - talk about map-reduce - it’s just foldMap</li>
      <li>DONE - introduce/reimplement foldMap</li>
      <li>
        <p>DONE - implement parallelFoldMap to mimic map-reduce</p>
        <ul>
          <li>DONE - mention that we’re specifically imitating multi-machine map-reduce where we need to split data between machines in large blocks</li>
          <li>DONE - implement in terms of our foldMap first</li>
          <li>DONE - then implement in terms of Cats’ foldMap</li>
          <li>DONE - talk about traverse</li>
        </ul>
      </li>
      <li>
        <p>summary</p>
        <ul>
          <li>DONE - real-world map-reduce has communication costs</li>
          <li>DONE - multi-cpu map-reduce doesn’t have communication costs</li>
          <li>DONE - parallelFoldMap mimics multi-machine</li>
          <li>DONE - our final version of parallelFoldMap (based on traverse) is far simpler</li>
          <li>
            <p>talk about substitution and the things it doesn’t model:</p>
            <ul>
              <li>performance</li>
              <li>parallelism</li>
              <li>side-effects (future starts immediately)</li>
              <li>etc…</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <p>TODO:</p>
    <ul>
      <li>DONE - drop the current foldMapM stuff</li>
      <li>DONE - maybe move it elsewhere</li>
    </ul>
    <p>–></p>
    <p>In this case study we’re going to implement a simple-but-powerful parallel processing framework using <code>Monoids</code>, <code>Functors</code>, and a host of other goodies.</p>
    <p>If you have used Hadoop or otherwise worked in “big data” you will have heard of <a href="http://research.google.com/archive/map-reduce.html">MapReduce<a id="loc-420" href="#loc-661" role="doc-noteref"><sup>85</sup></a></a>, which is a programming model for doing parallel data processing across clusters of machines (aka “nodes”). As the name suggests, the model is built around a <em>map</em> phase, which is the same <code>map</code> function we know from Scala and the <code>Functor</code> type class, and a <em>reduce</em> phase, which we usually call <code>fold</code>[^hadoop-shuffle] in Scala.</p>
    <p>[^hadoop-shuffle]: In Hadoop there is also a shuffle phase that we will ignore here.</p>
    <h3 id="loc-421">20.1. Parallelizing <strong>map</strong> and <strong>fold</strong></h3>
    <p>Recall the general signature for <code>map</code> is to apply a function <code>A => B</code> to a <code>F[A]</code>, returning a <code>F[B]</code>:</p>
    <p>!<a href="generic-map.svg">generic-map.svg</a>, caption: [Type chart: functor map]</p>
    <p><code>map</code> transforms each individual element in a sequence independently. We can easily parallelize <code>map</code> because there are no dependencies between the transformations applied to different elements (the type signature of the function <code>A => B</code> shows us this, assuming we don’t use side-effects not reflected in the types).</p>
    <p>What about <code>fold</code>? We can implement this step with an instance of <code>Foldable</code>. Not every functor also has an instance of foldable but we can implement a map-reduce system on top of any data type that has both of these type classes. Our reduction step becomes a <code>foldLeft</code> over the results of the distributed <code>map</code>.</p>
    <p>!<a href="generic-foldleft.svg">generic-foldleft.svg</a>, caption: [Type chart: fold]</p>
    <p>By distributing the reduce step we lose control over the order of traversal. Our overall reduction may not be entirely left-to-right—we may reduce left-to-right across several subsequences and then combine the results. To ensure correctness we need a reduction operation that is <em>associative</em>:</p>
    <pre><code data-lang="scala">reduce(a1, reduce(a2, a3)) <span style="color: #d73948">==</span> reduce(reduce(a1, a2), a3)</code></pre>
    <p>If we have associativity, we can arbitrarily distribute work between our nodes provided the subsequences at every node stay in the same order as the initial dataset.</p>
    <p>Our fold operation requires us to seed the computation with an element of type <code>B</code>. Since fold may be split into an arbitrary number of parallel steps, the seed should not affect the result of the computation. This naturally requires the seed to be an <em>identity</em> element:</p>
    <pre><code data-lang="scala">reduce(seed, a1) <span style="color: #d73948">==</span> reduce(a1, seed) <span style="color: #d73948">==</span> a1</code></pre>
    <p>In summary, our parallel fold will yield the correct results if:</p>
    <ul>
      <li>we require the reducer function to be associative;</li>
      <li>we seed the computation with the identity of this function.</li>
    </ul>
    <p>What does this pattern sound like? That’s right, we’ve come full circle back to <code>Monoid</code>, the first type class we discussed in this book. We are not the first to recognise the importance of monoids. The <a href="http://arxiv.org/abs/1304.7544">monoid design pattern for map-reduce jobs<a id="loc-422" href="#loc-662" role="doc-noteref"><sup>86</sup></a></a> is at the core of recent big data systems such as Twitter’s <a href="https://github.com/twitter/summingbird">Summingbird<a id="loc-423" href="#loc-663" role="doc-noteref"><sup>87</sup></a></a>.</p>
    <p>In this project we’re going to implement a very simple single-machine map-reduce. We’ll start by implementing a method called <code>foldMap</code> to model the data-flow we need.</p>
    <h3 id="loc-424">20.2. Implementing <strong>foldMap</strong></h3>
    <p>We saw <code>foldMap</code> briefly back when we covered <code>Foldable</code>. It is one of the derived operations that sits on top of <code>foldLeft</code> and <code>foldRight</code>. However, rather than use <code>Foldable</code>, we will re-implement <code>foldMap</code> here ourselves as it will provide useful insight into the structure of map-reduce.</p>
    <p>Start by writing out the signature of <code>foldMap</code>. It should accept the following parameters:</p>
    <ul>
      <li>a sequence of type <code>Vector[A]</code>;</li>
      <li>a function of type <code>A => B</code>, where there is a <code>Monoid</code> for <code>B</code>;</li>
    </ul>
    <p>You will have to add implicit parameters or context bounds to complete the type signature.</p>
    <p>Now implement the body of <code>foldMap</code>. Use the flow chart in <a href="#loc-425">Figure 16</a> as a guide to the steps required:</p>
    <ol>
      <li>start with a sequence of items of type <code>A</code>;</li>
      <li>map over the list to produce a sequence of items of type <code>B</code>;</li>
      <li>use the <code>Monoid</code> to reduce the items to a single <code>B</code>.</li>
    </ol>
    <figure id="loc-425">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQyMHB4IiBoZWlnaHQ9IjEwNDFweCIgdmlld0JveD0iMCAwIDE0MjAgMTA0MSIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggNDIgKDM2NzgxKSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5mb2xkLW1hcDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMyIgcG9pbnRzPSI1MC41OTUwODY1IDc2LjE4MDY4NjUgMjQuMjY5ODc1MyA5MC4wMjA2NjkxIDI5LjI5NzU0MzIgNjAuNzA3MTE1NiA4IDM5Ljk0NzE0MTggMzcuNDMyNDgwOSAzNS42NzAzNTIgNTAuNTk1MDg2NSA5IDYzLjc1NzY5MjEgMzUuNjcwMzUyIDkzLjE5MDE3MjkgMzkuOTQ3MTQxOCA3MS44OTI2Mjk3IDYwLjcwNzExNTYgNzYuOTIwMjk3NyA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtNSIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci02Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03IiB4PSIxMDAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItOCI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtOSIgeD0iMjAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTEwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0xMSIgcG9pbnRzPSI1MC41OTUwODY1IDc2LjE4MDY4NjUgMjQuMjY5ODc1MyA5MC4wMjA2NjkxIDI5LjI5NzU0MzIgNjAuNzA3MTE1NiA4IDM5Ljk0NzE0MTggMzcuNDMyNDgwOSAzNS42NzAzNTIgNTAuNTk1MDg2NSA5IDYzLjc1NzY5MjEgMzUuNjcwMzUyIDkzLjE5MDE3MjkgMzkuOTQ3MTQxOCA3MS44OTI2Mjk3IDYwLjcwNzExNTYgNzYuOTIwMjk3NyA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTIiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0xMyIgcG9pbnRzPSIxNDkuNTk1MDg2IDc2LjE4MDY4NjUgMTIzLjI2OTg3NSA5MC4wMjA2NjkxIDEyOC4yOTc1NDMgNjAuNzA3MTE1NiAxMDcgMzkuOTQ3MTQxOCAxMzYuNDMyNDgxIDM1LjY3MDM1MiAxNDkuNTk1MDg2IDkgMTYyLjc1NzY5MiAzNS42NzAzNTIgMTkyLjE5MDE3MyAzOS45NDcxNDE4IDE3MC44OTI2MyA2MC43MDcxMTU2IDE3NS45MjAyOTggOTAuMDIwNjY5MSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg1LjE5MDE3MjkiIGhlaWdodD0iODEuMDIwNjY5MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMTUiIHBvaW50cz0iMjQ5LjU5NTA4NiA3Ni4xODA2ODY1IDIyMy4yNjk4NzUgOTAuMDIwNjY5MSAyMjguMjk3NTQzIDYwLjcwNzExNTYgMjA3IDM5Ljk0NzE0MTggMjM2LjQzMjQ4MSAzNS42NzAzNTIgMjQ5LjU5NTA4NiA5IDI2Mi43NTc2OTIgMzUuNjcwMzUyIDI5Mi4xOTAxNzMgMzkuOTQ3MTQxOCAyNzAuODkyNjMgNjAuNzA3MTE1NiAyNzUuOTIwMjk4IDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTE3IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTE4Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xOSIgeD0iMTAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0yMSIgeD0iMjAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIyIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0yMyIgY3g9IjUwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0yNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTIzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMjUiIGN4PSIxNTAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTI2IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMjUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0yNyIgY3g9IjI1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMjgiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0yNyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgPC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImZvbGQtbWFwIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0zIiBmaWxsPSIjRkZGRkZGIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTQyMCIgaGVpZ2h0PSIxMDQxIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJyZWR1Y2VkLUIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDY1Mi4wMDAwMDAsIDc4MC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktMTgiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJtYXBwZWQtQiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTUyLjAwMDAwMCwgNDgwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci02KSIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTgpIiB4bGluazpocmVmPSIjcGF0aC03Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC03Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMTApIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMS1Db3B5LTIyIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xMikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktMjYiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTE0KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS0zMCIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTYpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTE1Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iSW5pdGlhbC1BIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NTIuMDAwMDAwLCAxODAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xOCkiIHhsaW5rOmhyZWY9IiNwYXRoLTE3Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0xNyI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0yMCkiIHhsaW5rOmhyZWY9IiNwYXRoLTE5Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0xOSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMjEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0yMikiIHhsaW5rOmhyZWY9IiNwYXRoLTIxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0yMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS0yMCIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMjQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTIzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTIxIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0yNikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMjUiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHktMjIiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTI4KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0yNyI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHRleHQgaWQ9InJlc3VsdC1sYWJlbCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTkzLjQ1NjA1NSIgeT0iOTgwIj40LiBGaW5hbCByZXN1bHQ8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxnIGlkPSJyZWR1Y2UtbGFiZWwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU0Ny4wMDAwMDAsIDY0OC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJhcnJvdyIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU0LjA3MTYxOCwgNDAuMDAwMDAwKSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtMTU0LjA3MTYxOCwgLTQwLjAwMDAwMCkgIiBwb2ludHM9IjExNC4wNzE2MTggMjAgMTU0LjA3MTYxOCAyMCAxNTQuMDcxNjE4IDMuNTUyNzEzNjhlLTE1IDE5NC4wNzE2MTggMzkuNDk3NzY3MSAxNTQuMDcxNjE4IDgwIDE1NC4wNzE2MTggNjAgMTE0LjA3MTYxOCA2MCI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHRleHQgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjAuNDEwMTU2MjUiIHk9IjQ0Ij4zLiBGb2xkL3JlZHVjZSBzdGVwPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0ibWFwLWxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MDcuMDAwMDAwLCAzNTAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iYXJyb3ciIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDk5LjAwMDAwMCwgNDAuMDAwMDAwKSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtOTkuMDAwMDAwLCAtNDAuMDAwMDAwKSAiIHBvaW50cz0iNTkgMjAgOTkgMjAgOTkgMy41NTI3MTM2OGUtMTUgMTM5IDM5LjQ5Nzc2NzEgOTkgODAgOTkgNjAgNTkgNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDx0ZXh0IGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMzYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIwLjQ0ODI0MjE4OCIgeT0iNDIiPjIuIE1hcCBzdGVwPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iaW5pdGlhbC1sYWJlbCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTE2LjM2NzE4OCIgeT0iOTQiPjEuIEluaXRpYWwgZGF0YSBzZXF1ZW5jZTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==">
      <figcaption>Figure 16: <em>foldMap</em> algorithm</figcaption>
    </figure>
    <p>Here’s some sample output for reference:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.instances.int.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Monoid</span></code></pre>
    <pre><code data-lang="scala">foldMap(<span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))(identity)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res1: Int = 6</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.instances.string.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Monoid</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #74747c">//</span><span style="color: #74747c"> Mapping to a String uses the concatenation monoid:</span><br>foldMap(<span style="color: #4b69c6">Vector</span>(<span style="color: #b60157">1</span>, <span style="color: #b60157">2</span>, <span style="color: #b60157">3</span>))(<span style="color: #d73948">_</span>.toString + <span style="color: #198810">"</span><span style="color: #198810">! </span><span style="color: #198810">"</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res2: String = "1! 2! 3! "</span><br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Mapping over a String to produce a String:</span><br>foldMap(<span style="color: #198810">"</span><span style="color: #198810">Hello world!</span><span style="color: #198810">"</span>.toVector)(<span style="color: #d73948">_</span>.toString.toUpperCase)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res3: String = "HELLO WORLD!"</span></code></pre>
    <h3 id="loc-426">20.3. Parallelising <strong>foldMap</strong></h3>
    <p>Now we have a working single-threaded implementation of <code>foldMap</code>, let’s look at distributing work to run in parallel. We’ll use our single-threaded version of <code>foldMap</code> as a building block.</p>
    <p>We’ll write a multi-CPU implementation that simulates the way we would distribute work in a map-reduce cluster as shown in <a href="#loc-427">Figure 17</a>:</p>
    <ol>
      <li>we start with an initial list of all the data we need to process;</li>
      <li>we divide the data into batches, sending one batch to each CPU;</li>
      <li>the CPUs run a batch-level map phase in parallel;</li>
      <li>the CPUs run a batch-level reduce phase in parallel, producing a local result for each batch;</li>
      <li>we reduce the results for each batch to a single final result.</li>
    </ol>
    <figure id="loc-427">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQyMHB4IiBoZWlnaHQ9IjE2NDBweCIgdmlld0JveD0iMCAwIDE0MjAgMTY0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggNDIgKDM2NzgxKSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5wYXJhbGxlbC1mb2xkLW1hcDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMyIgcG9pbnRzPSI1MC41OTUwODY1IDc2LjY3MDM1MiAyNC4yNjk4NzUzIDkwLjUxMDMzNDUgMjkuMjk3NTQzMiA2MS4xOTY3ODExIDggNDAuNDM2ODA3MyAzNy40MzI0ODA5IDM2LjE2MDAxNzQgNTAuNTk1MDg2NSA5LjQ4OTY2NTQ1IDYzLjc1NzY5MjEgMzYuMTYwMDE3NCA5My4xOTAxNzI5IDQwLjQzNjgwNzMgNzEuODkyNjI5NyA2MS4xOTY3ODExIDc2LjkyMDI5NzcgOTAuNTEwMzM0NSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTUiIHg9Ii0xLjQyMTA4NTQ3ZS0xNCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci02Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03IiB4PSI3MjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItOCI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtOSIgeD0iMzYwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTEwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xMSIgeD0iMTA4MCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0xMiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMTMiIHBvaW50cz0iNTAuNTk1MDg2NSA3Ni4xODA2ODY1IDI0LjI2OTg3NTMgOTAuMDIwNjY5MSAyOS4yOTc1NDMyIDYwLjcwNzExNTYgOCAzOS45NDcxNDE4IDM3LjQzMjQ4MDkgMzUuNjcwMzUyIDUwLjU5NTA4NjUgOSA2My43NTc2OTIxIDM1LjY3MDM1MiA5My4xOTAxNzI5IDM5Ljk0NzE0MTggNzEuODkyNjI5NyA2MC43MDcxMTU2IDc2LjkyMDI5NzcgOTAuMDIwNjY5MSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg1LjE5MDE3MjkiIGhlaWdodD0iODEuMDIwNjY5MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMTUiIHBvaW50cz0iNDEwLjU5NTA4NiA3Ni4xODA2ODY1IDM4NC4yNjk4NzUgOTAuMDIwNjY5MSAzODkuMjk3NTQzIDYwLjcwNzExNTYgMzY4IDM5Ljk0NzE0MTggMzk3LjQzMjQ4MSAzNS42NzAzNTIgNDEwLjU5NTA4NiA5IDQyMy43NTc2OTIgMzUuNjcwMzUyIDQ1My4xOTAxNzMgMzkuOTQ3MTQxOCA0MzEuODkyNjMgNjAuNzA3MTE1NiA0MzYuOTIwMjk4IDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTE3IiBwb2ludHM9Ijc3MC41OTUwODYgNzYuMTgwNjg2NSA3NDQuMjY5ODc1IDkwLjAyMDY2OTEgNzQ5LjI5NzU0MyA2MC43MDcxMTU2IDcyOCAzOS45NDcxNDE4IDc1Ny40MzI0ODEgMzUuNjcwMzUyIDc3MC41OTUwODYgOSA3ODMuNzU3NjkyIDM1LjY3MDM1MiA4MTMuMTkwMTczIDM5Ljk0NzE0MTggNzkxLjg5MjYzIDYwLjcwNzExNTYgNzk2LjkyMDI5OCA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTgiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTciPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC0xOSIgcG9pbnRzPSIxMTMwLjU5NTA5IDc2LjE4MDY4NjUgMTEwNC4yNjk4OCA5MC4wMjA2NjkxIDExMDkuMjk3NTQgNjAuNzA3MTE1NiAxMDg4IDM5Ljk0NzE0MTggMTExNy40MzI0OCAzNS42NzAzNTIgMTEzMC41OTUwOSA5IDExNDMuNzU3NjkgMzUuNjcwMzUyIDExNzMuMTkwMTcgMzkuOTQ3MTQxOCAxMTUxLjg5MjYzIDYwLjcwNzExNTYgMTE1Ni45MjAzIDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0yMCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xOSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTIxIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIyIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0yMyIgeD0iNzIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTI0Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0yNSIgeD0iMTAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTI2Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0yNyIgeD0iODIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTI4Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0yOSIgeD0iMjAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTMwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0zMSIgeD0iOTIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTMyIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0zMyIgeD0iMzYwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTM0Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0zNSIgeD0iMTA4MCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0zNiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMzciIHg9IjQ2MCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0zOCI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMzkiIHg9IjExODAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItNDAiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTQxIiB4PSI1NjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItNDIiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTQzIiB4PSIxMjgwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTQ0Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC00NSIgcG9pbnRzPSI1MC41OTUwODY1IDc2LjE4MDY4NjUgMjQuMjY5ODc1MyA5MC4wMjA2NjkxIDI5LjI5NzU0MzIgNjAuNzA3MTE1NiA4IDM5Ljk0NzE0MTggMzcuNDMyNDgwOSAzNS42NzAzNTIgNTAuNTk1MDg2NSA5IDYzLjc1NzY5MjEgMzUuNjcwMzUyIDkzLjE5MDE3MjkgMzkuOTQ3MTQxOCA3MS44OTI2Mjk3IDYwLjcwNzExNTYgNzYuOTIwMjk3NyA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNDYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNDUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC00NyIgcG9pbnRzPSI0MTAuNTk1MDg2IDc2LjE4MDY4NjUgMzg0LjI2OTg3NSA5MC4wMjA2NjkxIDM4OS4yOTc1NDMgNjAuNzA3MTE1NiAzNjggMzkuOTQ3MTQxOCAzOTcuNDMyNDgxIDM1LjY3MDM1MiA0MTAuNTk1MDg2IDkgNDIzLjc1NzY5MiAzNS42NzAzNTIgNDUzLjE5MDE3MyAzOS45NDcxNDE4IDQzMS44OTI2MyA2MC43MDcxMTU2IDQzNi45MjAyOTggOTAuMDIwNjY5MSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTQ4IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg1LjE5MDE3MjkiIGhlaWdodD0iODEuMDIwNjY5MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTQ3Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNDkiIHBvaW50cz0iNzcwLjU5NTA4NiA3Ni4xODA2ODY1IDc0NC4yNjk4NzUgOTAuMDIwNjY5MSA3NDkuMjk3NTQzIDYwLjcwNzExNTYgNzI4IDM5Ljk0NzE0MTggNzU3LjQzMjQ4MSAzNS42NzAzNTIgNzcwLjU5NTA4NiA5IDc4My43NTc2OTIgMzUuNjcwMzUyIDgxMy4xOTAxNzMgMzkuOTQ3MTQxOCA3OTEuODkyNjMgNjAuNzA3MTE1NiA3OTYuOTIwMjk4IDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay01MCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC00OSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTUxIiBwb2ludHM9IjExMzAuNTk1MDkgNzYuMTgwNjg2NSAxMTA0LjI2OTg4IDkwLjAyMDY2OTEgMTEwOS4yOTc1NCA2MC43MDcxMTU2IDEwODggMzkuOTQ3MTQxOCAxMTE3LjQzMjQ4IDM1LjY3MDM1MiAxMTMwLjU5NTA5IDkgMTE0My43NTc2OSAzNS42NzAzNTIgMTE3My4xOTAxNyAzOS45NDcxNDE4IDExNTEuODkyNjMgNjAuNzA3MTE1NiAxMTU2LjkyMDMgOTAuMDIwNjY5MSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTUyIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg1LjE5MDE3MjkiIGhlaWdodD0iODEuMDIwNjY5MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTUxIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNTMiIHBvaW50cz0iMTQ5LjU5NTA4NiA3Ni4xODA2ODY1IDEyMy4yNjk4NzUgOTAuMDIwNjY5MSAxMjguMjk3NTQzIDYwLjcwNzExNTYgMTA3IDM5Ljk0NzE0MTggMTM2LjQzMjQ4MSAzNS42NzAzNTIgMTQ5LjU5NTA4NiA5IDE2Mi43NTc2OTIgMzUuNjcwMzUyIDE5Mi4xOTAxNzMgMzkuOTQ3MTQxOCAxNzAuODkyNjMgNjAuNzA3MTE1NiAxNzUuOTIwMjk4IDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay01NCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC01MyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTU1IiBwb2ludHM9IjUwOS41OTUwODYgNzYuMTgwNjg2NSA0ODMuMjY5ODc1IDkwLjAyMDY2OTEgNDg4LjI5NzU0MyA2MC43MDcxMTU2IDQ2NyAzOS45NDcxNDE4IDQ5Ni40MzI0ODEgMzUuNjcwMzUyIDUwOS41OTUwODYgOSA1MjIuNzU3NjkyIDM1LjY3MDM1MiA1NTIuMTkwMTczIDM5Ljk0NzE0MTggNTMwLjg5MjYzIDYwLjcwNzExNTYgNTM1LjkyMDI5OCA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNTYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC01NyIgcG9pbnRzPSI4NjkuNTk1MDg2IDc2LjE4MDY4NjUgODQzLjI2OTg3NSA5MC4wMjA2NjkxIDg0OC4yOTc1NDMgNjAuNzA3MTE1NiA4MjcgMzkuOTQ3MTQxOCA4NTYuNDMyNDgxIDM1LjY3MDM1MiA4NjkuNTk1MDg2IDkgODgyLjc1NzY5MiAzNS42NzAzNTIgOTEyLjE5MDE3MyAzOS45NDcxNDE4IDg5MC44OTI2MyA2MC43MDcxMTU2IDg5NS45MjAyOTggOTAuMDIwNjY5MSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTU4IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg1LjE5MDE3MjkiIGhlaWdodD0iODEuMDIwNjY5MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTU3Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNTkiIHBvaW50cz0iMTIyOS41OTUwOSA3Ni4xODA2ODY1IDEyMDMuMjY5ODggOTAuMDIwNjY5MSAxMjA4LjI5NzU0IDYwLjcwNzExNTYgMTE4NyAzOS45NDcxNDE4IDEyMTYuNDMyNDggMzUuNjcwMzUyIDEyMjkuNTk1MDkgOSAxMjQyLjc1NzY5IDM1LjY3MDM1MiAxMjcyLjE5MDE3IDM5Ljk0NzE0MTggMTI1MC44OTI2MyA2MC43MDcxMTU2IDEyNTUuOTIwMyA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNjAiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNTkiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC02MSIgcG9pbnRzPSIyNDkuNTk1MDg2IDc2LjE4MDY4NjUgMjIzLjI2OTg3NSA5MC4wMjA2NjkxIDIyOC4yOTc1NDMgNjAuNzA3MTE1NiAyMDcgMzkuOTQ3MTQxOCAyMzYuNDMyNDgxIDM1LjY3MDM1MiAyNDkuNTk1MDg2IDkgMjYyLjc1NzY5MiAzNS42NzAzNTIgMjkyLjE5MDE3MyAzOS45NDcxNDE4IDI3MC44OTI2MyA2MC43MDcxMTU2IDI3NS45MjAyOTggOTAuMDIwNjY5MSI+PC9wb2x5Z29uPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTYyIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9Ijg1LjE5MDE3MjkiIGhlaWdodD0iODEuMDIwNjY5MSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTYxIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNjMiIHBvaW50cz0iNjA5LjU5NTA4NiA3Ni4xODA2ODY1IDU4My4yNjk4NzUgOTAuMDIwNjY5MSA1ODguMjk3NTQzIDYwLjcwNzExNTYgNTY3IDM5Ljk0NzE0MTggNTk2LjQzMjQ4MSAzNS42NzAzNTIgNjA5LjU5NTA4NiA5IDYyMi43NTc2OTIgMzUuNjcwMzUyIDY1Mi4xOTAxNzMgMzkuOTQ3MTQxOCA2MzAuODkyNjMgNjAuNzA3MTE1NiA2MzUuOTIwMjk4IDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay02NCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC02MyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTY1IiBwb2ludHM9Ijk2OS41OTUwODYgNzYuMTgwNjg2NSA5NDMuMjY5ODc1IDkwLjAyMDY2OTEgOTQ4LjI5NzU0MyA2MC43MDcxMTU2IDkyNyAzOS45NDcxNDE4IDk1Ni40MzI0ODEgMzUuNjcwMzUyIDk2OS41OTUwODYgOSA5ODIuNzU3NjkyIDM1LjY3MDM1MiAxMDEyLjE5MDE3IDM5Ljk0NzE0MTggOTkwLjg5MjYzIDYwLjcwNzExNTYgOTk1LjkyMDI5OCA5MC4wMjA2NjkxIj48L3BvbHlnb24+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNjYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iODUuMTkwMTcyOSIgaGVpZ2h0PSI4MS4wMjA2NjkxIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtNjUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC02NyIgcG9pbnRzPSIxMzI5LjU5NTA5IDc2LjE4MDY4NjUgMTMwMy4yNjk4OCA5MC4wMjA2NjkxIDEzMDguMjk3NTQgNjAuNzA3MTE1NiAxMjg3IDM5Ljk0NzE0MTggMTMxNi40MzI0OCAzNS42NzAzNTIgMTMyOS41OTUwOSA5IDEzNDIuNzU3NjkgMzUuNjcwMzUyIDEzNzIuMTkwMTcgMzkuOTQ3MTQxOCAxMzUwLjg5MjYzIDYwLjcwNzExNTYgMTM1NS45MjAzIDkwLjAyMDY2OTEiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay02OCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4NS4xOTAxNzI5IiBoZWlnaHQ9IjgxLjAyMDY2OTEiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC02NyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTY5IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTcwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03MSIgeD0iNzIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTcyIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03MyIgeD0iMTAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTc0Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03NSIgeD0iODIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTc2Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03NyIgeD0iMjAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTc4Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC03OSIgeD0iOTIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTgwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC04MSIgeD0iMzYwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTgyIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC04MyIgeD0iMTA4MCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci04NCI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtODUiIHg9IjQ2MCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci04NiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtODciIHg9IjExODAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItODgiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTg5IiB4PSI1NjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItOTAiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTkxIiB4PSIxMjgwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTkyIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC05MyIgY3g9IjExMjkuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTk0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOTMiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC05NSIgY3g9IjEyMjkuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTk2IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC05NyIgY3g9IjEzMjkuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTk4IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOTciPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC05OSIgY3g9Ijc3MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTAwIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOTkiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xMDEiIGN4PSI4NzAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTEwMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEwMSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTEwMyIgY3g9Ijk3MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTA0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTAzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTA1IiBjeD0iNDEwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMDYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xMDUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xMDciIGN4PSI1MTAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTEwOCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEwNyI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTEwOSIgY3g9IjYxMC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTEwIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTA5Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTExIiBjeD0iNTAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTExMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTExMSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTExMyIgY3g9IjE1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTE0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTE1IiBjeD0iMjUwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMTYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xMTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xMTciIHg9IjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMTE4Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xMTkiIHg9IjYwMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0xMjAiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEyMSIgeD0iMTAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTEyMiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTIzIiB4PSI3MDAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMTI0Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xMjUiIHg9IjIwMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0xMjYiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEyNyIgeD0iODAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTEyOCI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTI5IiB4PSIzMDAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMTMwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xMzEiIHg9IjkwMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0xMzIiPgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dCbHVySW5uZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIxIiBpbj0ic2hhZG93Qmx1cklubmVyMSIgcmVzdWx0PSJzaGFkb3dPZmZzZXRJbm5lcjEiPjwvZmVPZmZzZXQ+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93T2Zmc2V0SW5uZXIxIiBpbjI9IlNvdXJjZUFscGhhIiBvcGVyYXRvcj0iYXJpdGhtZXRpYyIgazI9Ii0xIiBrMz0iMSIgcmVzdWx0PSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuNSAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dJbm5lcklubmVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgICAgIDxyZWN0IGlkPSJwYXRoLTEzMyIgeD0iNDAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTEzNCI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTM1IiB4PSIxMDAwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgIDxmaWx0ZXIgeD0iLTUwJSIgeT0iLTUwJSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTEzNiI+CiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd0JsdXJJbm5lcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjEiIGluPSJzaGFkb3dCbHVySW5uZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldElubmVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluPSJzaGFkb3dPZmZzZXRJbm5lcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJhcml0aG1ldGljIiBrMj0iLTEiIGszPSIxIiByZXN1bHQ9InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0lubmVySW5uZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTM3IiB4PSI1MDAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMTM4Ij4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xMzkiIHg9IjExMDAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgPGZpbHRlciB4PSItNTAlIiB5PSItNTAlIiB3aWR0aD0iMjAwJSIgaGVpZ2h0PSIyMDAlIiBmaWx0ZXJVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIGlkPSJmaWx0ZXItMTQwIj4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMS41IiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93Qmx1cklubmVyMSI+PC9mZUdhdXNzaWFuQmx1cj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49InNoYWRvd0JsdXJJbm5lcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0SW5uZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd09mZnNldElubmVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9ImFyaXRobWV0aWMiIGsyPSItMSIgazM9IjEiIHJlc3VsdD0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb21wb3NpdGU+CiAgICAgICAgICAgIDxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93SW5uZXJJbm5lcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xNDEiIGN4PSI1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTQyIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTQxIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTQzIiBjeD0iMTUwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNDQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNDMiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xNDUiIGN4PSIyNTAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE0NiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTE0NSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTE0NyIgY3g9IjM1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTQ4IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTQ3Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTQ5IiBjeD0iNjUwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNTAiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNDkiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xNTEiIGN4PSI5NTAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE1MiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTE1MSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTE1MyIgY3g9IjQ1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTU0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTUzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTU1IiBjeD0iNzUwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNTYiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNTUiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xNTciIGN4PSIxMDUwLjUiIGN5PSI1MC41IiByeD0iMzYuNSIgcnk9IjM2LjUiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0xNTgiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iNzMiIGhlaWdodD0iNzMiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNTciPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xNTkiIGN4PSI1NTAuNSIgY3k9IjUwLjUiIHJ4PSIzNi41IiByeT0iMzYuNSI+PC9lbGxpcHNlPgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE2MCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI3MyIgaGVpZ2h0PSI3MyIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTE1OSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTE2MSIgY3g9Ijg1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTYyIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTYxIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTYzIiBjeD0iMTE1MC41IiBjeT0iNTAuNSIgcng9IjM2LjUiIHJ5PSIzNi41Ij48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTY0IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjczIiBoZWlnaHQ9IjczIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMTYzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0icGFyYWxsZWwtZm9sZC1tYXAiPgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTMiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNDIwIiBoZWlnaHQ9IjE2NDAiPjwvcmVjdD4KICAgICAgICAgICAgPGcgaWQ9ImZpbmFsLUIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDY2MC4wMDAwMDAsIDEzNjAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNCI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0yKSIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iOCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS0xNCIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stNCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMyI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9InJlZHVjZWQtYmF0Y2hlcy1vZi1CIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAuMDAwMDAwLCAxMDYwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci02KSIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iOCIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNCI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci04KSIgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iOCIgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHkiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMTApIiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiB4bGluazpocmVmPSIjcGF0aC05Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weS03Ij4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xMikiIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiB4bGluazpocmVmPSIjcGF0aC0xMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS0xMyIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMS1Db3B5LTE0IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xNikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTUiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktMTUiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTE4KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xNyI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS0xNiIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMjApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTE5Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iYmF0Y2hlcy1vZi1CIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMC4wMDAwMDAsIDc2MC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTIyKSIgeGxpbms6aHJlZj0iI3BhdGgtMjEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0yMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weS0zIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIzIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTI0KSIgeGxpbms6aHJlZj0iI3BhdGgtMjMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0yMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMjUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMjYpIiB4bGluazpocmVmPSIjcGF0aC0yNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTI1Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZS1Db3B5LTQiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMjciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMjgpIiB4bGluazpocmVmPSIjcGF0aC0yNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTI3Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0yOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0zMCkiIHhsaW5rOmhyZWY9IiNwYXRoLTI5Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMjkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0zMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0zMikiIHhsaW5rOmhyZWY9IiNwYXRoLTMxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMzEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMzIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTM0KSIgeGxpbms6aHJlZj0iI3BhdGgtMzMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0zMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weS02Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTM1Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTM2KSIgeGxpbms6aHJlZj0iI3BhdGgtMzUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0zNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0zNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0zOCkiIHhsaW5rOmhyZWY9IiNwYXRoLTM3Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMzciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0zOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci00MCkiIHhsaW5rOmhyZWY9IiNwYXRoLTM5Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMzkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktMiI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC00MSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci00MikiIHhsaW5rOmhyZWY9IiNwYXRoLTQxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtNDEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktOCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC00MyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci00NCkiIHhsaW5rOmhyZWY9IiNwYXRoLTQzIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtNDMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSIzNjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSI3MjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSIxMDgwIiB5PSIwIiB3aWR0aD0iMzAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHkiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTQ2KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC00NSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS00IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay00OCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtNDciPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktNyIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stNTApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTQ5Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMS1Db3B5LTEwIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay01MikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtNTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktMiIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stNTQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTUzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMS1Db3B5LTUiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTU2KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC01NSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS04IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay01OCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtNTciPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktMTEiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTYwKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC01OSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS0zIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay02MikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtNjEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xLUNvcHktNiIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stNjQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTYzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9IlN0YXItMS1Db3B5LTkiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTY2KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC02NSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJTdGFyLTEtQ29weS0xMiIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stNjgpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTY3Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iYmF0Y2hlcy1vZi1BIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMC4wMDAwMDAsIDQ2MC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTY5Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTcwKSIgeGxpbms6aHJlZj0iI3BhdGgtNjkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC02OSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weS0zIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTcxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTcyKSIgeGxpbms6aHJlZj0iI3BhdGgtNzEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC03MSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNzMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItNzQpIiB4bGluazpocmVmPSIjcGF0aC03MyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTczIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZS1Db3B5LTQiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNzUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItNzYpIiB4bGluazpocmVmPSIjcGF0aC03NSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTc1Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC03NyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci03OCkiIHhsaW5rOmhyZWY9IiNwYXRoLTc3Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtNzciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC03OSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci04MCkiIHhsaW5rOmhyZWY9IiNwYXRoLTc5Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtNzkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTgxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTgyKSIgeGxpbms6aHJlZj0iI3BhdGgtODEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC04MSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weS02Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTgzIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTg0KSIgeGxpbms6aHJlZj0iI3BhdGgtODMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC04MyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC04NSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci04NikiIHhsaW5rOmhyZWY9IiNwYXRoLTg1Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtODUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC04NyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci04OCkiIHhsaW5rOmhyZWY9IiNwYXRoLTg3Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtODciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktMiI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC04OSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci05MCkiIHhsaW5rOmhyZWY9IiNwYXRoLTg5Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtODkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktOCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC05MSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci05MikiIHhsaW5rOmhyZWY9IiNwYXRoLTkxIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtOTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSIzNjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSI3MjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSIxMDgwIiB5PSIwIiB3aWR0aD0iMzAwIiBoZWlnaHQ9IjEwMCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHktOCIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stOTQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTkzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTkiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTk2KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC05NSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS0xMCIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stOTgpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTk3Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTgiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTEwMCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtOTkiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHktOSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTAyKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xMDEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHktMTAiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTEwNCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTAzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTgiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTEwNikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTA1Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTkiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTEwOCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTA3Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTEwIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xMTApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTEwOSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS04IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xMTIpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTExMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS05IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xMTQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTExMyI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS0xMCIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTE2KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xMTUiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJpbml0aWFsLUEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDExMC4wMDAwMDAsIDE2MC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xMTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xMTgpIiB4bGluazpocmVmPSIjcGF0aC0xMTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTExNyI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktMyI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTExOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTEyMCkiIHhsaW5rOmhyZWY9IiNwYXRoLTExOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMTE5Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xMjEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xMjIpIiB4bGluazpocmVmPSIjcGF0aC0xMjEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTEyMSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNCI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEyMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTEyNCkiIHhsaW5rOmhyZWY9IiNwYXRoLTEyMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMTIzIj48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xMjUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xMjYpIiB4bGluazpocmVmPSIjcGF0aC0xMjUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTEyNSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEyNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTEyOCkiIHhsaW5rOmhyZWY9IiNwYXRoLTEyNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMTI3Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xMjkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xMzApIiB4bGluazpocmVmPSIjcGF0aC0xMjkiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTEyOSI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktNiI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEzMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTEzMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEzMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMTMxIj48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEzMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTEzNCkiIHhsaW5rOmhyZWY9IiNwYXRoLTEzMyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMTMzIj48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJSZWN0YW5nbGUtQ29weS03Ij4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMTM1Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMTM2KSIgeGxpbms6aHJlZj0iI3BhdGgtMTM1Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4bGluazpocmVmPSIjcGF0aC0xMzUiPjwvdXNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9IlJlY3RhbmdsZS1Db3B5LTIiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xMzciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMSIgZmlsdGVyPSJ1cmwoI2ZpbHRlci0xMzgpIiB4bGluazpocmVmPSIjcGF0aC0xMzciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDx1c2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHhsaW5rOmhyZWY9IiNwYXRoLTEzNyI+PC91c2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLUNvcHktOCI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEzOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTE0MCkiIHhsaW5rOmhyZWY9IiNwYXRoLTEzOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeGxpbms6aHJlZj0iI3BhdGgtMTM5Ij48L3VzZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSIzMDAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSI2MDAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTIiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWpvaW49InJvdW5kIiB4PSI5MDAiIHk9IjAiIHdpZHRoPSIzMDAiIGhlaWdodD0iMTAwIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTQyKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xNDEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHkiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTE0NCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTQzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xNDYpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTE0NSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTQ4KSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xNDciPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHktMiIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTUwKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xNDkiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHktNSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTUyKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xNTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xLUNvcHkiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTE1NCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTUzIj48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTMiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTE1NikiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTU1Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5LTYiIHN0cm9rZT0iIzAwMDAwMCIgbWFzaz0idXJsKCNtYXNrLTE1OCkiIHN0cm9rZS13aWR0aD0iOCIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTU3Ij48L3VzZT4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMS1Db3B5IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xNjApIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTE1OSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS00IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xNjIpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTE2MSI+PC91c2U+CiAgICAgICAgICAgICAgICA8dXNlIGlkPSJPdmFsLTEtQ29weS03IiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0xNjQpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTE2MyI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHRleHQgaWQ9InJlc3VsdC1sYWJlbCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNjAyLjQ1NjA1NSIgeT0iMTU3MiI+Ni4gRmluYWwgcmVzdWx0PC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8ZyBpZD0icmVkdWNlLWFsbC1sYWJlbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjcxLjAwMDAwMCwgMTIxMS4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1Ni41Njg1NDIsIDU2LjU2ODU0Mikgcm90YXRlKC0zMTUuMDAwMDAwKSB0cmFuc2xhdGUoLTU2LjU2ODU0MiwgLTU2LjU2ODU0MikgIiBwb2ludHM9IjE2LjU2ODU0MjUgMzYuNTY4NTQyNSA1Ni41Njg1NDI1IDM2LjU2ODU0MjUgNTYuNTY4NTQyNSAxNi41Njg1NDI1IDk2LjU2ODU0MjUgNTYuMDY2MzA5NiA1Ni41Njg1NDI1IDk2LjU2ODU0MjUgNTYuNTY4NTQyNSA3Ni41Njg1NDI1IDE2LjU2ODU0MjUgNzYuNTY4NTQyNSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM0OS40NDk0MzksIDU3LjQ0OTQzOSkgcm90YXRlKC0yOTMuMDAwMDAwKSB0cmFuc2xhdGUoLTM0OS40NDk0MzksIC01Ny40NDk0MzkpICIgcG9pbnRzPSIzMDkuNDQ5NDM5IDM3LjQ0OTQzOTMgMzQ5LjQ0OTQzOSAzNy40NDk0MzkzIDM0OS40NDk0MzkgMTcuNDQ5NDM5MyAzODkuNDQ5NDM5IDU2Ljk0NzIwNjQgMzQ5LjQ0OTQzOSA5Ny40NDk0MzkzIDM0OS40NDk0MzkgNzcuNDQ5NDM5MyAzMDkuNDQ5NDM5IDc3LjQ0OTQzOTMiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NTMuNDQ5NDM5LCA1Ny40NDk0MzkpIHJvdGF0ZSgtMjQ3LjAwMDAwMCkgdHJhbnNsYXRlKC01NTMuNDQ5NDM5LCAtNTcuNDQ5NDM5KSAiIHBvaW50cz0iNTEzLjQ0OTQzOSAzNy40NDk0MzkzIDU1My40NDk0MzkgMzcuNDQ5NDM5MyA1NTMuNDQ5NDM5IDE3LjQ0OTQzOTMgNTkzLjQ0OTQzOSA1Ni45NDcyMDY0IDU1My40NDk0MzkgOTcuNDQ5NDM5MyA1NTMuNDQ5NDM5IDc3LjQ0OTQzOTMgNTEzLjQ0OTQzOSA3Ny40NDk0MzkzIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMyIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODE5LjU2ODU0MiwgNTcuNTY4NTQyKSByb3RhdGUoLTIyNS4wMDAwMDApIHRyYW5zbGF0ZSgtODE5LjU2ODU0MiwgLTU3LjU2ODU0MikgIiBwb2ludHM9Ijc3OS41Njg1NDIgMzcuNTY4NTQyNSA4MTkuNTY4NTQyIDM3LjU2ODU0MjUgODE5LjU2ODU0MiAxNy41Njg1NDI1IDg1OS41Njg1NDIgNTcuMDY2MzA5NiA4MTkuNTY4NTQyIDk3LjU2ODU0MjUgODE5LjU2ODU0MiA3Ny41Njg1NDI1IDc3OS41Njg1NDIgNzcuNTY4NTQyNSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IjUuLVJlZHVjZS10aGUtYmF0Y2hlIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjU5LjM3Njk1MyIgeT0iNjEiPjUuIFJlZHVjZSB0aGUgYmF0Y2hlczwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9InJlZHVjZS1iYXRjaGVzLWxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzAuMDAwMDAwLCA5MjguMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAuMDcxNjE4LCA0MC4wMDAwMDApIHJvdGF0ZSgtMjcwLjAwMDAwMCkgdHJhbnNsYXRlKC00MC4wNzE2MTgsIC00MC4wMDAwMDApICIgcG9pbnRzPSIwLjA3MTYxNzkxOTMgMjAgNDAuMDcxNjE3OSAyMCA0MC4wNzE2MTc5IDMuNTUyNzEzNjhlLTE1IDgwLjA3MTYxNzkgMzkuNDk3NzY3MSA0MC4wNzE2MTc5IDgwIDQwLjA3MTYxNzkgNjAgMC4wNzE2MTc5MTkzIDYwIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAxLjE3NzY0NywgNDAuMTA2MDI5KSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtNDAxLjE3NzY0NywgLTQwLjEwNjAyOSkgIiBwb2ludHM9IjM2MS4xNzc2NDcgMjAuMTA2MDI4OSA0MDEuMTc3NjQ3IDIwLjEwNjAyODkgNDAxLjE3NzY0NyAwLjEwNjAyODg2OSA0NDEuMTc3NjQ3IDM5LjYwMzc5NiA0MDEuMTc3NjQ3IDgwLjEwNjAyODkgNDAxLjE3NzY0NyA2MC4xMDYwMjg5IDM2MS4xNzc2NDcgNjAuMTA2MDI4OSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDc2MS4xNzc2NDcsIDQwLjEwNjAyOSkgcm90YXRlKC0yNzAuMDAwMDAwKSB0cmFuc2xhdGUoLTc2MS4xNzc2NDcsIC00MC4xMDYwMjkpICIgcG9pbnRzPSI3MjEuMTc3NjQ3IDIwLjEwNjAyODkgNzYxLjE3NzY0NyAyMC4xMDYwMjg5IDc2MS4xNzc2NDcgMC4xMDYwMjg4NjkgODAxLjE3NzY0NyAzOS42MDM3OTYgNzYxLjE3NzY0NyA4MC4xMDYwMjg5IDc2MS4xNzc2NDcgNjAuMTA2MDI4OSA3MjEuMTc3NjQ3IDYwLjEwNjAyODkiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0zIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMTIxLjAwMDAwMCwgNDAuMDAwMDAwKSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtMTEyMS4wMDAwMDAsIC00MC4wMDAwMDApICIgcG9pbnRzPSIxMDgxIDIwIDExMjEgMjAgMTEyMSAzLjU1MjcxMzY4ZS0xNSAxMTYxIDM5LjQ5Nzc2NzEgMTEyMSA4MCAxMTIxIDYwIDEwODEgNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSI0Li1SZWR1Y2UtZWFjaC1iYXRjaCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjMyMy4zMzIwMzEiIHk9IjQ0Ij40LiBSZWR1Y2UgZWFjaCBiYXRjaCBpbiBwYXJhbGxlbDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Im1hcC1sYWJlbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMwLjAwMDAwMCwgNjMwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQwLjAwMDAwMCwgNDAuMDAwMDAwKSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtNDAuMDAwMDAwLCAtNDAuMDAwMDAwKSAiIHBvaW50cz0iMCAyMCA0MCAyMCA0MCAzLjU1MjcxMzY4ZS0xNSA4MCAzOS40OTc3NjcxIDQwIDgwIDQwIDYwIDAgNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MDEuMDAwMDAwLCA0MC4wMDAwMDApIHJvdGF0ZSgtMjcwLjAwMDAwMCkgdHJhbnNsYXRlKC00MDEuMDAwMDAwLCAtNDAuMDAwMDAwKSAiIHBvaW50cz0iMzYxIDIwIDQwMSAyMCA0MDEgMy41NTI3MTM2OGUtMTUgNDQxIDM5LjQ5Nzc2NzEgNDAxIDgwIDQwMSA2MCAzNjEgNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NjEuMDAwMDAwLCA0MC4wMDAwMDApIHJvdGF0ZSgtMjcwLjAwMDAwMCkgdHJhbnNsYXRlKC03NjEuMDAwMDAwLCAtNDAuMDAwMDAwKSAiIHBvaW50cz0iNzIxIDIwIDc2MSAyMCA3NjEgMy41NTI3MTM2OGUtMTUgODAxIDM5LjQ5Nzc2NzEgNzYxIDgwIDc2MSA2MCA3MjEgNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0zIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMTIxLjAwMDAwMCwgNDAuMDAwMDAwKSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtMTEyMS4wMDAwMDAsIC00MC4wMDAwMDApICIgcG9pbnRzPSIxMDgxIDIwIDExMjEgMjAgMTEyMSAzLjU1MjcxMzY4ZS0xNSAxMTYxIDM5LjQ5Nzc2NzEgMTEyMSA4MCAxMTIxIDYwIDEwODEgNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSIzLi1NYXAtb3Zlci10aGUtYmF0YyIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjMwNS4zNDA4MiIgeT0iNDIiPjMuIE1hcCBvdmVyIHRoZSBiYXRjaGVzIGluIHBhcmFsbGVsPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iZGl2aWRlLWxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTYuMDAwMDAwLCAzMTYuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTIuMDcxNjE4LCA1Mi4wNzE2MTgpIHJvdGF0ZSgtMjQ4LjAwMDAwMCkgdHJhbnNsYXRlKC01Mi4wNzE2MTgsIC01Mi4wNzE2MTgpICIgcG9pbnRzPSIxMi4wNzE2MTc5IDMyLjA3MTYxNzkgNTIuMDcxNjE3OSAzMi4wNzE2MTc5IDUyLjA3MTYxNzkgMTIuMDcxNjE3OSA5Mi4wNzE2MTc5IDUxLjU2OTM4NSA1Mi4wNzE2MTc5IDkyLjA3MTYxNzkgNTIuMDcxNjE3OSA3Mi4wNzE2MTc5IDEyLjA3MTYxNzkgNzIuMDcxNjE3OSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM4OC4wMDAwMDAsIDUyLjAwMDAwMCkgcm90YXRlKC0yNjIuMDAwMDAwKSB0cmFuc2xhdGUoLTM4OC4wMDAwMDAsIC01Mi4wMDAwMDApICIgcG9pbnRzPSIzNDggMzIgMzg4IDMyIDM4OCAxMiA0MjggNTEuNDk3NzY3MSAzODggOTIgMzg4IDcyIDM0OCA3MiI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDcyMC4wMDAwMDAsIDUyLjAwMDAwMCkgcm90YXRlKC0yNzguMDAwMDAwKSB0cmFuc2xhdGUoLTcyMC4wMDAwMDAsIC01Mi4wMDAwMDApICIgcG9pbnRzPSI2ODAgMzIgNzIwIDMyIDcyMCAxMiA3NjAgNTEuNDk3NzY3MSA3MjAgOTIgNzIwIDcyIDY4MCA3MiI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTMiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwNTMuNDc1OTYyLCA1Mi40NzU5NjIpIHJvdGF0ZSgtMjkwLjAwMDAwMCkgdHJhbnNsYXRlKC0xMDUzLjQ3NTk2MiwgLTUyLjQ3NTk2MikgIiBwb2ludHM9IjEwMTMuNDc1OTYgMzIuNDc1OTYyMSAxMDUzLjQ3NTk2IDMyLjQ3NTk2MjEgMTA1My40NzU5NiAxMi40NzU5NjIxIDEwOTMuNDc1OTYgNTEuOTczNzI5MiAxMDUzLjQ3NTk2IDkyLjQ3NTk2MjEgMTA1My40NzU5NiA3Mi40NzU5NjIxIDEwMTMuNDc1OTYgNzIuNDc1OTYyMSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IjIuLURpdmlkZS1pbnRvLWJhdGNoIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjY5LjM1NjQ0NSIgeT0iNTYiPjIuIERpdmlkZSBpbnRvIGJhdGNoZXMgZm9yIGVhY2ggQ1BVPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iaW5pdGlhbC1sYWJlbCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTI1LjM2NzE4OCIgeT0iOTEiPjEuIEluaXRpYWwgZGF0YSBzZXF1ZW5jZTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==">
      <figcaption>Figure 17: <em>parallelFoldMap</em> algorithm</figcaption>
    </figure>
    <p>Scala provides some simple tools to distribute work amongst threads. We could use the <a href="http://docs.scala-lang.org/overviews/parallel-collections/overview.html">parallel collections library<a id="loc-428" href="#loc-664" role="doc-noteref"><sup>88</sup></a></a> to implement a solution, but let’s challenge ourselves by diving a bit deeper and implementing the algorithm ourselves using <code>Futures</code>.</p>
    <h4 id="loc-429">20.3.1. <strong>Futures</strong>, Thread Pools, and ExecutionContexts</h4>
    <p>We already know a fair amount about the monadic nature of <code>Futures</code>. Let’s take a moment for a quick recap, and to describe how Scala futures are scheduled behind the scenes.</p>
    <p><code>Futures</code> run on a thread pool, determined by an implicit <code>ExecutionContext</code> parameter. Whenever we create a <code>Future</code>, whether through a call to <code>Future.apply</code> or some other combinator, we must have an implicit <code>ExecutionContext</code> in scope:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.Future<br><span style="color: #d73948">import</span> scala.concurrent.ExecutionContext.Implicits.global</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> future1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Future</span> {<br>  (<span style="color: #b60157">1</span> to <span style="color: #b60157">100</span>).toList.foldLeft(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> future1: Future[Int] = Future(Success(5050))</span><br><br><span style="color: #d73948">val</span> future2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Future</span> {<br>  (<span style="color: #b60157">100</span> to <span style="color: #b60157">200</span>).toList.foldLeft(<span style="color: #b60157">0</span>)(<span style="color: #d73948">_</span> + <span style="color: #d73948">_</span>)<br>}<br><span style="color: #74747c">//</span><span style="color: #74747c"> future2: Future[Int] = Future(Success(15150))</span></code></pre>
    <p>In this example we’ve imported a <code>ExecutionContext.Implicits.global</code>. This default context allocates a thread pool with one thread per CPU in our machine. When we create a <code>Future</code> the <code>ExecutionContext</code> schedules it for execution. If there is a free thread in the pool, the <code>Future</code> starts executing immediately. Most modern machines have at least two CPUs, so in our example it is likely that <code>future1</code> and <code>future2</code> will execute in parellel.</p>
    <p>Some combinators create new <code>Futures</code> that schedule work based on the results of other <code>Futures</code>. The <code>map</code> and <code>flatMap</code> methods, for example, schedule computations that run as soon as their input values are computed and a CPU is available:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> future3 <span style="color: #d73948">=</span> future1.map(<span style="color: #d73948">_</span>.toString)<br><span style="color: #74747c">//</span><span style="color: #74747c"> future3: Future[String] = Future(Success(5050))</span><br><br><span style="color: #d73948">val</span> future4 <span style="color: #d73948">=</span> <span style="color: #d73948">for</span> {<br>  a <span style="color: #d73948">&lt;-</span> future1<br>  b <span style="color: #d73948">&lt;-</span> future2<br>} <span style="color: #d73948">yield</span> a + b<br><span style="color: #74747c">//</span><span style="color: #74747c"> future4: Future[Int] = Future(Success(20200))</span></code></pre>
    <p>As we saw in <a href="#loc-319">Section 13.2</a>, we can convert a <code>List[Future[A]]</code> to a <code>Future[List[A]]</code> using <code>Future.sequence</code>:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Future</span>.sequence(<span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Future</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">2</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">3</span>)))<br><span style="color: #74747c">//</span><span style="color: #74747c"> res6: Future[List[Int]] = Future(Success(List(1, 2, 3)))</span></code></pre>
    <p>or an instance of <code>Traverse</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.instances.future.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Applicative</span><br><span style="color: #d73948">import</span> cats.instances.list.<span style="color: #d73948">_</span>   <span style="color: #74747c">//</span><span style="color: #74747c"> for Traverse</span><br><span style="color: #d73948">import</span> cats.syntax.traverse.<span style="color: #d73948">_</span>  <span style="color: #74747c">//</span><span style="color: #74747c"> for sequence</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #4b69c6">Future</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">2</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">3</span>)).sequence<br><span style="color: #74747c">//</span><span style="color: #74747c"> res7: Future[List[Int]] = Future(Success(List(1, 2, 3)))</span></code></pre>
    <p>An <code>ExecutionContext</code> is required in either case. Finally, we can use <code>Await.result</code> to block on a <code>Future</code> until a result is available:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> scala.concurrent.<span style="color: #d73948">_</span><br><span style="color: #d73948">import</span> scala.concurrent.duration.<span style="color: #d73948">_</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Await</span>.result(<span style="color: #4b69c6">Future</span>(<span style="color: #b60157">1</span>), <span style="color: #b60157">1</span>.second) <span style="color: #74747c">//</span><span style="color: #74747c"> wait for the result</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> res8: Int = 1</span></code></pre>
    <p>There are also <code>Monad</code> and <code>Monoid</code> implementations for <code>Future</code> available from <code>cats.instances.future</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.{Monad, Monoid}<br><span style="color: #d73948">import</span> cats.instances.int.<span style="color: #d73948">_</span>    <span style="color: #74747c">//</span><span style="color: #74747c"> for Monoid</span><br><span style="color: #d73948">import</span> cats.instances.future.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Monad and Monoid</span><br><br><span style="color: #4b69c6">Monad</span>[<span style="color: #4b69c6">Future</span>].pure(<span style="color: #b60157">42</span>)<br><br><span style="color: #4b69c6">Monoid</span>[<span style="color: #4b69c6">Future</span>[<span style="color: #d73948">Int</span>]].combine(<span style="color: #4b69c6">Future</span>(<span style="color: #b60157">1</span>), <span style="color: #4b69c6">Future</span>(<span style="color: #b60157">2</span>))</code></pre>
    <h4 id="loc-430">20.3.2. Dividing Work</h4>
    <p>Now we’ve refreshed our memory of <code>Futures</code>, let’s look at how we can divide work into batches. We can query the number of available CPUs on our machine using an API call from the Java standard library:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">Runtime</span>.getRuntime.availableProcessors<br><span style="color: #74747c">//</span><span style="color: #74747c"> res11: Int = 4</span></code></pre>
    <p>We can partition a sequence (actually anything that implements <code>Vector</code>) using the <code>grouped</code> method. We’ll use this to split off batches of work for each CPU:</p>
    <pre><code data-lang="scala">(<span style="color: #b60157">1</span> to <span style="color: #b60157">10</span>).toList.grouped(<span style="color: #b60157">3</span>).toList<br><span style="color: #74747c">//</span><span style="color: #74747c"> res12: List[List[Int]] = List(</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   List(1, 2, 3),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   List(4, 5, 6),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   List(7, 8, 9),</span><br><span style="color: #74747c">//</span><span style="color: #74747c">   List(10)</span><br><span style="color: #74747c">//</span><span style="color: #74747c"> )</span></code></pre>
    <h4 id="loc-431">20.3.3. Implementing <strong>parallelFoldMap</strong></h4>
    <p>Implement a parallel version of <code>foldMap</code> called <code>parallelFoldMap</code>. Here is the type signature:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">parallelFoldMap</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span> <span style="color: #d73948">:</span> <span style="color: #4b69c6">Monoid</span>]<br>      (values: <span style="color: #4b69c6">Vector</span>[<span style="color: #4b69c6">A</span>])<br>      (func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Future</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span></code></pre>
    <p>Use the techniques described above to split the work into batches, one batch per CPU. Process each batch in a parallel thread. Refer back to <a href="#loc-427">Figure 17</a> if you need to review the overall algorithm.</p>
    <p>For bonus points, process the batches for each CPU using your implementation of <code>foldMap</code> from above.</p>
    <h4 id="loc-432">20.3.4. <strong>parallelFoldMap</strong> with more Cats</h4>
    <p>Although we implemented <code>foldMap</code> ourselves above, the method is also available as part of the <code>Foldable</code> type class we discussed in <a href="#loc-315">Section 13.1</a>.</p>
    <p>Reimplement <code>parallelFoldMap</code> using Cats’ <code>Foldable</code> and <code>Traverseable</code> type classes.</p>
    <h3 id="loc-433">20.4. Summary</h3>
    <p>In this case study we implemented a system that imitates map-reduce as performed on a cluster. Our algorithm followed three steps:</p>
    <ol>
      <li>batch the data and send one batch to each “node”;</li>
      <li>perform a local map-reduce on each batch;</li>
      <li>combine the results using monoid addition.</li>
    </ol>
    <p>Our toy system emulates the batching behaviour of real-world map-reduce systems such as Hadoop. However, in reality we are running all of our work on a single machine where communcation between nodes is negligible. We don’t actually need to batch data to gain efficient parallel processing of a list. We can simply map using a <code>Functor</code> and reduce using a <code>Monoid</code>.</p>
    <p>Regardless of the batching strategy, mapping and reducing with <code>Monoids</code> is a powerful and general framework that isn’t limited to simple tasks like addition and string concatenation. Most of the tasks data scientists perform in their day-to-day analyses can be cast as monoids. There are monoids for all the following:</p>
    <ul>
      <li>approximate sets such as the Bloom filter;</li>
      <li>set cardinality estimators, such as the HyperLogLog algorithm;</li>
      <li>vectors and vector operations like stochastic gradient descent;</li>
      <li>quantile estimators such as the t-digest</li>
    </ul>
    <p>to name but a few.</p>
    <h2 id="loc-434">21. Case Study: Data Validation</h2>
    <p>In this case study we will build a library for validation. What do we mean by validation? Almost all programs must check their input meets certain criteria. Usernames must not be blank, email addresses must be valid, and so on. This type of validation often occurs in web forms, but it could be performed on configuration files, on web service responses, and any other case where we have to deal with data that we can’t guarantee is correct. Authentication, for example, is just a specialised form of validation.</p>
    <p>We want to build a library that performs these checks. What design goals should we have? For inspiration, let’s look at some examples of the types of checks we want to perform:</p>
    <ul>
      <li>
        <p>A user must be over 18 years old or must have parental consent.</p>
      </li>
      <li>
        <p>A <code>String</code> ID must be parsable as a <code>Int</code> and the <code>Int</code> must correspond to a valid record ID.</p>
      </li>
      <li>
        <p>A bid in an auction must apply to one or more items and have a positive value.</p>
      </li>
      <li>
        <p>A username must contain at least four characters and all characters must be alphanumeric.</p>
      </li>
      <li>
        <p>An email address must contain a single <code>@</code> sign. Split the string at the <code>@</code>. The string to the left must not be empty. The string to the right must be at least three characters long and contain a dot.</p>
      </li>
    </ul>
    <p>With these examples in mind we can state some goals:</p>
    <ul>
      <li>
        <p>We should be able to associate meaningful messages with each validation failure, so the user knows why their data is not valid.</p>
      </li>
      <li>
        <p>We should be able to combine small checks into larger ones. Taking the username example above, we should be able to express this by combining a check of length and a check for alphanumeric values.</p>
      </li>
      <li>
        <p>We should be able to transform data while we are checking it. There is an example above requiring we parse data, changing its type from <code>String</code> to <code>Int</code>.</p>
      </li>
      <li>
        <p>Finally, we should be able to accumulate all the failures in one go, so the user can correct all the issues before resubmitting.</p>
      </li>
    </ul>
    <p>These goals assume we’re checking a single piece of data. We will also need to combine checks across multiple pieces of data. For a login form, for example, we’ll need to combine the check results for the username and the password. This will turn out to be quite a small component of the library, so the majority of our time will focus on checking a single data item.</p>
    <h3 id="loc-435">21.1. Sketching the Library Structure</h3>
    <p>Let’s start at the bottom, checking individual pieces of data. Before we start coding let’s try to develop a feel for what we’ll be building. We can use a graphical notation to help us. We’ll go through our goals one by one.</p>
    <p><strong>Providing error messages</strong></p>
    <p>Our first goal requires us to associate useful error messages with a check failure. The output of a check could be either the value being checked, if it passed the check, or some kind of error message. We can abstractly represent this as a value in a context, where the context is the possibility of an error message as shown in <a href="#loc-436">Figure 18</a>.</p>
    <figure id="loc-436">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTkyMXB4IiBoZWlnaHQ9IjM2MHB4IiB2aWV3Qm94PSIwIDAgMTkyMSAzNjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5yZXN1bHQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8Y2lyY2xlIGlkPSJwYXRoLTEiIGN4PSIxMDAiIGN5PSIxMDAiIHI9IjgwIj48L2NpcmNsZT4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJyZXN1bHQiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjEiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4NjEuMDAwMDAwLCAzOC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJGW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTAuMSIgeT0iMjc2Ij5GW0FdPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xMSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjEwMCIgY3k9IjEwMCIgcj0iNzgiPjwvY2lyY2xlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSIyIiB5PSIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 18: A validation result</figcaption>
    </figure>
    <p>A check itself is therefore a function that transforms a value into a value in a context as shown in <a href="#loc-437">Figure 19</a>.</p>
    <figure id="loc-437">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTkyMXB4IiBoZWlnaHQ9IjM2MHB4IiB2aWV3Qm94PSIwIDAgMTkyMSAzNjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5jaGVjazwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxjaXJjbGUgaWQ9InBhdGgtMSIgY3g9IjgwIiBjeT0iMTAwIiByPSI4MCI+PC9jaXJjbGU+CiAgICAgICAgPGNpcmNsZSBpZD0icGF0aC0yIiBjeD0iMTAwIiBjeT0iMTAwIiByPSI4MCI+PC9jaXJjbGU+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iY2hlY2siPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjEiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3MDIuMDAwMDAwLCA0MC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iODAiIGN5PSIxMDAiIHI9Ijc4Ij48L2NpcmNsZT4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzE4LjAwMDAwMCwgMC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iMTAwIiBjeT0iMTAwIiByPSI3OCI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIiIHk9IjIiIHdpZHRoPSIxOTYiIGhlaWdodD0iMTk2IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIyMDAgODAgMjQwIDgwIDI0MCA2MCAyODAgOTkuNDk3NzY3MSAyNDAgMTQwIDI0MCAxMjAgMjAwIDEyMCI+PC9wb2x5Z29uPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUZbQV0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijg0Ny4xIiB5PSIzMTQiPkEgPSZndDsgRltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==">
      <figcaption>Figure 19: A validation check</figcaption>
    </figure>
    <p><strong>Combine checks</strong></p>
    <p>How do we combine smaller checks into larger ones? Is this an applicative or semigroupal as shown in <a href="#loc-438">Figure 20</a>?</p>
    <figure id="loc-438">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjAxN3B4IiBoZWlnaHQ9IjI3MnB4IiB2aWV3Qm94PSIwIDAgMjAxNyAyNzIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5hcHBsaWNhdGl2ZTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTEiIGN4PSI2OC4xMjM5ODA0IiBjeT0iODUuMjEwNTI2MyIgcng9IjY4LjEyMzk4MDQiIHJ5PSI2OC4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMiIgY3g9Ijg2LjEyMzk4MDQiIGN5PSI4NS4yMTA1MjYzIiByeD0iNjguMTIzOTgwNCIgcnk9IjY4LjIxMDUyNjMiPjwvZWxsaXBzZT4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0zIiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2OC4xMjM5ODA0IiByeT0iNjguMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTQiIGN4PSI4NS4xMjM5ODA0IiBjeT0iODYuMjEwNTI2MyIgcng9IjY4LjEyMzk4MDQiIHJ5PSI2OC4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtNSIgY3g9IjY4LjEyMzk4MDQiIGN5PSI4NS4yMTA1MjYzIiByeD0iNjguMTIzOTgwNCIgcnk9IjY4LjIxMDUyNjMiPjwvZWxsaXBzZT4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC02IiBjeD0iODkuMTIzOTgwNCIgY3k9Ijg2LjIxMDUyNjMiIHJ4PSI2OC4xMjM5ODA0IiByeT0iNjguMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTciIGN4PSIyNDAuMTIzOTgiIGN5PSI4Ni4yMTA1MjYzIiByeD0iNjguMTIzOTgwNCIgcnk9IjY4LjIxMDUyNjMiPjwvZWxsaXBzZT4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJhcHBsaWNhdGl2ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQ0LjAwMDAwMCwgLTYwLjAwMDAwMCkiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxMDUiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC03IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4NC4wMDAwMDAsIDYxLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNzIuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iODYuMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSIyIiB5PSIyIiB3aWR0aD0iMTY2LjMwOTk1MSIgaGVpZ2h0PSIxNjYuNTI2MzE2IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxNzEgNzAuMDUyNjMxNiAyMDUuMDYxOTkgNzAuMDUyNjMxNiAyMDUuMDYxOTkgNTMgMjM5LjEyMzk4IDg2LjY3NzA0MzYgMjA1LjA2MTk5IDEyMS4yMTA1MjYgMjA1LjA2MTk5IDEwNC4xNTc4OTUgMTcxIDEwNC4xNTc4OTUiPjwvcG9seWdvbj4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxOTEuOTM2ODY4IiB5PSIzMjUiPkEgPSZndDsgRltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU4NC4wMDAwMDAsIDYwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNzMuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIiIHk9IjIiIHdpZHRoPSIxNjYuMzA5OTUxIiBoZWlnaHQ9IjE2Ni41MjYzMTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC00Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI4NS4xMjM5ODA0IiBjeT0iODYuMjEwNTI2MyIgcng9IjY2LjEyMzk4MDQiIHJ5PSI2Ni4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxNzIgNzEuMDUyNjMxNiAyMDYuMDYxOTkgNzEuMDUyNjMxNiAyMDYuMDYxOTkgNTQgMjQwLjEyMzk4IDg3LjY3NzA0MzYgMjA2LjA2MTk5IDEyMi4yMTA1MjYgMjA2LjA2MTk5IDEwNS4xNTc4OTUgMTcyIDEwNS4xNTc4OTUiPjwvcG9seWdvbj4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI2OTEuMzUxMjIzIiB5PSIzMjQiPkEgPSZndDsgRltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstRlsoQSwtQSldIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxNTgzLjYzNDI2IiB5PSIzMjQiPkEgPSZndDsgRlsoQSwgQSldPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ2MC4wMDAwMDAsIDYwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxNzEgNjguMDUyNjMxNiAyMDUuMDYxOTkgNjguMDUyNjMxNiAyMDUuMDYxOTkgNTEgMjM5LjEyMzk4IDg0LjY3NzA0MzYgMjA1LjA2MTk5IDExOS4yMTA1MjYgMjA1LjA2MTk5IDEwMi4xNTc4OTUgMTcxIDEwMi4xNTc4OTUiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC00IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNzIuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIuNjkwMDQ4OTQiIHk9IjIiIHdpZHRoPSIzMjMuNjQ0MzcyIiBoZWlnaHQ9IjE2Ni41MjYzMTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC02Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI4OS4xMjM5ODA0IiBjeT0iODYuMjEwNTI2MyIgcng9IjY2LjEyMzk4MDQiIHJ5PSI2Ni4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNyI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iMjQwLjEyMzk4IiBjeT0iODYuMjEwNTI2MyIgcng9IjY2LjEyMzk4MDQiIHJ5PSI2Ni4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMTM0NCAxMjcgMTM4NCAxMjcgMTM4NCAxMDcgMTQyNCAxNDYuNDk3NzY3IDEzODQgMTg3IDEzODQgMTY3IDEzNDQgMTY3Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIsIiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjU2IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTQwLjIiIHk9IjE2OSI+LDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IikudHVwbGVkIiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjU2IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTA0My4xIiB5PSIxNjkiPikudHVwbGVkPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iKCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI1NiIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjM5LjIiIHk9IjE2OSI+KDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==">
      <figcaption>Figure 20: Applicative combination of checks</figcaption>
    </figure>
    <p>Not really. With applicative combination, both checks are applied to the same value and result in a tuple with the value repeated. What we want feels more like a monoid as shown in <a href="#loc-439">Figure 21</a>. We can define a sensible identity—a check that always passes—and two binary combination operators—<em>and</em> and <em>or</em>:</p>
    <figure id="loc-439">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTY0M3B4IiBoZWlnaHQ9IjI3MHB4IiB2aWV3Qm94PSIwIDAgMTY0MyAyNzAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5tb25vaWQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC0xIiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2OC4xMjM5ODA0IiByeT0iNjguMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTIiIGN4PSI4Ni4xMjM5ODA0IiBjeT0iODUuMjEwNTI2MyIgcng9IjY4LjEyMzk4MDQiIHJ5PSI2OC4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMyIgY3g9IjY4LjEyMzk4MDQiIGN5PSI4NS4yMTA1MjYzIiByeD0iNjguMTIzOTgwNCIgcnk9IjY4LjIxMDUyNjMiPjwvZWxsaXBzZT4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC00IiBjeD0iODUuMTIzOTgwNCIgY3k9Ijg2LjIxMDUyNjMiIHJ4PSI2OC4xMjM5ODA0IiByeT0iNjguMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTUiIGN4PSI2OC4xMjM5ODA0IiBjeT0iODUuMjEwNTI2MyIgcng9IjY4LjEyMzk4MDQiIHJ5PSI2OC4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtNiIgY3g9Ijg1LjEyMzk4MDQiIGN5PSI4Ni4yMTA1MjYzIiByeD0iNjguMTIzOTgwNCIgcnk9IjY4LjIxMDUyNjMiPjwvZWxsaXBzZT4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJtb25vaWQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzkuMDAwMDAwLCAtNjAuMDAwMDAwKSI+CiAgICAgICAgICAgIDxyZWN0IGlkPSJCYWNrZ3JvdW5kIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMSIgaGVpZ2h0PSIzNjAiPjwvcmVjdD4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzOS4wMDAwMDAsIDYxLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNzIuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iODYuMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSIyIiB5PSIyIiB3aWR0aD0iMTY2LjMwOTk1MSIgaGVpZ2h0PSIxNjYuNTI2MzE2IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxNzEgNzAuMDUyNjMxNiAyMDUuMDYxOTkgNzAuMDUyNjMxNiAyMDUuMDYxOTkgNTMgMjM5LjEyMzk4IDg2LjY3NzA0MzYgMjA1LjA2MTk5IDEyMS4yMTA1MjYgMjA1LjA2MTk5IDEwNC4xNTc4OTUgMTcxIDEwNC4xNTc4OTUiPjwvcG9seWdvbj4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyNDYuOTM2ODY4IiB5PSIzMjUiPkEgPSZndDsgRltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDczOS4wMDAwMDAsIDYwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNjguMTIzOTgwNCIgY3k9Ijg1LjIxMDUyNjMiIHJ4PSI2Ni4xMjM5ODA0IiByeT0iNjYuMjEwNTI2MyI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNzMuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIiIHk9IjIiIHdpZHRoPSIxNjYuMzA5OTUxIiBoZWlnaHQ9IjE2Ni41MjYzMTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC00Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI4NS4xMjM5ODA0IiBjeT0iODYuMjEwNTI2MyIgcng9IjY2LjEyMzk4MDQiIHJ5PSI2Ni4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxNzIgNzEuMDUyNjMxNiAyMDYuMDYxOTkgNzEuMDUyNjMxNiAyMDYuMDYxOTkgNTQgMjQwLjEyMzk4IDg3LjY3NzA0MzYgMjA2LjA2MTk5IDEyMi4yMTA1MjYgMjA2LjA2MTk5IDEwNS4xNTc4OTUgMTcyIDEwNS4xNTc4OTUiPjwvcG9seWdvbj4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI4NDYuMzUxMjIzIiB5PSIzMjQiPkEgPSZndDsgRltBXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstRltBXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTQ0Ni42MzQyNiIgeT0iMzI0Ij5BID0mZ3Q7IEZbQV08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC01IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzM5LjAwMDAwMCwgNjAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI2OC4xMjM5ODA0IiBjeT0iODUuMjEwNTI2MyIgcng9IjY2LjEyMzk4MDQiIHJ5PSI2Ni4yMTA1MjYzIj48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjMDAwMDAwIiBwb2ludHM9IjE3MSA2OC4wNTI2MzE2IDIwNS4wNjE5OSA2OC4wNTI2MzE2IDIwNS4wNjE5OSA1MSAyMzkuMTIzOTggODQuNjc3MDQzNiAyMDUuMDYxOTkgMTE5LjIxMDUyNiAyMDUuMDYxOTkgMTAyLjE1Nzg5NSAxNzEgMTAyLjE1Nzg5NSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3Mi4wMDAwMDAsIDAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iMi42OTAwNDg5NCIgeT0iMiIgd2lkdGg9IjE2Ni4zMDk5NTEiIGhlaWdodD0iMTY2LjUyNjMxNiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTYiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8ZWxsaXBzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9Ijg1LjEyMzk4MDQiIGN5PSI4Ni4yMTA1MjYzIiByeD0iNjYuMTIzOTgwNCIgcnk9IjY2LjIxMDUyNjMiPjwvZWxsaXBzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIxMjIxIDEyNyAxMjYxIDEyNyAxMjYxIDEwNyAxMzAxIDE0Ni40OTc3NjcgMTI2MSAxODcgMTI2MSAxNjcgMTIyMSAxNjciPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9InwrfCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI1NiIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYxMS4xIiB5PSIxNjkiPnwrfDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==">
      <figcaption>Figure 21: Monoid combination of checks</figcaption>
    </figure>
    <p>We’ll probably be using <em>and</em> and <em>or</em> about equally often with our validation library and it will be annoying to continuously switch between two monoids for combining rules. We consequently won’t actually use the monoid API: we’ll use two separate methods, <code>and</code> and <code>or</code>, instead.</p>
    <p><strong>Accumulating errors as we check</strong></p>
    <p>Monoids also feel like a good mechanism for accumulating error messages. If we store messages as a <code>List</code> or <code>NonEmptyList</code>, we can even use a pre-existing monoid from inside Cats.</p>
    <p><strong>Transforming data as we check it</strong></p>
    <p>In addition to checking data, we also have the goal of transforming it. This seems like it should be a <code>map</code> or a <code>flatMap</code> depending on whether the transform can fail or not, so it seems we also want checks to be a monad as shown in <a href="#loc-440">Figure 22</a>.</p>
    <figure id="loc-440">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTYxNHB4IiBoZWlnaHQ9IjU0MnB4IiB2aWV3Qm94PSIwIDAgMTYxNCA1NDIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5tb25hZDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTEiIHBvaW50cz0iMjc5LjM4NTY2MyAxMDAuMDEzNDcxIDI0NS4xNTEyNTcgMTE3Ljg5NTggMjUxLjY4OTQ0NyA4MC4wMjA0MTk2IDIyMy45OTMyMyA1My4xOTY5MjY1IDI2Mi4yNjg0NiA0Ny42NzA5ODMxIDI3OS4zODU2NjMgMTMuMjEwODIzOSAyOTYuNTAyODY3IDQ3LjY3MDk4MzEgMzM0Ljc3ODA5NyA1My4xOTY5MjY1IDMwNy4wODE4OCA4MC4wMjA0MTk2IDMxMy42MjAwNyAxMTcuODk1OCI+PC9wb2x5Z29uPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTIiIGN4PSI1My4xNjgzMjkiIGN5PSI2Ni4xMDQyODUzIiByeD0iNTMuMTY4MzI5IiByeT0iNTIuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTMiIHBvaW50cz0iMjY3LjAyNjg2MyA5OC4xMzYyNDk2IDIzMi43OTI0NTYgMTE2LjAxODU3OCAyMzkuMzMwNjQ2IDc4LjE0MzE5ODMgMjExLjYzNDQyOSA1MS4zMTk3MDUyIDI0OS45MDk2NTkgNDUuNzkzNzYxNyAyNjcuMDI2ODYzIDExLjMzMzYwMjYgMjg0LjE0NDA2NiA0NS43OTM3NjE3IDMyMi40MTkyOTYgNTEuMzE5NzA1MiAyOTQuNzIzMDc5IDc4LjE0MzE5ODMgMzAxLjI2MTI2OSAxMTYuMDE4NTc4Ij48L3BvbHlnb24+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtNCIgY3g9IjUzLjI5Njk1NTciIGN5PSI2Ny4zMjg4NDExIiByeD0iNTMuMTY4MzI5IiByeT0iNTIuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTUiIGN4PSI1My40MjI2ODEiIGN5PSI2Ni4zMjg4NDExIiByeD0iNTMuMTY4MzI5IiByeT0iNTIuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTYiIGN4PSI1My42MjY3NDI5IiBjeT0iNjYuMzUxNDU4MiIgcng9IjUzLjE2ODMyOSIgcnk9IjUyLjg5MzQ2MTQiPjwvZWxsaXBzZT4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC03IiBwb2ludHM9IjI3OS44NDQwNzcgOTkuNDg1MTk5NSAyNDUuNjA5NjcxIDExNy4zNjc1MjggMjUyLjE0Nzg2MSA3OS40OTIxNDgyIDIyNC40NTE2NDQgNTIuNjY4NjU1MSAyNjIuNzI2ODc0IDQ3LjE0MjcxMTcgMjc5Ljg0NDA3NyAxMi42ODI1NTI1IDI5Ni45NjEyODEgNDcuMTQyNzExNyAzMzUuMjM2NTExIDUyLjY2ODY1NTEgMzA3LjU0MDI5NCA3OS40OTIxNDgyIDMxNC4wNzg0ODQgMTE3LjM2NzUyOCI+PC9wb2x5Z29uPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTgiIGN4PSI1My4xODM4MDI5IiBjeT0iNjYuNTc2MDEzOSIgcng9IjUzLjE2ODMyOSIgcnk9IjUyLjg5MzQ2MTQiPjwvZWxsaXBzZT4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC05IiBwb2ludHM9IjU1LjY0MDk4MjYgODcuMjYwNjQzOCAyMS40MDY1NzYxIDEwNS4xNDI5NzMgMjcuOTQ0NzY2IDY3LjI2NzU5MjUgMC4yNDg1NDkzMjMgNDAuNDQ0MDk5NCAzOC41MjM3Nzk0IDM0LjkxODE1NTkgNTUuNjQwOTgyNiAwLjQ1Nzk5Njc2OSA3Mi43NTgxODU4IDM0LjkxODE1NTkgMTExLjAzMzQxNiA0MC40NDQwOTk0IDgzLjMzNzE5OTIgNjcuMjY3NTkyNSA4OS44NzUzODkxIDEwNS4xNDI5NzMiPjwvcG9seWdvbj4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJtb25hZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE1NS4wMDAwMDAsIC0zNy4wMDAwMDApIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTIxIiBoZWlnaHQ9IjYyMSI+PC9yZWN0PgogICAgICAgICAgICA8ZyBpZD0iZmxhdG1hcCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU1LjAwMDAwMCwgMzU4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTEwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCwgMi4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iU3Rhci0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTI0Ny44MTAwOTUsMTE0LjI1MDU0NSBMMjUzLjY2MDI5OCw4MC4zNjA2MzUzIEwyNTMuODQwMDk1LDc5LjMxOTA3ODcgTDI1My4wODA4NDQsNzguNTgzNzUyMSBMMjI4LjMxMDg4Myw1NC41OTQzMDY2IEwyNjIuNTU0MjQ1LDQ5LjY1MDQ1OTUgTDI2My41OTI4MzMsNDkuNTAwNTE0NSBMMjY0LjA1OTY1NSw0OC41NjA3MTM0IEwyNzkuMzg1NjYzLDE3LjcwNjU2NzkgTDI5NC43MTE2NzIsNDguNTYwNzEzNCBMMjk1LjE3ODQ5NCw0OS41MDA1MTQ1IEwyOTYuMjE3MDgyLDQ5LjY1MDQ1OTUgTDMzMC40NjA0NDQsNTQuNTk0MzA2NiBMMzA1LjY5MDQ4Myw3OC41ODM3NTIxIEwzMDQuOTMxMjMyLDc5LjMxOTA3ODcgTDMwNS4xMTEwMjksODAuMzYwNjM1MyBMMzEwLjk2MTIzMiwxMTQuMjUwNTQ1IEwyODAuMzExNjQ2LDk4LjI0MDc0NTMgTDI3OS4zODU2NjMsOTcuNzU3MDU4NyBMMjc4LjQ1OTY4MSw5OC4yNDA3NDUzIEwyNDcuODEwMDk1LDExNC4yNTA1NDUgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8ZWxsaXBzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjUzLjE2ODMyOSIgY3k9IjY2LjEwNDI4NTMiIHJ4PSI1MS4xNjgzMjkiIHJ5PSI1MC44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIxNC4yODYyNjciIHk9IjIuMDI4MjcxNDEiIHdpZHRoPSIxMjguOTIwODIzIiBoZWlnaHQ9IjEyOC4yMzM2NTQiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxMzMuNDU5MzgxIDU0LjM1MDE4MjggMTYwLjA0MzU0NiA1NC4zNTAxODI4IDE2MC4wNDM1NDYgNDEuMTI2ODE3NCAxODYuNjI3NzEgNjcuMjQxNDg3NyAxNjAuMDQzNTQ2IDk0LjAyMDI3ODkgMTYwLjA0MzU0NiA4MC43OTY5MTM1IDEzMy40NTkzODEgODAuNzk2OTEzNSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU4Ni4wMDAwMDAsIDAuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGQ9Ik0yMzUuNDUxMjk0LDExMi4zNzMzMjMgTDI0MS4zMDE0OTcsNzguNDgzNDE0IEwyNDEuNDgxMjk0LDc3LjQ0MTg1NzQgTDI0MC43MjIwNDMsNzYuNzA2NTMwOCBMMjE1Ljk1MjA4Miw1Mi43MTcwODUyIEwyNTAuMTk1NDQ0LDQ3Ljc3MzIzODIgTDI1MS4yMzQwMzIsNDcuNjIzMjkzMiBMMjUxLjcwMDg1NSw0Ni42ODM0OTIxIEwyNjcuMDI2ODYzLDE1LjgyOTM0NjYgTDI4Mi4zNTI4NzEsNDYuNjgzNDkyMSBMMjgyLjgxOTY5Myw0Ny42MjMyOTMyIEwyODMuODU4MjgxLDQ3Ljc3MzIzODIgTDMxOC4xMDE2NDMsNTIuNzE3MDg1MiBMMjkzLjMzMTY4Miw3Ni43MDY1MzA4IEwyOTIuNTcyNDMxLDc3LjQ0MTg1NzQgTDI5Mi43NTIyMjgsNzguNDgzNDE0IEwyOTguNjAyNDMxLDExMi4zNzMzMjMgTDI2Ny45NTI4NDUsOTYuMzYzNTI0IEwyNjcuMDI2ODYzLDk1Ljg3OTgzNzMgTDI2Ni4xMDA4OCw5Ni4zNjM1MjQgTDIzNS40NTEyOTQsMTEyLjM3MzMyMyBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iMzQ3LjQzNTIwMyA1My4yNDg0MDU3IDM3NC4wMTkzNjggNTMuMjQ4NDA1NyAzNzQuMDE5MzY4IDQwLjAyNTA0MDQgNDAwLjYwMzUzMiA2Ni4xMzk3MTA3IDM3NC4wMTkzNjggOTIuOTE4NTAxOCAzNzQuMDE5MzY4IDc5LjY5NTEzNjUgMzQ3LjQzNTIwMyA3OS42OTUxMzY1Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iNDI4LjgwMDY0NyIgeT0iMi40NzczODI4OCIgd2lkdGg9IjEyOC45MjA4MjMiIGhlaWdodD0iMTI4LjIzMzY1NCIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTQiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8ZWxsaXBzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjUzLjI5Njk1NTciIGN5PSI2Ny4zMjg4NDExIiByeD0iNTEuMTY4MzI5IiByeT0iNTAuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjMDAwMDAwIiBwb2ludHM9IjEzMy41ODgwMDggNTUuNTc0NzM4NSAxNjAuMTcyMTcyIDU1LjU3NDczODUgMTYwLjE3MjE3MiA0Mi4zNTEzNzMyIDE4Ni43NTYzMzcgNjguNDY2MDQzNSAxNjAuMTcyMTcyIDk1LjI0NDgzNDYgMTYwLjE3MjE3MiA4Mi4wMjE0NjkzIDEzMy41ODgwMDggODIuMDIxNDY5MyI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQb2x5Z29uIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSI0OTMuMDgyNTk3IDIzIDUzOS4xNjUxOTQgNTYuMjY1NjE2NyA1MjEuNTYzMjA4IDExMC4wOTA1MTUgNDY0LjYwMTk4NiAxMTAuMDkwNTE1IDQ0NyA1Ni4yNjU2MTY3Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0JdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTkuNDY3MDIxMyIgeT0iMjE1Ij5BID0mZ3Q7IEZbQl08L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IkItPSZndDstKEEtPSZndDstRltDXSkiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI2NjQuNTcwNjk2IiB5PSIyMTUiPkIgPSZndDsgKEEgPSZndDsgRltDXSk8L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstRltDXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEzMjcuMTEwMyIgeT0iMjE1Ij5BID0mZ3Q7IEZbQ108L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyNjguMDAwMDAwLCAxLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNTMuNDIyNjgxIiBjeT0iNjYuMzI4ODQxMSIgcng9IjUxLjE2ODMyOSIgcnk9IjUwLjg5MzQ2MTQiPjwvZWxsaXBzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxMzMuNzEzNzMzIDUzLjAyMzg1IDE2MC4yOTc4OTggNTMuMDIzODUgMTYwLjI5Nzg5OCAzOS44MDA0ODQ3IDE4Ni44ODIwNjIgNjUuOTE1MTU0OSAxNjAuMjk3ODk4IDkyLjY5Mzk0NjEgMTYwLjI5Nzg5OCA3OS40NzA1ODA3IDEzMy43MTM3MzMgNzkuNDcwNTgwNyI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIxNS4wNzkxNzciIHk9IjIuMjUyODI3MTQiIHdpZHRoPSIxMjguOTIwODIzIiBoZWlnaHQ9IjEyOC4yMzM2NTQiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24iIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjI4MC4wODI1OTcgMjMgMzI2LjE2NTE5NCA1Ni4yNjU2MTY3IDMwOC41NjMyMDggMTEwLjA5MDUxNSAyNTEuNjAxOTg2IDExMC4wOTA1MTUgMjM0IDU2LjI2NTYxNjciPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMTE3OC41MDA5NyA1My4yMDc1OTI5IDEyMDkuNzE5NTQgNTMuMjA3NTkyOSAxMjA5LjcxOTU0IDM3LjY5ODcwNzYgMTI0MC45MzgxIDY4LjMyNzAyNDYgMTIwOS43MTk1NCA5OS43MzQyNDg4IDEyMDkuNzE5NTQgODQuMjI1MzYzNSAxMTc4LjUwMDk3IDg0LjIyNTM2MzUiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJmbGF0TWFwIiBmb250LWZhbWlseT0iRmlyYU1vbm8tQm9sZCwgRmlyYSBNb25vIiBmb250LXNpemU9IjQ1IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI0Y2QTYyMyI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjM3NS43ODE2NzMiIHk9IjgyIj5mbGF0TWFwPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0ibWFwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMjAuMDAwMDAwLCAzNy4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUZbQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI2NS4xMzc4MTQzIiB5PSIyMTQiPkEgPSZndDsgRltCXTwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCAxLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNTMuNjI2NzQyOSIgY3k9IjY2LjM1MTQ1ODIiIHJ4PSI1MS4xNjgzMjkiIHJ5PSI1MC44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjIxNC43NDQ2ODEiIHk9IjIuMjc1NDQ0MjYiIHdpZHRoPSIxMjguOTIwODIzIiBoZWlnaHQ9IjEyOC4yMzM2NTQiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIxMzMuOTE3Nzk1IDU0LjU5NzM1NTcgMTYwLjUwMTk1OSA1NC41OTczNTU3IDE2MC41MDE5NTkgNDEuMzczOTkwMyAxODcuMDg2MTI0IDY3LjQ4ODY2MDYgMTYwLjUwMTk1OSA5NC4yNjc0NTE3IDE2MC41MDE5NTkgODEuMDQ0MDg2NCAxMzMuOTE3Nzk1IDgxLjA0NDA4NjQiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iU3Rhci0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTI0OC4yNjg1MDksMTEzLjcyMjI3MyBMMjU0LjExODcxMiw3OS44MzIzNjM5IEwyNTQuMjk4NTA5LDc4Ljc5MDgwNzMgTDI1My41MzkyNTgsNzguMDU1NDgwNyBMMjI4Ljc2OTI5Nyw1NC4wNjYwMzUyIEwyNjMuMDEyNjU5LDQ5LjEyMjE4ODEgTDI2NC4wNTEyNDcsNDguOTcyMjQzMSBMMjY0LjUxODA2OSw0OC4wMzI0NDIgTDI3OS44NDQwNzcsMTcuMTc4Mjk2NSBMMjk1LjE3MDA4Niw0OC4wMzI0NDIgTDI5NS42MzY5MDgsNDguOTcyMjQzMSBMMjk2LjY3NTQ5Niw0OS4xMjIxODgxIEwzMzAuOTE4ODU4LDU0LjA2NjAzNTIgTDMwNi4xNDg4OTcsNzguMDU1NDgwNyBMMzA1LjM4OTY0Niw3OC43OTA4MDczIEwzMDUuNTY5NDQzLDc5LjgzMjM2MzkgTDMxMS40MTk2NDYsMTEzLjcyMjI3MyBMMjgwLjc3MDA2LDk3LjcxMjQ3MzkgTDI3OS44NDQwNzcsOTcuMjI4Nzg3MiBMMjc4LjkxODA5NSw5Ny43MTI0NzM5IEwyNDguMjY4NTA5LDExMy43MjIyNzMgWiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJCLT0mZ3Q7LUMiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI1NzAuOTAwNjE2IiB5PSIyMTQiPkIgPSZndDsgQzwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0NdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAwMS41MTAzIiB5PSIyMTQiPkEgPSZndDsgRltDXTwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjgzNy4xMTYwNTQgNTIuNDU0NzY1OCA4NjguMzM0NjIzIDUyLjQ1NDc2NTggODY4LjMzNDYyMyAzNi45NDU4ODA1IDg5OS41NTMxOTEgNjcuNTc0MTk3NSA4NjguMzM0NjIzIDk4Ljk4MTQyMTYgODY4LjMzNDYyMyA4My40NzI1MzYzIDgzNy4xMTYwNTQgODMuNDcyNTM2MyI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHRleHQgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0NSIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIzODAuMjM4Mzk1IiB5PSI4MS42MTk1NDc3Ij5tYXA8L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwLTEyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5MzcuMDAwMDAwLCAwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtOCI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNTMuMTgzODAyOSIgY3k9IjY2LjU3NjAxMzkiIHJ4PSI1MS4xNjgzMjkiIHJ5PSI1MC44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iMTMzLjQ3NDg1NSA1My4yNzEwMjI5IDE2MC4wNTkwMTkgNTMuMjcxMDIyOSAxNjAuMDU5MDE5IDQwLjA0NzY1NzUgMTg2LjY0MzE4NCA2Ni4xNjIzMjc4IDE2MC4wNTkwMTkgOTIuOTQxMTE5IDE2MC4wNTkwMTkgNzkuNzE3NzUzNiAxMzMuNDc0ODU1IDc5LjcxNzc1MzYiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSIyMTQuODQwMjk5IiB5PSIyLjUiIHdpZHRoPSIxMjguOTIwODIzIiBoZWlnaHQ9IjEyOC4yMzM2NTQiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24iIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjI3OS41OTc0NDcgMjMuMDgyNzY2IDMyNS42ODAwNDQgNTYuMzQ4MzgyNyAzMDguMDc4MDU4IDExMC4xNzMyODEgMjUxLjExNjgzNiAxMTAuMTczMjgxIDIzMy41MTQ4NSA1Ni4zNDgzODI3Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4OC4wMDAwMDAsIDE0LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMjQuMDY1NDEzOSwxMDEuNDk3NzE3IEwyOS45MTU2MTY5LDY3LjYwNzgwODIgTDMwLjA5NTQxNDMsNjYuNTY2MjUxNiBMMjkuMzM2MTYzMyw2NS44MzA5MjUgTDQuNTY2MjAyMTQsNDEuODQxNDc5NCBMMzguODA5NTY0MSwzNi44OTc2MzI0IEwzOS44NDgxNTIzLDM2Ljc0NzY4NzQgTDQwLjMxNDk3NDQsMzUuODA3ODg2MyBMNTUuNjQwOTgyNiw0Ljk1Mzc0MDc2IEw3MC45NjY5OTA4LDM1LjgwNzg4NjMgTDcxLjQzMzgxMjksMzYuNzQ3Njg3NCBMNzIuNDcyNDAxMSwzNi44OTc2MzI0IEwxMDYuNzE1NzYzLDQxLjg0MTQ3OTQgTDgxLjk0NTgwMTksNjUuODMwOTI1IEw4MS4xODY1NTA5LDY2LjU2NjI1MTYgTDgxLjM2NjM0ODMsNjcuNjA3ODA4MiBMODcuMjE2NTUxMywxMDEuNDk3NzE3IEw1Ni41NjY5NjUyLDg1LjQ4NzkxODEgTDU1LjY0MDk4MjYsODUuMDA0MjMxNSBMNTQuNzE1LDg1LjQ4NzkxODEgTDI0LjA2NTQxMzksMTAxLjQ5NzcxNyBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iMTM2LjgyOTc4NyA0MS41OTczNTU3IDE2My40MTM5NTIgNDEuNTk3MzU1NyAxNjMuNDEzOTUyIDI4LjM3Mzk5MDMgMTg5Ljk5ODExNiA1NC40ODg2NjA2IDE2My40MTM5NTIgODEuMjY3NDUxNyAxNjMuNDEzOTUyIDY4LjA0NDA4NjQgMTM2LjgyOTc4NyA2OC4wNDQwODY0Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24iIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjI2My4zMDAxOTkgOC4yMTI0Mzk0MiAzMDkuMzgyNzk2IDQxLjQ3ODA1NjEgMjkxLjc4MDgxIDk1LjMwMjk1NDUgMjM0LjgxOTU4NyA5NS4zMDI5NTQ1IDIxNy4yMTc2MDIgNDEuNDc4MDU2MSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
      <figcaption>Figure 22: Monadic combination of checks</figcaption>
    </figure>
    <p>We’ve now broken down our library into familiar abstractions and are in a good position to begin development.</p>
    <h3 id="loc-441">21.2. The Check Datatype</h3>
    <p>Our design revolves around a <code>Check</code>, which we said was a function from a value to a value in a context. As soon as you see this description you should think of something like</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">String</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>Here we’ve represented the error message as a <code>String</code>. This is probably not the best representation. We may want to accumulate messages in a <code>List</code>, for example, or even use a different representation that allows for internationalization or standard error codes.</p>
    <p>We could attempt to build some kind of <code>ErrorMessage</code> type that holds all the information we can think of. However, we can’t predict the user’s requirements. Instead let’s let the user specify what they want. We can do this by adding a second type parameter to <code>Check</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>We will probably want to add custom methods to <code>Check</code> so let’s declare it as a <code>trait</code> instead of a type alias:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(value: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> other methods...</span><br>}</code></pre>
    <p>As we said in [Essential Scala][link-essential-scala], there are two functional programming patterns that we should consider when defining a trait:</p>
    <ul>
      <li>we can make it a typeclass, or;</li>
      <li>we can make it an algebraic data type (and hence seal it).</li>
    </ul>
    <p>Type classes allow us to unify disparate data types with a common interface. This doesn’t seem like what we’re trying to do here. That leaves us with an algebraic data type. Let’s keep that thought in mind as we explore the design a bit further.</p>
    <h3 id="loc-442">21.3. Basic Combinators</h3>
    <p>Let’s add some combinator methods to <code>Check</code>, starting with <code>and</code>. This method combines two checks into one, succeeding only if both checks succeed. Think about implementing this method now. You should hit some problems. Read on when you do!</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>(that: <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> other methods...</span><br>}</code></pre>
    <p>The problem is: what do you do when <em>both</em> checks fail? The correct thing to do is to return both errors, but we don’t currently have any way to combine <code>Es</code>. We need a <em>type class</em> that abstracts over the concept of “accumulating” errors as shown in <a href="#loc-443">Figure 23</a> What type class do we know that looks like this? What method or operator should we use to implement the <code>?</code> operation?</p>
    <figure id="loc-443">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTkyMXB4IiBoZWlnaHQ9IjY2MHB4IiB2aWV3Qm94PSIwIDAgMTkyMSA2NjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5lcnJvci1zZW1pZ3JvdXA8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iZXJyb3Itc2VtaWdyb3VwIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTIxIiBoZWlnaHQ9IjY2MCI+PC9yZWN0PgogICAgICAgICAgICA8dGV4dCBpZD0iRS3igKItRS09Jmd0Oy1FIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI4NDAiIHk9IjMxOSI+RSDigKIgRSA9Jmd0OyBFPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iTGlzdFtTdHJpbmddLeKAoi1MaXN0WyIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNDE5LjIiIHk9IjYwMSI+TGlzdFtTdHJpbmddIOKAoiBMaXN0W1N0cmluZ10gPSZndDsgTGlzdFtTdHJpbmddPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU4MC4wMDAwMDAsIDQyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24tMiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHBvaW50cz0iMzY0LjUgMSA0NDEuMDYwMDUgNTYuNjI0MTMyIDQxMS44MTY3MTMgMTQ2LjYyNTg2OCAzMTcuMTgzMjg3IDE0Ni42MjU4NjggMjg3LjkzOTk1IDU2LjYyNDEzMiI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24tMiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHBvaW50cz0iNzYuNTYwMDQ5NiAwIDE1My4xMjAwOTkgNTUuNjI0MTMyIDEyMy44NzY3NjIgMTQ1LjYyNTg2OCAyOS4yNDMzMzY4IDE0NS42MjU4NjggLTEuNDIxMDg1NDdlLTE0IDU1LjYyNDEzMiI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24tMiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHBvaW50cz0iNjgzLjU2MDA1IDAgNzYwLjEyMDA5OSA1NS42MjQxMzIgNzMwLjg3Njc2MiAxNDUuNjI1ODY4IDYzNi4yNDMzMzcgMTQ1LjYyNTg2OCA2MDcgNTUuNjI0MTMyIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjMDAwMDAwIiBwb2ludHM9IjQ4NSA2MCA1MjUgNjAgNTI1IDQwIDU2NSA3OS40OTc3NjcxIDUyNSAxMjAgNTI1IDEwMCA0ODUgMTAwIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMDAwMDAwIiBjeD0iMjE5IiBjeT0iODEiIHI9IjIwIj48L2NpcmNsZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMjAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU2NS4wMDAwMDAsIDMzNC4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjg5LjAwMDAwMCwgOS4wMDAwMDApIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZT0iIzAwMDAwMCIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24tMiIgcG9pbnRzPSI5NS41NjAwNDk2IDI3IDE3Mi4xMjAwOTkgODIuNjI0MTMyIDE0Mi44NzY3NjIgMTcyLjYyNTg2OCA0OC4yNDMzMzY4IDE3Mi42MjU4NjggMTkgODIuNjI0MTMyIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24tMiIgcG9pbnRzPSI3Ni41NjAwNDk2IDAgMTUzLjEyMDA5OSA1NS42MjQxMzIgMTIzLjg3Njc2MiAxNDUuNjI1ODY4IDI5LjI0MzMzNjggMTQ1LjYyNTg2OCAtMS40MjEwODU0N2UtMTQgNTUuNjI0MTMyIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCA1LjAwMDAwMCkiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlPSIjMDAwMDAwIiBmaWxsPSIjRkZGRkZGIj4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbi0yIiBwb2ludHM9Ijk1LjU2MDA0OTYgMjcgMTcyLjEyMDA5OSA4Mi42MjQxMzIgMTQyLjg3Njc2MiAxNzIuNjI1ODY4IDQ4LjI0MzMzNjggMTcyLjYyNTg2OCAxOSA4Mi42MjQxMzIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbi0yIiBwb2ludHM9Ijc2LjU2MDA0OTYgMCAxNTMuMTIwMDk5IDU1LjYyNDEzMiAxMjMuODc2NzYyIDE0NS42MjU4NjggMjkuMjQzMzM2OCAxNDUuNjI1ODY4IC0xLjQyMTA4NTQ3ZS0xNCA1NS42MjQxMzIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTk3LjAwMDAwMCwgMC4wMDAwMDApIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZT0iIzAwMDAwMCIgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24tMiIgcG9pbnRzPSIxMTYuNTYwMDUgNDIgMTkzLjEyMDA5OSA5Ny42MjQxMzIgMTYzLjg3Njc2MiAxODcuNjI1ODY4IDY5LjI0MzMzNjggMTg3LjYyNTg2OCA0MCA5Ny42MjQxMzIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbi0yIiBwb2ludHM9Ijk1LjU2MDA0OTYgMjIgMTcyLjEyMDA5OSA3Ny42MjQxMzIgMTQyLjg3Njc2MiAxNjcuNjI1ODY4IDQ4LjI0MzMzNjggMTY3LjYyNTg2OCAxOSA3Ny42MjQxMzIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbi0yIiBwb2ludHM9Ijc2LjU2MDA0OTYgMCAxNTMuMTIwMDk5IDU1LjYyNDEzMiAxMjMuODc2NzYyIDE0NS42MjU4NjggMjkuMjQzMzM2OCAxNDUuNjI1ODY4IC0xLjQyMTA4NTQ3ZS0xNCA1NS42MjQxMzIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iNDk0IDgyIDUzNCA4MiA1MzQgNjIgNTc0IDEwMS40OTc3NjcgNTM0IDE0MiA1MzQgMTIyIDQ5NCAxMjIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwiIGZpbGw9IiMwMDAwMDAiIGN4PSIyMjgiIGN5PSIxMDMiIHI9IjIwIj48L2NpcmNsZT4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 23: Combining error messages</figcaption>
    </figure>
    <p>There is another semantic issue that will come up quite quickly: should <code>and</code> short-circuit if the first check fails. What do you think the most useful behaviour is?</p>
    <p>Use this knowledge to implement <code>and</code>. Make sure you end up with the behaviour you expect!</p>
    <p>Strictly speaking, <code>Either[E, A]</code> is the wrong abstraction for the output of our check. Why is this the case? What other data type could we use instead? Switch your implementation over to this new data type.</p>
    <p>Our implementation is looking pretty good now. Implement an <code>or</code> combinator to complement <code>and</code>.</p>
    <p>With <code>and</code> and <code>or</code> we can implement many of checks we’ll want in practice. However, we still have a few more methods to add. We’ll turn to <code>map</code> and related methods next.</p>
    <h3 id="loc-444">21.4. Transforming Data</h3>
    <p>One of our requirements is the ability to transform data. This allows us to support additional scenarios like parsing input. In this section we’ll extend our check library with this additional functionality.</p>
    <p>The obvious starting point is <code>map</code>. When we try to implement this, we immediately run into a wall. Our current definition of <code>Check</code> requires the input and output types to be the same:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <p>When we map over a check, what type do we assign to the result? It can’t be <code>A</code> and it can’t be <code>B</code>. We are at an impasse:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>(check: <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>])(func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span>): <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #d73948">?</span><span style="color: #d73948">?</span><span style="color: #d73948">?</span>]</code></pre>
    <p>To implement <code>map</code> we need to change the definition of <code>Check</code>. Specifically, we need to a new type variable to separate the input type from the output:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">B</span>]</code></pre>
    <p>Checks can now represent operations like parsing a <code>String</code> as an <code>Int</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> parseInt: <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">String</span>], <span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>] =<br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span></code></pre>
    <p>However, splitting our input and output types raises another issue. Up until now we have operated under the assumption that a <code>Check</code> always returns its input when successful. We used this in <code>and</code> and <code>or</code> to ignore the output of the left and right rules and simply return the original input on success:</p>
    <pre><code data-lang="scala">(<span style="color: #d73948">this</span>(a), that(a)) <span style="color: #d73948">match</span> {<br>  <span style="color: #d73948">case</span> <span style="color: #4b69c6">And</span>(left, right) <span style="color: #d73948">=></span><br>    (left(a), right(a))<br>      .mapN((result1, result2) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Right</span>(a))<br><br>  <span style="color: #74747c">//</span><span style="color: #74747c"> etc...</span><br>}</code></pre>
    <p>In our new formulation we can’t return <code>Right(a)</code> because its type is <code>Either[E, A]</code> not <code>Either[E, B]</code>. We’re forced to make an arbitrary choice between returning <code>Right(result1)</code> and <code>Right(result2)</code>. The same is true of the <code>or</code> method. From this we can derive two things:</p>
    <ul>
      <li>we should strive to make the laws we adhere to explicit; and</li>
      <li>the code is telling us we have the wrong abstraction in <code>Check</code>.</li>
    </ul>
    <h4 id="loc-445">21.4.1. Predicates</h4>
    <p>We can make progress by pulling apart the concept of a <em>predicate</em>, which can be combined using logical operations such as <em>and</em> and <em>or</em>, and the concept of a <em>check</em>, which can transform data.</p>
    <p>What we have called <code>Check</code> so far we will call <code>Predicate</code>. For <code>Predicate</code> we can state the following <em>identity law</em> encoding the notion that a predicate always returns its input if it succeeds:</p>
    <p>> For a predicate <code>p</code> of type <code>Predicate[E, A]</code> > and elements <code>a1</code> and <code>a2</code> of type <code>A</code>, > if <code>p(a1) == Success(a2)</code> then <code>a1 == a2</code>.</p>
    <p>Making this change gives us the following code:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.Semigroup<br><span style="color: #d73948">import</span> cats.data.Validated<br><span style="color: #d73948">import</span> cats.syntax.semigroup.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for |+|</span><br><span style="color: #d73948">import</span> cats.syntax.apply.<span style="color: #d73948">_</span>     <span style="color: #74747c">//</span><span style="color: #74747c"> for mapN</span><br><span style="color: #d73948">import</span> cats.data.Validated.<span style="color: #d73948">_</span>   <span style="color: #74747c">//</span><span style="color: #74747c"> for Valid and Invalid</span></code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">trait</span><span style="color: #4b69c6"> Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">and</span>(that: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">And</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">or</span>(that: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #4b69c6">Or</span>(<span style="color: #d73948">this</span>, that)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(a: <span style="color: #4b69c6">A</span>)(<span style="color: #d73948">implicit</span> s: <span style="color: #4b69c6">Semigroup</span>[<span style="color: #4b69c6">E</span>]): <span style="color: #4b69c6">Validated</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">this</span> <span style="color: #d73948">match</span> {<br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Pure</span>(func) <span style="color: #d73948">=></span><br>        func(a)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">And</span>(left, right) <span style="color: #d73948">=></span><br>        (left(a), right(a)).mapN((<span style="color: #d73948">_</span>, <span style="color: #d73948">_</span>) <span style="color: #d73948">=></span> a)<br><br>      <span style="color: #d73948">case</span> <span style="color: #4b69c6">Or</span>(left, right) <span style="color: #d73948">=></span><br>        left(a) <span style="color: #d73948">match</span> {<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Valid</span>(<span style="color: #d73948">_</span>)   <span style="color: #d73948">=></span> <span style="color: #4b69c6">Valid</span>(a)<br>          <span style="color: #d73948">case</span> <span style="color: #4b69c6">Invalid</span>(e1) <span style="color: #d73948">=></span><br>            right(a) <span style="color: #d73948">match</span> {<br>              <span style="color: #d73948">case</span> <span style="color: #4b69c6">Valid</span>(<span style="color: #d73948">_</span>)   <span style="color: #d73948">=></span> <span style="color: #4b69c6">Valid</span>(a)<br>              <span style="color: #d73948">case</span> <span style="color: #4b69c6">Invalid</span>(e2) <span style="color: #d73948">=></span> <span style="color: #4b69c6">Invalid</span>(e1 |+| e2)<br>            }<br>        }<br>    }<br>}<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> And</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>](<br>  left: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>],<br>  right: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Or</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>](<br>  left: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>],<br>  right: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Pure</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>](<br>  func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Validated</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]) <span style="color: #d73948">extends</span> <span style="color: #8b41b1">Predicate</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>]</code></pre>
    <h4 id="loc-446">21.4.2. Checks</h4>
    <p>We’ll use <code>Check</code> to represent a structure we build from a <code>Predicate</code> that also allows transformation of its input. Implement <code>Check</code> with the following interface:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">trait</span><span style="color: #4b69c6"> Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>(a: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">Validated</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">map</span>[<span style="color: #4b69c6">C</span>](func: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">C</span>): <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">C</span>] <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>What about <code>flatMap</code>? The semantics are a bit unclear here. The method is simple enough to declare but it’s not so obvious what it means or how we should implement <code>apply</code>. The general shape of <code>flatMap</code> is shown in <a href="#loc-447">Figure 24</a>.</p>
    <figure id="loc-447">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5MjFweCIgaGVpZ2h0PSIzNjBweCIgdmlld0JveD0iMCAwIDE5MjEgMzYwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Z2VuZXJpYy1mbGF0bWFwPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMSIgY3g9Ijg4NSIgY3k9IjE0MCIgcng9IjgwIiByeT0iODAiPjwvZWxsaXBzZT4KICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE2MCIgaGVpZ2h0PSIxNjAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMyIgcG9pbnRzPSIxMDEuNTk1MDg2IDE1NSA0OC42OTQ0MTM4IDE4Mi44MTE1MjkgNTguNzk3NTQzMiAxMjMuOTA1NzY1IDE2IDgyLjE4ODQ3MDUgNzUuMTQ0NzUwMSA3My41OTQyMzUzIDEwMS41OTUwODYgMjAgMTI4LjA0NTQyMyA3My41OTQyMzUzIDE4Ny4xOTAxNzMgODIuMTg4NDcwNSAxNDQuMzkyNjMgMTIzLjkwNTc2NSAxNTQuNDk1NzU5IDE4Mi44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay00IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MS4xOTAxNzMiIGhlaWdodD0iMTYyLjgxMTUyOSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cmVjdCBpZD0icGF0aC01IiB4PSIwIiB5PSIwIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgcng9IjgiPjwvcmVjdD4KICAgICAgICA8bWFzayBpZD0ibWFzay02IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNyIgcG9pbnRzPSIxMDEuNTk1MDg2IDE1NSA0OC42OTQ0MTM4IDE4Mi44MTE1MjkgNTguNzk3NTQzMiAxMjMuOTA1NzY1IDE2IDgyLjE4ODQ3MDUgNzUuMTQ0NzUwMSA3My41OTQyMzUzIDEwMS41OTUwODYgMjAgMTI4LjA0NTQyMyA3My41OTQyMzUzIDE4Ny4xOTAxNzMgODIuMTg4NDcwNSAxNDQuMzkyNjMgMTIzLjkwNTc2NSAxNTQuNDk1NzU5IDE4Mi44MTE1MjkiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay04IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3MS4xOTAxNzMiIGhlaWdodD0iMTYyLjgxMTUyOSIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgICAgICA8cmVjdCBpZD0icGF0aC05IiB4PSIwIiB5PSIwIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgcng9IjgiPjwvcmVjdD4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtOSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTExIiBwb2ludHM9Ijk5NCAxMjAgMTAzNCAxMjAgMTAzNCAxMDAgMTA3NCAxMzkuNDk3NzY3IDEwMzQgMTgwIDEwMzQgMTYwIDk5NCAxNjAiPjwvcG9seWdvbj4KICAgICAgICA8bWFzayBpZD0ibWFzay0xMiIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMTMiIGN4PSIxMDAiIGN5PSIxMDAiIHJ4PSI4MCIgcnk9IjgwIj48L2VsbGlwc2U+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stMTQiIG1hc2tDb250ZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiB4PSIwIiB5PSIwIiB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTEzIj48L3VzZT4KICAgICAgICA8L21hc2s+CiAgICAgICAgPHJlY3QgaWQ9InBhdGgtMTUiIHg9IjAiIHk9IjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiByeD0iOCI+PC9yZWN0PgogICAgICAgIDxtYXNrIGlkPSJtYXNrLTE2IiBtYXNrQ29udGVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFza1VuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IndoaXRlIj4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcGF0aC0xNSI+PC91c2U+CiAgICAgICAgPC9tYXNrPgogICAgPC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImdlbmVyaWMtZmxhdG1hcCI+CiAgICAgICAgICAgIDxyZWN0IGlkPSJCYWNrZ3JvdW5kIiBmaWxsPSIjRkZGRkZGIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMSIgaGVpZ2h0PSIzNjAiPjwvcmVjdD4KICAgICAgICAgICAgPHVzZSBpZD0iT3ZhbC0xIiBzdHJva2U9IiMwMDAwMDAiIG1hc2s9InVybCgjbWFzay0yKSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSIjRkZGRkZGIiB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNDU5LjAwMDAwMCwgMzcuMDAwMDAwKSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stNCkiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlLTEiIG1hc2s9InVybCgjbWFzay02KSIgeGxpbms6aHJlZj0iI3BhdGgtNSI+PC91c2U+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMDk5LjAwMDAwMCwgMzkuMDAwMDAwKSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjgiPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iU3Rhci0xIiBtYXNrPSJ1cmwoI21hc2stOCkiIGZpbGw9IiNGRkZGRkYiIHhsaW5rOmhyZWY9IiNwYXRoLTciPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlLTEiIG1hc2s9InVybCgjbWFzay0xMCkiIHhsaW5rOmhyZWY9IiNwYXRoLTkiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDx1c2UgaWQ9IlBhdGgtMSIgc3Ryb2tlPSIjMDAwMDAwIiBtYXNrPSJ1cmwoI21hc2stMTIpIiBzdHJva2Utd2lkdGg9IjgiIGZpbGw9IiMwMDAwMDAiIHhsaW5rOmhyZWY9IiNwYXRoLTExIj48L3VzZT4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIxMzM5IDEyMCAxMzc5IDEyMCAxMzc5IDEwMCAxNDE5IDEzOS40OTc3NjcgMTM3OSAxODAgMTM3OSAxNjAgMTMzOSAxNjAiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkZbQV0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjMwMC4xIiB5PSIzMTQiPkZbQV08L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJGW0JdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxNTEyLjYiIHk9IjMxNCI+RltCXTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstRltCXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iOTQ1LjYiIHk9IjMxNCI+QSA9Jmd0OyBGW0JdPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1NS4wMDAwMDAsIDM4LjAwMDAwMCkiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI4Ij4KICAgICAgICAgICAgICAgIDx1c2UgaWQ9Ik92YWwtMSIgbWFzaz0idXJsKCNtYXNrLTE0KSIgZmlsbD0iI0ZGRkZGRiIgeGxpbms6aHJlZj0iI3BhdGgtMTMiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlLTEiIG1hc2s9InVybCgjbWFzay0xNikiIHhsaW5rOmhyZWY9IiNwYXRoLTE1Ij48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8dGV4dCBpZD0iZmxhdE1hcCIgZm9udC1mYW1pbHk9IkZpcmFNb25vLUJvbGQsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI2NCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNGNkE2MjMiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjQ5Ni4yIiB5PSIxNTUiPmZsYXRNYXA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
      <figcaption>Figure 24: Type chart for flatMap</figcaption>
    </figure>
    <p>How do we relate <code>F</code> in the figure to <code>Check</code> in our code? <code>Check</code> has <em>three</em> type variables while <code>F</code> only has one.</p>
    <p>To unify the types we need to fix two of the type parameters. The idiomatic choices are the error type <code>E</code> and the input type <code>A</code>. This gives us the relationships shown in <a href="#loc-448">Figure 25</a>. In other words, the semantics of applying a <code>FlatMap</code> are:</p>
    <ul>
      <li>
        <p>given an input of type <code>A</code>, convert to <code>F[B]</code>;</p>
      </li>
      <li>
        <p>use the output of type <code>B</code> to choose a <code>Check[E, A, C]</code>;</p>
      </li>
      <li>
        <p>return to the <em>original</em> input of type <code>A</code> and apply it to the chosen check to generate the final result of type <code>F[C]</code>.</p>
      </li>
    </ul>
    <figure id="loc-448">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTYxNHB4IiBoZWlnaHQ9IjIyMXB4IiB2aWV3Qm94PSIwIDAgMTYxNCAyMjEiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5mbGF0bWFwPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIyNzkuMzg1NjYzIDEwMC4wMTM0NzEgMjQ1LjE1MTI1NyAxMTcuODk1OCAyNTEuNjg5NDQ3IDgwLjAyMDQxOTYgMjIzLjk5MzIzIDUzLjE5NjkyNjUgMjYyLjI2ODQ2IDQ3LjY3MDk4MzEgMjc5LjM4NTY2MyAxMy4yMTA4MjM5IDI5Ni41MDI4NjcgNDcuNjcwOTgzMSAzMzQuNzc4MDk3IDUzLjE5NjkyNjUgMzA3LjA4MTg4IDgwLjAyMDQxOTYgMzEzLjYyMDA3IDExNy44OTU4Ij48L3BvbHlnb24+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMiIgY3g9IjUzLjE2ODMyOSIgY3k9IjY2LjEwNDI4NTMiIHJ4PSI1My4xNjgzMjkiIHJ5PSI1Mi44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMyIgcG9pbnRzPSIyNjcuMDI2ODYzIDk4LjEzNjI0OTYgMjMyLjc5MjQ1NiAxMTYuMDE4NTc4IDIzOS4zMzA2NDYgNzguMTQzMTk4MyAyMTEuNjM0NDI5IDUxLjMxOTcwNTIgMjQ5LjkwOTY1OSA0NS43OTM3NjE3IDI2Ny4wMjY4NjMgMTEuMzMzNjAyNiAyODQuMTQ0MDY2IDQ1Ljc5Mzc2MTcgMzIyLjQxOTI5NiA1MS4zMTk3MDUyIDI5NC43MjMwNzkgNzguMTQzMTk4MyAzMDEuMjYxMjY5IDExNi4wMTg1NzgiPjwvcG9seWdvbj4KICAgICAgICA8ZWxsaXBzZSBpZD0icGF0aC00IiBjeD0iNTMuMjk2OTU1NyIgY3k9IjY3LjMyODg0MTEiIHJ4PSI1My4xNjgzMjkiIHJ5PSI1Mi44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtNSIgY3g9IjUzLjQyMjY4MSIgY3k9IjY2LjMyODg0MTEiIHJ4PSI1My4xNjgzMjkiIHJ5PSI1Mi44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ibW9uYWRpYyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE1NS4wMDAwMDAsIC0zNTguMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJmbGF0bWFwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTUuMDAwMDAwLCAzNTguMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtMTAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCAyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMjQ3LjgxMDA5NSwxMTQuMjUwNTQ1IEwyNTMuNjYwMjk4LDgwLjM2MDYzNTMgTDI1My44NDAwOTUsNzkuMzE5MDc4NyBMMjUzLjA4MDg0NCw3OC41ODM3NTIxIEwyMjguMzEwODgzLDU0LjU5NDMwNjYgTDI2Mi41NTQyNDUsNDkuNjUwNDU5NSBMMjYzLjU5MjgzMyw0OS41MDA1MTQ1IEwyNjQuMDU5NjU1LDQ4LjU2MDcxMzQgTDI3OS4zODU2NjMsMTcuNzA2NTY3OSBMMjk0LjcxMTY3Miw0OC41NjA3MTM0IEwyOTUuMTc4NDk0LDQ5LjUwMDUxNDUgTDI5Ni4yMTcwODIsNDkuNjUwNDU5NSBMMzMwLjQ2MDQ0NCw1NC41OTQzMDY2IEwzMDUuNjkwNDgzLDc4LjU4Mzc1MjEgTDMwNC45MzEyMzIsNzkuMzE5MDc4NyBMMzA1LjExMTAyOSw4MC4zNjA2MzUzIEwzMTAuOTYxMjMyLDExNC4yNTA1NDUgTDI4MC4zMTE2NDYsOTguMjQwNzQ1MyBMMjc5LjM4NTY2Myw5Ny43NTcwNTg3IEwyNzguNDU5NjgxLDk4LjI0MDc0NTMgTDI0Ny44MTAwOTUsMTE0LjI1MDU0NSBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMiI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNTMuMTY4MzI5IiBjeT0iNjYuMTA0Mjg1MyIgcng9IjUxLjE2ODMyOSIgcnk9IjUwLjg5MzQ2MTQiPjwvZWxsaXBzZT4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iMjE0LjI4NjI2NyIgeT0iMi4wMjgyNzE0MSIgd2lkdGg9IjEyOC45MjA4MjMiIGhlaWdodD0iMTI4LjIzMzY1NCIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjMDAwMDAwIiBwb2ludHM9IjEzMy40NTkzODEgNTQuMzUwMTgyOCAxNjAuMDQzNTQ2IDU0LjM1MDE4MjggMTYwLjA0MzU0NiA0MS4xMjY4MTc0IDE4Ni42Mjc3MSA2Ny4yNDE0ODc3IDE2MC4wNDM1NDYgOTQuMDIwMjc4OSAxNjAuMDQzNTQ2IDgwLjc5NjkxMzUgMTMzLjQ1OTM4MSA4MC43OTY5MTM1Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTg2LjAwMDAwMCwgMC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iU3Rhci0xIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTIzNS40NTEyOTQsMTEyLjM3MzMyMyBMMjQxLjMwMTQ5Nyw3OC40ODM0MTQgTDI0MS40ODEyOTQsNzcuNDQxODU3NCBMMjQwLjcyMjA0Myw3Ni43MDY1MzA4IEwyMTUuOTUyMDgyLDUyLjcxNzA4NTIgTDI1MC4xOTU0NDQsNDcuNzczMjM4MiBMMjUxLjIzNDAzMiw0Ny42MjMyOTMyIEwyNTEuNzAwODU1LDQ2LjY4MzQ5MjEgTDI2Ny4wMjY4NjMsMTUuODI5MzQ2NiBMMjgyLjM1Mjg3MSw0Ni42ODM0OTIxIEwyODIuODE5NjkzLDQ3LjYyMzI5MzIgTDI4My44NTgyODEsNDcuNzczMjM4MiBMMzE4LjEwMTY0Myw1Mi43MTcwODUyIEwyOTMuMzMxNjgyLDc2LjcwNjUzMDggTDI5Mi41NzI0MzEsNzcuNDQxODU3NCBMMjkyLjc1MjIyOCw3OC40ODM0MTQgTDI5OC42MDI0MzEsMTEyLjM3MzMyMyBMMjY3Ljk1Mjg0NSw5Ni4zNjM1MjQgTDI2Ny4wMjY4NjMsOTUuODc5ODM3MyBMMjY2LjEwMDg4LDk2LjM2MzUyNCBMMjM1LjQ1MTI5NCwxMTIuMzczMzIzIFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iIzAwMDAwMCIgcG9pbnRzPSIzNDcuNDM1MjAzIDUzLjI0ODQwNTcgMzc0LjAxOTM2OCA1My4yNDg0MDU3IDM3NC4wMTkzNjggNDAuMDI1MDQwNCA0MDAuNjAzNTMyIDY2LjEzOTcxMDcgMzc0LjAxOTM2OCA5Mi45MTg1MDE4IDM3NC4wMTkzNjggNzkuNjk1MTM2NSAzNDcuNDM1MjAzIDc5LjY5NTEzNjUiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSI0MjguODAwNjQ3IiB5PSIyLjQ3NzM4Mjg4IiB3aWR0aD0iMTI4LjkyMDgyMyIgaGVpZ2h0PSIxMjguMjMzNjU0IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtNCI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iNTMuMjk2OTU1NyIgY3k9IjY3LjMyODg0MTEiIHJ4PSI1MS4xNjgzMjkiIHJ5PSI1MC44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iMTMzLjU4ODAwOCA1NS41NzQ3Mzg1IDE2MC4xNzIxNzIgNTUuNTc0NzM4NSAxNjAuMTcyMTcyIDQyLjM1MTM3MzIgMTg2Ljc1NjMzNyA2OC40NjYwNDM1IDE2MC4xNzIxNzIgOTUuMjQ0ODM0NiAxNjAuMTcyMTcyIDgyLjAyMTQ2OTMgMTMzLjU4ODAwOCA4Mi4wMjE0NjkzIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24iIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjQ5My4wODI1OTcgMjMgNTM5LjE2NTE5NCA1Ni4yNjU2MTY3IDUyMS41NjMyMDggMTEwLjA5MDUxNSA0NjQuNjAxOTg2IDExMC4wOTA1MTUgNDQ3IDU2LjI2NTYxNjciPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDx0ZXh0IGlkPSJBLT0mZ3Q7LUZbQl0iIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI1OS40NjcwMjEzIiB5PSIyMTUiPkEgPSZndDsgRltCXTwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQi09Jmd0Oy0oQS09Jmd0Oy1GW0NdKSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjY2NC41NzA2OTYiIHk9IjIxNSI+QiA9Jmd0OyAoQSA9Jmd0OyBGW0NdKTwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0NdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTMyNy4xMTAzIiB5PSIyMTUiPkEgPSZndDsgRltDXTwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAtOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTI2OC4wMDAwMDAsIDEuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC01Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI1My40MjI2ODEiIGN5PSI2Ni4zMjg4NDExIiByeD0iNTEuMTY4MzI5IiByeT0iNTAuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjMDAwMDAwIiBwb2ludHM9IjEzMy43MTM3MzMgNTMuMDIzODUgMTYwLjI5Nzg5OCA1My4wMjM4NSAxNjAuMjk3ODk4IDM5LjgwMDQ4NDcgMTg2Ljg4MjA2MiA2NS45MTUxNTQ5IDE2MC4yOTc4OTggOTIuNjkzOTQ2MSAxNjAuMjk3ODk4IDc5LjQ3MDU4MDcgMTMzLjcxMzczMyA3OS40NzA1ODA3Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iMjE1LjA3OTE3NyIgeT0iMi4yNTI4MjcxNCIgd2lkdGg9IjEyOC45MjA4MjMiIGhlaWdodD0iMTI4LjIzMzY1NCIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUG9seWdvbiIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iMjgwLjA4MjU5NyAyMyAzMjYuMTY1MTk0IDU2LjI2NTYxNjcgMzA4LjU2MzIwOCAxMTAuMDkwNTE1IDI1MS42MDE5ODYgMTEwLjA5MDUxNSAyMzQgNTYuMjY1NjE2NyI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMSIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIxMTc4LjUwMDk3IDUzLjIwNzU5MjkgMTIwOS43MTk1NCA1My4yMDc1OTI5IDEyMDkuNzE5NTQgMzcuNjk4NzA3NiAxMjQwLjkzODEgNjguMzI3MDI0NiAxMjA5LjcxOTU0IDk5LjczNDI0ODggMTIwOS43MTk1NCA4NC4yMjUzNjM1IDExNzguNTAwOTcgODQuMjI1MzYzNSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHRleHQgaWQ9ImZsYXRNYXAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1Cb2xkLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDUiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjRjZBNjIzIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzc1Ljc4MTY3MyIgeT0iODIiPmZsYXRNYXA8L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
      <figcaption>Figure 25: Type chart for flatMap applied to Check</figcaption>
    </figure>
    <p>This is quite an odd method. We can implement it, but it is hard to find a use for it. Go ahead and implement <code>flatMap</code> for <code>Check</code>, and then we’ll see a more generally useful method.</p>
    <p>We can write a more useful combinator that chains together two <code>Checks</code>. The output of the first check is connected to the input of the second. This is analogous to function composition using <code>andThen</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> f: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">B</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><span style="color: #d73948">val</span> g: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">C</span> <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><span style="color: #d73948">val</span> h: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">C</span> <span style="color: #d73948">=</span> f andThen g</code></pre>
    <p>A <code>Check</code> is basically a function <code>A => Validated[E, B]</code> so we can define an analagous <code>andThen</code> method:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">andThen</span>[<span style="color: #4b69c6">C</span>](that: <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">B</span>, <span style="color: #4b69c6">C</span>]): <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">E</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">C</span>]<br>}</code></pre>
    <p>Implement <code>andThen</code> now!</p>
    <h4 id="loc-449">21.4.3. Recap</h4>
    <p>We now have two algebraic data types, <code>Predicate</code> and <code>Check</code>, and a host of combinators with their associated case class implementations. Look at the following solution for a complete definition of each ADT.</p>
    <p>We have a complete implementation of <code>Check</code> and <code>Predicate</code> that do most of what we originally set out to do. However, we are not finished yet. You have probably recognised structure in <code>Predicate</code> and <code>Check</code> that we can abstract over: <code>Predicate</code> has a monoid and <code>Check</code> has a monad. Furthermore, in implementing <code>Check</code> you might have felt the implementation doesn’t do much—all we do is call through to underlying methods on <code>Predicate</code> and <code>Validated</code>.</p>
    <p>There are a lot of ways this library could be cleaned up. However, let’s implement some examples to prove to ourselves that our library really does work, and then we’ll turn to improving it.</p>
    <p>Implement checks for some of the examples given in the introduction:</p>
    <ul>
      <li>
        <p>A username must contain at least four characters and consist entirely of alphanumeric characters</p>
      </li>
      <li>
        <p>An email address must contain an <code>@</code> sign. Split the string at the <code>@</code>. The string to the left must not be empty. The string to the right must be at least three characters long and contain a dot.</p>
      </li>
    </ul>
    <p>You might find the following predicates useful:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.{NonEmptyList, Validated}</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Errors</span> <span style="color: #d73948">= </span><span style="color: #4b69c6">NonEmptyList</span>[<span style="color: #4b69c6">String</span>]<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">error</span>(s: <span style="color: #4b69c6">String</span>): <span style="color: #4b69c6">NonEmptyList</span>[<span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">NonEmptyList</span>(s, <span style="color: #4b69c6">Nil</span>)<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">longerThan</span>(n: <span style="color: #d73948">Int</span>): <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">Errors</span>, <span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Predicate</span>.lift(<br>    error(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Must be longer than </span>$n<span style="color: #198810"> characters</span><span style="color: #198810">"</span>),<br>    str <span style="color: #d73948">=></span> str.size > n)<br><br><span style="color: #d73948">val</span> alphanumeric: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">Errors</span>, <span style="color: #4b69c6">String</span>] =<br>  <span style="color: #4b69c6">Predicate</span>.lift(<br>    error(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Must be all alphanumeric characters</span><span style="color: #198810">"</span>),<br>    str <span style="color: #d73948">=></span> str.forall(<span style="color: #d73948">_</span>.isLetterOrDigit))<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">contains</span>(char: <span style="color: #d73948">Char</span>): <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">Errors</span>, <span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Predicate</span>.lift(<br>    error(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Must contain the character </span>$char<span style="color: #198810">"</span>),<br>    str <span style="color: #d73948">=></span> str.contains(char))<br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">containsOnce</span>(char: <span style="color: #d73948">Char</span>): <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">Errors</span>, <span style="color: #4b69c6">String</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Predicate</span>.lift(<br>    error(<span style="color: #4b69c6">s</span><span style="color: #198810">"</span><span style="color: #198810">Must contain the character </span>$char<span style="color: #198810"> only once</span><span style="color: #198810">"</span>),<br>    str <span style="color: #d73948">=></span> str.filter(c <span style="color: #d73948">=></span> c <span style="color: #d73948">==</span> char).size <span style="color: #d73948">==</span> <span style="color: #b60157">1</span>)</code></pre>
    <h3 id="loc-450">21.5. Kleislis</h3>
    <p>We’ll finish off this case study by cleaning up the implementation of <code>Check</code>. A justifiable criticism of our approach is that we’ve written a lot of code to do very little. A <code>Predicate</code> is essentially a function <code>A => Validated[E, A]</code>, and a <code>Check</code> is basically a wrapper that lets us compose these functions.</p>
    <p>We can abstract <code>A => Validated[E, A]</code> to <code>A => F[B]</code>, which you’ll recognise as the type of function you pass to the <code>flatMap</code> method on a monad. Imagine we have the following sequence of operations:</p>
    <ul>
      <li>
        <p>We lift some value into a monad (by using <code>pure</code>, for example). This is a function with type <code>A => F[A]</code>.</p>
      </li>
      <li>
        <p>We then sequence some transformations on the monad using <code>flatMap</code>.</p>
      </li>
    </ul>
    <p>We can illustrate this as shown in <a href="#loc-451">Figure 26</a>. We can also write out this example using the monad API as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> aToB: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><span style="color: #d73948">val</span> bToC: <span style="color: #4b69c6">B</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">C</span>] <span style="color: #d73948">=</span> <span style="color: #d73948">???</span><br><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">example</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">C</span>](a: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">C</span>] <span style="color: #d73948">=</span><br>  aToB(a).flatMap(bToC)</code></pre>
    <figure id="loc-451">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQ3NnB4IiBoZWlnaHQ9IjIyMHB4IiB2aWV3Qm94PSIwIDAgMTQ3NiAyMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5rbGVpc2xpPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMSIgY3g9IjUzLjE2ODMyOSIgY3k9IjY3Ljg5MzQ2MTQiIHJ4PSI1My4xNjgzMjkiIHJ5PSI1Mi44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgPGVsbGlwc2UgaWQ9InBhdGgtMiIgY3g9IjI3OS4xNjgzMjkiIGN5PSI2Ny44OTM0NjE0IiByeD0iNTMuMTY4MzI5IiByeT0iNTIuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgIDxlbGxpcHNlIGlkPSJwYXRoLTMiIGN4PSI2MjcuMTY4MzI5IiBjeT0iNjUuODkzNDYxNCIgcng9IjUzLjE2ODMyOSIgcnk9IjUyLjg5MzQ2MTQiPjwvZWxsaXBzZT4KICAgICAgICA8cG9seWdvbiBpZD0icGF0aC00IiBwb2ludHM9Ijg1My4zOTI0MzMgOTkuODAyNjQ3IDgxOS4xNTgwMjcgMTE3LjY4NDk3NiA4MjUuNjk2MjE3IDc5LjgwOTU5NTcgNzk4IDUyLjk4NjEwMjYgODM2LjI3NTIzIDQ3LjQ2MDE1OTIgODUzLjM5MjQzMyAxMyA4NzAuNTA5NjM3IDQ3LjQ2MDE1OTIgOTA4Ljc4NDg2NyA1Mi45ODYxMDI2IDg4MS4wODg2NSA3OS44MDk1OTU3IDg4Ny42MjY4NCAxMTcuNjg0OTc2Ij48L3BvbHlnb24+CiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtNSIgcG9pbnRzPSIxMjAxLjM5MjQzIDk5LjgwMjY0NyAxMTY3LjE1ODAzIDExNy42ODQ5NzYgMTE3My42OTYyMiA3OS44MDk1OTU3IDExNDYgNTIuOTg2MTAyNiAxMTg0LjI3NTIzIDQ3LjQ2MDE1OTIgMTIwMS4zOTI0MyAxMyAxMjE4LjUwOTY0IDQ3LjQ2MDE1OTIgMTI1Ni43ODQ4NyA1Mi45ODYxMDI2IDEyMjkuMDg4NjUgNzkuODA5NTk1NyAxMjM1LjYyNjg0IDExNy42ODQ5NzYiPjwvcG9seWdvbj4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJrbGVpc2xpIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIzLjAwMDAwMCwgLTM4LjAwMDAwMCkiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjEiIGhlaWdodD0iMzAwIj48L3JlY3Q+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0xNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjIzLjAwMDAwMCwgMzguMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iT3ZhbC0xIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPGVsbGlwc2Ugc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIGN4PSI1My4xNjgzMjkiIGN5PSI2Ny44OTM0NjE0IiByeD0iNTEuMTY4MzI5IiByeT0iNTAuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPGcgaWQ9Ik92YWwtMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTIiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxlbGxpcHNlIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBjeD0iMjc5LjE2ODMyOSIgY3k9IjY3Ljg5MzQ2MTQiIHJ4PSI1MS4xNjgzMjkiIHJ5PSI1MC44OTM0NjE0Ij48L2VsbGlwc2U+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSIyMTQiIHk9IjQiIHdpZHRoPSIxMjguOTIwODIzIiBoZWlnaHQ9IjEyOC4yMzM2NTQiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xIiBmaWxsPSIjMDAwMDAwIiBwb2ludHM9IjEzMyA1Ni4yMjMzNjU0IDE1OS41ODQxNjUgNTYuMjIzMzY1NCAxNTkuNTg0MTY1IDQzIDE4Ni4xNjgzMjkgNjkuMTE0NjcwMyAxNTkuNTg0MTY1IDk1Ljg5MzQ2MTQgMTU5LjU4NDE2NSA4Mi42NzAwOTYxIDEzMyA4Mi42NzAwOTYxIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQS09Jmd0Oy1GW0FdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTkuNDY3MDIxMyIgeT0iMjE1Ij5BID0mZ3Q7IEZbQV08L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9ImZsYXRNYXAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1Cb2xkLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDUiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjRjZBNjIzIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMzY1Ljc4MTY3MyIgeT0iODIiPmZsYXRNYXA8L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9ImZsYXRNYXAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1Cb2xkLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNDUiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjRjZBNjIzIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iOTQwLjc4MTY3MyIgeT0iODIiPmZsYXRNYXA8L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPHRleHQgaWQ9IkEtPSZndDstRltCXSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI0MCIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYzOC4xMzc4MTQiIHk9IjIxMyI+QSA9Jmd0OyBGW0JdPC90c3Bhbj4KICAgICAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgICAgIDxnIGlkPSJPdmFsLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8ZWxsaXBzZSBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgY3g9IjYyNy4xNjgzMjkiIGN5PSI2NS44OTM0NjE0IiByeD0iNTEuMTY4MzI5IiByeT0iNTAuODkzNDYxNCI+PC9lbGxpcHNlPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iNzg4IiB5PSIyIiB3aWR0aD0iMTI4LjkyMDgyMyIgaGVpZ2h0PSIxMjguMjMzNjU0IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iMTM0NSIgeT0iMiIgd2lkdGg9IjEyOC45MjA4MjMiIGhlaWdodD0iMTI4LjIzMzY1NCIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iNzA3IDU0LjIyMzM2NTQgNzMzLjU4NDE2NSA1NC4yMjMzNjU0IDczMy41ODQxNjUgNDEgNzYwLjE2ODMyOSA2Ny4xMTQ2NzAzIDczMy41ODQxNjUgOTMuODkzNDYxNCA3MzMuNTg0MTY1IDgwLjY3MDA5NjEgNzA3IDgwLjY3MDA5NjEiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxnIGlkPSJTdGFyLTEiPgogICAgICAgICAgICAgICAgICAgIDx1c2UgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJldmVub2RkIiB4bGluazpocmVmPSIjcGF0aC00Ij48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgZD0iTTgyMS44MTY4NjUsMTE0LjAzOTcyMSBMODI3LjY2NzA2OCw4MC4xNDk4MTE0IEw4MjcuODQ2ODY1LDc5LjEwODI1NDggTDgyNy4wODc2MTQsNzguMzcyOTI4MiBMODAyLjMxNzY1Myw1NC4zODM0ODI3IEw4MzYuNTYxMDE1LDQ5LjQzOTYzNTYgTDgzNy41OTk2MDMsNDkuMjg5NjkwNiBMODM4LjA2NjQyNSw0OC4zNDk4ODk1IEw4NTMuMzkyNDMzLDE3LjQ5NTc0NCBMODY4LjcxODQ0MSw0OC4zNDk4ODk1IEw4NjkuMTg1MjY0LDQ5LjI4OTY5MDYgTDg3MC4yMjM4NTIsNDkuNDM5NjM1NiBMOTA0LjQ2NzIxNCw1NC4zODM0ODI3IEw4NzkuNjk3MjUzLDc4LjM3MjkyODIgTDg3OC45MzgwMDIsNzkuMTA4MjU0OCBMODc5LjExNzc5OSw4MC4xNDk4MTE0IEw4ODQuOTY4MDAyLDExNC4wMzk3MjEgTDg1NC4zMTg0MTYsOTguMDI5OTIxNCBMODUzLjM5MjQzMyw5Ny41NDYyMzQ3IEw4NTIuNDY2NDUxLDk4LjAyOTkyMTQgTDgyMS44MTY4NjUsMTE0LjAzOTcyMSBaIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iQi09Jmd0Oy1GW0NdIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjQwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTE5My40MDA2MiIgeT0iMjEzIj5CID0mZ3Q7IEZbQ108L3RzcGFuPgogICAgICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICAgICAgPGcgaWQ9IlN0YXItMSI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTUiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBkPSJNMTE2OS44MTY4NiwxMTQuMDM5NzIxIEwxMTc1LjY2NzA3LDgwLjE0OTgxMTQgTDExNzUuODQ2ODYsNzkuMTA4MjU0OCBMMTE3NS4wODc2MSw3OC4zNzI5MjgyIEwxMTUwLjMxNzY1LDU0LjM4MzQ4MjcgTDExODQuNTYxMDEsNDkuNDM5NjM1NiBMMTE4NS41OTk2LDQ5LjI4OTY5MDYgTDExODYuMDY2NDMsNDguMzQ5ODg5NSBMMTIwMS4zOTI0MywxNy40OTU3NDQgTDEyMTYuNzE4NDQsNDguMzQ5ODg5NSBMMTIxNy4xODUyNiw0OS4yODk2OTA2IEwxMjE4LjIyMzg1LDQ5LjQzOTYzNTYgTDEyNTIuNDY3MjEsNTQuMzgzNDgyNyBMMTIyNy42OTcyNSw3OC4zNzI5MjgyIEwxMjI2LjkzOCw3OS4xMDgyNTQ4IEwxMjI3LjExNzgsODAuMTQ5ODExNCBMMTIzMi45NjgsMTE0LjAzOTcyMSBMMTIwMi4zMTg0Miw5OC4wMjk5MjE0IEwxMjAxLjM5MjQzLDk3LjU0NjIzNDcgTDEyMDAuNDY2NDUsOTguMDI5OTIxNCBMMTE2OS44MTY4NiwxMTQuMDM5NzIxIFoiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEiIGZpbGw9IiMwMDAwMDAiIHBvaW50cz0iMTI4MyA1NC4yMjMzNjU0IDEzMDkuNTg0MTYgNTQuMjIzMzY1NCAxMzA5LjU4NDE2IDQxIDEzMzYuMTY4MzMgNjcuMTE0NjcwMyAxMzA5LjU4NDE2IDkzLjg5MzQ2MTQgMTMwOS41ODQxNiA4MC42NzAwOTYxIDEyODMgODAuNjcwMDk2MSI+PC9wb2x5Z29uPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBvbHlnb24iIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjE0MDkuMDgyNiAyMSAxNDU1LjE2NTE5IDU0LjI2NTYxNjcgMTQzNy41NjMyMSAxMDguMDkwNTE1IDEzODAuNjAxOTkgMTA4LjA5MDUxNSAxMzYzIDU0LjI2NTYxNjciPjwvcG9seWdvbj4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 26: Sequencing monadic transforms</figcaption>
    </figure>
    <p>Recall that <code>Check</code> is, in the abstract, allowing us to compose functions of type <code>A => F[B]</code>. We can write the above in terms of <code>andThen</code> as:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> aToC <span style="color: #d73948">=</span> aToB andThen bToC</code></pre>
    <p>The result is a (wrapped) function <code>aToC</code> of type <code>A => F[C]</code> that we can subsequently apply to a value of type <code>A</code>.</p>
    <p>We have achieved the same thing as the <code>example</code> method without having to reference an argument of type <code>A</code>. The <code>andThen</code> method on <code>Check</code> is analogous to function composition, but is composing function <code>A => F[B]</code> instead of <code>A => B</code>.</p>
    <p>The abstract concept of composing functions of type <code>A => F[B]</code> has a name: a <em>Kleisli</em>.</p>
    <p>Cats contains a data type [<code>cats.data.Kleisli</code>][cats.data.Kleisli] that wraps a function just as <code>Check</code> does. <code>Kleisli</code> has all the methods of <code>Check</code> plus some additional ones. If <code>Kleisli</code> seems familiar to you, then congratulations. You’ve seen through its disguise and recognised it as another concept from earlier in the book: <code>Kleisli</code> is just another name for <code>ReaderT</code>.</p>
    <p>Here is a simple example using <code>Kleisli</code> to transform an integer into a list of integers through three steps:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.data.Kleisli<br><span style="color: #d73948">import</span> cats.instances.list.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Monad</span></code></pre>
    <p>These steps each transform an input <code>Int</code> into an output of type <code>List[Int]</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> step1: <span style="color: #4b69c6">Kleisli</span>[<span style="color: #4b69c6">List</span>, <span style="color: #d73948">Int</span>, <span style="color: #d73948">Int</span>] =<br>  <span style="color: #4b69c6">Kleisli</span>(x <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>(x + <span style="color: #b60157">1</span>, x - <span style="color: #b60157">1</span>))<br><br><span style="color: #d73948">val</span> step2: <span style="color: #4b69c6">Kleisli</span>[<span style="color: #4b69c6">List</span>, <span style="color: #d73948">Int</span>, <span style="color: #d73948">Int</span>] =<br>  <span style="color: #4b69c6">Kleisli</span>(x <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>(x, -x))<br><br><span style="color: #d73948">val</span> step3: <span style="color: #4b69c6">Kleisli</span>[<span style="color: #4b69c6">List</span>, <span style="color: #d73948">Int</span>, <span style="color: #d73948">Int</span>] =<br>  <span style="color: #4b69c6">Kleisli</span>(x <span style="color: #d73948">=></span> <span style="color: #4b69c6">List</span>(x * <span style="color: #b60157">2</span>, x / <span style="color: #b60157">2</span>))</code></pre>
    <p>We can combine the steps into a single pipeline that combines the underlying <code>Lists</code> using <code>flatMap</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> pipeline <span style="color: #d73948">=</span> step1 andThen step2 andThen step3</code></pre>
    <p>The result is a function that consumes a single <code>Int</code> and returns eight outputs, each produced by a different combination of transformations from <code>step1</code>, <code>step2</code>, and <code>step3</code>:</p>
    <pre><code data-lang="scala">pipeline.run(<span style="color: #b60157">20</span>)<br><span style="color: #74747c">//</span><span style="color: #74747c"> res0: List[Int] = List(42, 10, -42, -10, 38, 9, -38, -9)</span></code></pre>
    <p>The only notable difference between <code>Kleisli</code> and <code>Check</code> in terms of API is that <code>Kleisli</code> renames our <code>apply</code> method to <code>run</code>.</p>
    <p>Let’s replace <code>Check</code> with <code>Kleisli</code> in our validation examples. To do so we need to make a few changes to <code>Predicate</code>. We must be able to convert a <code>Predicate</code> to a function, as <code>Kleisli</code> only works with functions. Somewhat more subtly, when we convert a <code>Predicate</code> to a function, it should have type <code>A => Either[E, A]</code> rather than <code>A => Validated[E, A]</code> because <code>Kleisli</code> relies on the wrapped function returning a monad.</p>
    <p>Add a method to <code>Predicate</code> called <code>run</code> that returns a function of the correct type. Leave the rest of the code in <code>Predicate</code> the same.</p>
    <p>Now rewrite our username and email validation example in terms of <code>Kleisli</code> and <code>Predicate</code>. Here are few tips in case you get stuck:</p>
    <p>First, remember that the <code>run</code> method on <code>Predicate</code> takes an implicit parameter. If you call <code>aPredicate.run(a)</code> it will try to pass the implicit parameter explicitly. If you want to create a function from a <code>Predicate</code> and immediately apply that function, use <code>aPredicate.run.apply(a)</code></p>
    <p>Second, type inference can be tricky in this exercise. We found that the following definitions helped us to write code with fewer type declarations.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">type</span> <span style="color: #4b69c6">Result</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Either</span>[<span style="color: #4b69c6">Errors</span>, <span style="color: #4b69c6">A</span>]<br><br><span style="color: #d73948">type</span> <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">= </span><span style="color: #4b69c6">Kleisli</span>[<span style="color: #4b69c6">Result</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>]<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Create a check from a function:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">check</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>](func: <span style="color: #4b69c6">A</span> <span style="color: #d73948">=></span> <span style="color: #4b69c6">Result</span>[<span style="color: #4b69c6">B</span>]): <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">B</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Kleisli</span>(func)<br><br><span style="color: #74747c">//</span><span style="color: #74747c"> Create a check from a Predicate:</span><br><span style="color: #d73948">def</span> <span style="color: #4b69c6">checkPred</span>[<span style="color: #4b69c6">A</span>](pred: <span style="color: #4b69c6">Predicate</span>[<span style="color: #4b69c6">Errors</span>, <span style="color: #4b69c6">A</span>]): <span style="color: #4b69c6">Check</span>[<span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">A</span>] <span style="color: #d73948">=</span><br>  <span style="color: #4b69c6">Kleisli</span>[<span style="color: #4b69c6">Result</span>, <span style="color: #4b69c6">A</span>, <span style="color: #4b69c6">A</span>](pred.run)</code></pre>
    <p>We have now written our code entirely in terms of <code>Kleisli</code> and <code>Predicate</code>, completely removing <code>Check</code>. This is a good first step to simplifying our library. There’s still plenty more to do, but we have a sophisticated building block from Cats to work with. We’ll leave further improvements up to the reader.</p>
    <h3 id="loc-452">21.6. Summary</h3>
    <p>This case study has been an exercise in removing rather than building abstractions. We started with a fairly complex <code>Check</code> type. Once we realised we were conflating two concepts, we separated out <code>Predicate</code> leaving us with something that could be implemented with <code>Kleisli</code>.</p>
    <p>&lt;!– <code>Predicate</code> is very much like a stripped down version of the matchers found in testing libraries like ScalaTest and Specs2. One next step would be to develop a more elaborate predicate library along these lines. There are a few other directions to consider.</p>
    <p>With the current representation of <code>Predicate</code> there is no way to implement logical negation. To implement negation we need to know the error message that a successful predicate would have returned if it had failed (so that the negation can return that message). One way to implement this is to have a predicate return a <code>Boolean</code> flag indicating success or failure and the associated message.</p>
    <p>We could also do better in how error messages are represented. At the moment there is no indication with an error message of the structure of the predicates that failed. For example, if we represent error messsages as a <code>List[String]</code> and we get back the message:</p>
    <pre><code data-lang="scala"><span style="color: #4b69c6">List</span>(<span style="color: #198810">"</span><span style="color: #198810">Must be longer than 4 characters</span><span style="color: #198810">"</span>,<br>     <span style="color: #198810">"</span><span style="color: #198810">Must not contain a number</span><span style="color: #198810">"</span>)</code></pre>
    <p>does this message indicate a failing conjunction (two <code>ands</code>) or a failing disjunction (two <code>ors</code>)? We can probably guess in this case but in general we don’t have sufficient information to work this out. We can solve this problem by wrapping all messages in a type as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">sealed</span> <span style="color: #d73948">trait</span><span style="color: #4b69c6"> Structure</span>[<span style="color: #4b69c6">E</span>]<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Or</span>[<span style="color: #4b69c6">E</span>](messages: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]])<br>  extends <span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> And</span>[<span style="color: #4b69c6">E</span>](messages: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]])<br>  extends <span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Not</span>[<span style="color: #4b69c6">E</span>](messages: <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]])<br>  extends <span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]<br><br><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> Pure</span>[<span style="color: #4b69c6">E</span>](message: <span style="color: #4b69c6">E</span>)<br>  extends <span style="color: #4b69c6">Structure</span>[<span style="color: #4b69c6">E</span>]</code></pre>
    <p>We can simplify this structure by converting all predicates into a normal form. For example, if we use disjunctive normal form the structure of the predicate will always be a disjunction (logical or) of conjunctions (logical and). By doing so we could errors as a <code>List[List[Either[E, E]]]</code>, with the outer list representing disjunction, the inner list representing conjunction, and the <code>Either</code> representing negation. –></p>
    <p>We made several design choices above that reasonable developers may disagree with. Should the method that converts a <code>Predicate</code> to a function really be called <code>run</code> instead of, say, <code>toFunction</code>? Should <code>Predicate</code> be a subtype of <code>Function</code> to begin with? Many functional programmers prefer to avoid subtyping because it plays poorly with implicit resolution and type inference, but there could be an argument to use it here. As always the best decisions depend on the context in which the library will be used.</p>
    <h2 id="loc-453">22. Case Study: CRDTs</h2>
    <p>In this case study we will explore <strong>Commutative Replicated Data Types (CRDTs)</strong>, a family of data structures that can be used to reconcile eventually consistent data.</p>
    <p>We’ll start by describing the utility and difficulty of eventually consistent systems, then show how we can use monoids and their extensions to solve the issues that arise. Finally, we will model the solutions in Scala.</p>
    <p>Our goal here is to focus on the implementation in Scala of a particular type of CRDT. We’re not aiming at a comprehensive survey of all CRDTs. CRDTs are a fast-moving field and we advise you to read the literature to learn about more.</p>
    <h3 id="loc-454">22.1. Eventual Consistency</h3>
    <p>As soon as a system scales beyond a single machine we have to make a fundamental choice about how we manage data.</p>
    <p>One approach is to build a system that is <em>consistent</em>, meaning that all machines have the same view of data. For example, if a user changes their password then all machines that store a copy of that password must accept the change before we consider the operation to have completed successfully.</p>
    <p>Consistent systems are easy to work with but they have their disadvantages. They tend to have high latency because a single change can result in many messages being sent between machines. They also tend to have relatively low uptime because outages can cut communications between machines creating a <em>network partition</em>. When there is a network partition, a consistent system may refuse further updates to prevent inconsistencies across machines.</p>
    <p>An alternative approach is an <em>eventually consistent</em> system. This means that at any particular point in time machines are allowed to have differing views of data. However, if all machines can communicate and there are no further updates they will eventually all have the same view of data.</p>
    <p>Eventually consistent systems require less communication between machines so latency can be lower. A partitioned machine can still accept updates and reconcile its changes when the network is fixed, so systems can also have better uptime.</p>
    <p>The big question is: how do we do this reconciliation between machines? CRDTs provide one approach to the problem.</p>
    <h3 id="loc-455">22.2. The GCounter</h3>
    <p>Let’s look at one particular CRDT implementation. Then we’ll attempt to generalise properties to see if we can find a general pattern.</p>
    <p>The data structure we will look at is called a <em>GCounter</em>. It is a distributed <em>increment-only</em> counter that can be used, for example, to count the number of visitors to a web site where requests are served by many web servers.</p>
    <h4 id="loc-456">22.2.1. Simple Counters</h4>
    <p>To see why a straightforward counter won’t work, imagine we have two servers storing a simple count of visitors. Let’s call the machines <code>A</code> and <code>B</code>. Each machine is storing an integer counter and the counters all start at zero as shown in <a href="#loc-457">Figure 27</a>.</p>
    <figure id="loc-457">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjM2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSAzNjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5zaW1wbGUtY291bnRlcjE8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ic2ltcGxlLWNvdW50ZXIxIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzYxIiBoZWlnaHQ9IjM2MCI+PC9yZWN0PgogICAgICAgICAgICA8dGV4dCBpZD0iTWFjaGluZS1CIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjQyIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI5ODEuMjgzMjAzIiB5PSI2NCI+TWFjaGluZSBCPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSI5ODEiIHk9IjEyMSIgd2lkdGg9IjE5NiIgaGVpZ2h0PSIxOTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJNYWNoaW5lLUEiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjU4My40MzE2NDEiIHk9IjY0Ij5NYWNoaW5lIEE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIwIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjgwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI2NTYiIHk9IjI0NiI+MDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iODAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEwNTUiIHk9IjI0NiI+MDwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iNTgyIiB5PSIxMjEiIHdpZHRoPSIxOTYiIGhlaWdodD0iMTk2IiByeD0iOCI+PC9yZWN0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 27: Simple counters: initial state</figcaption>
    </figure>
    <p>Now imagine we receive some web traffic. Our load balancer distributes five incoming requests to <code>A</code> and <code>B</code>, <code>A</code> serving three visitors and <code>B</code> two. The machines have inconsistent views of the system state that they need to <em>reconcile</em> to achieve consistency. One reconciliation strategy with simple counters is to exchange counts and add them as shown in <a href="#loc-458">Figure 28</a>.</p>
    <figure id="loc-458">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjY2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSA2NjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5zaW1wbGUtY291bnRlcjM8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ic2ltcGxlLWNvdW50ZXIzIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzYxIiBoZWlnaHQ9IjY2MCI+PC9yZWN0PgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSI5ODEiIHk9IjQyMiIgd2lkdGg9IjE5NiIgaGVpZ2h0PSIxOTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgIDx0ZXh0IGlkPSI1IiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjgwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI2NTYiIHk9IjU0OCI+NTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IjUiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iODAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEwNTUiIHk9IjU0NyI+NTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iNTgyIiB5PSI0MjIiIHdpZHRoPSIxOTYiIGhlaWdodD0iMTk2IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODg1LjQwMTA4NSwgMzc0LjQwMTA4NSkgcm90YXRlKC0zMTUuMDAwMDAwKSB0cmFuc2xhdGUoLTg4NS40MDEwODUsIC0zNzQuNDAxMDg1KSAiIHBvaW50cz0iNzc3Ljc1NTY1NSAzNTQuNjkxOTQ2IDk1My4wNDY1MTUgMzU0LjQwMTA4NSA5NTMuMDQ2NTE1IDMzNC40MDEwODUgOTkzLjA0NjUxNSAzNzMuODk4ODUyIDk1My4wNDY1MTUgNDE0LjQwMTA4NSA5NTMuMDQ2NTE1IDM5NC40MDEwODUgNzc3Ljc1NTY1NSAzOTQuNjkxOTQ2Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4NzguNDAxMDg1LCAzNzQuNDAxMDg1KSByb3RhdGUoLTIyNS4wMDAwMDApIHRyYW5zbGF0ZSgtODc4LjQwMTA4NSwgLTM3NC40MDEwODUpICIgcG9pbnRzPSI3NzAuNzU1NjU1IDM1NC42OTE5NDYgOTQ2LjA0NjUxNSAzNTQuNDAxMDg1IDk0Ni4wNDY1MTUgMzM0LjQwMTA4NSA5ODYuMDQ2NTE1IDM3My44OTg4NTIgOTQ2LjA0NjUxNSA0MTQuNDAxMDg1IDk0Ni4wNDY1MTUgMzk0LjQwMTA4NSA3NzAuNzU1NjU1IDM5NC42OTE5NDYiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNCIgeD0iOTgxIiB5PSIxMjIiIHdpZHRoPSIxOTYiIGhlaWdodD0iMTk2IiByeD0iOCI+PC9yZWN0PgogICAgICAgICAgICA8dGV4dCBpZD0iMyIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI4MCIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNjU2IiB5PSIyNDciPjM8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIyIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjgwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDU1IiB5PSIyNDciPjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iMTIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iOTgxLjI4MzIwMyIgeT0iNzAiPk1hY2hpbmUgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTgzLjQzMTY0MSIgeT0iNzAiPk1hY2hpbmUgQTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkFkZC1jb3VudGVycyIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNzc1LjQzMzU5NCIgeT0iMzg0Ij5BZGQgY291bnRlcnM8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzI3LjY0NTQzMCwgMjIwLjAwMDAwMCkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTMyNy42NDU0MzAsIC0yMjAuMDAwMDAwKSAiIHBvaW50cz0iMTIyMCAyMDAuMjkwODYxIDEzOTUuMjkwODYgMjAwIDEzOTUuMjkwODYgMTgwIDE0MzUuMjkwODYgMjE5LjQ5Nzc2NyAxMzk1LjI5MDg2IDI2MCAxMzk1LjI5MDg2IDI0MCAxMjIwIDI0MC4yOTA4NjEiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkluY29taW5nLXJlcXVlc3RzIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMjc0LjQyMzgzIiB5PSIxODEiPkluY29taW5nIHJlcXVlc3RzPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIzMjYgMjAwLjI5MDg2MSA1MDEuMjkwODYxIDIwMCA1MDEuMjkwODYxIDE4MCA1NDEuMjkwODYxIDIxOS40OTc3NjcgNTAxLjI5MDg2MSAyNjAgNTAxLjI5MDg2MSAyNDAgMzI2IDI0MC4yOTA4NjEiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkluY29taW5nLXJlcXVlc3RzIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxOTAuNDIzODI4IiB5PSIxODEiPkluY29taW5nIHJlcXVlc3RzPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 28: Simple counters: first round of requests and reconciliation</figcaption>
    </figure>
    <p>So far so good, but things will start to fall apart shortly. Suppose <code>A</code> serves a single visitor, which means we’ve seen six visitors in total. The machines attempt to reconcile state again using addition leading to the answer shown in <a href="#loc-459">Figure 29</a>.</p>
    <figure id="loc-459">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjY2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSA2NjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5zaW1wbGUtY291bnRlcjU8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ic2ltcGxlLWNvdW50ZXI1Ij4KICAgICAgICAgICAgPHJlY3QgaWQ9IkJhY2tncm91bmQiIGZpbGw9IiNGRkZGRkYiIHg9IjAiIHk9IjAiIHdpZHRoPSIxNzYxIiBoZWlnaHQ9IjY2MCI+PC9yZWN0PgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSI5ODEiIHk9IjQyMiIgd2lkdGg9IjE5NiIgaGVpZ2h0PSIxOTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgIDx0ZXh0IGlkPSIxMSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI4MCIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNjMyIiB5PSI1NDgiPjExPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iMTEiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iODAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEwMzEiIHk9IjU0NyI+MTE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iNDIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDg4NS40MDEwODUsIDM3NC40MDEwODUpIHJvdGF0ZSgtMzE1LjAwMDAwMCkgdHJhbnNsYXRlKC04ODUuNDAxMDg1LCAtMzc0LjQwMTA4NSkgIiBwb2ludHM9Ijc3Ny43NTU2NTUgMzU0LjY5MTk0NiA5NTMuMDQ2NTE1IDM1NC40MDEwODUgOTUzLjA0NjUxNSAzMzQuNDAxMDg1IDk5My4wNDY1MTUgMzczLjg5ODg1MiA5NTMuMDQ2NTE1IDQxNC40MDEwODUgOTUzLjA0NjUxNSAzOTQuNDAxMDg1IDc3Ny43NTU2NTUgMzk0LjY5MTk0NiI+PC9wb2x5Z29uPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODc4LjQwMTA4NSwgMzc0LjQwMTA4NSkgcm90YXRlKC0yMjUuMDAwMDAwKSB0cmFuc2xhdGUoLTg3OC40MDEwODUsIC0zNzQuNDAxMDg1KSAiIHBvaW50cz0iNzcwLjc1NTY1NSAzNTQuNjkxOTQ2IDk0Ni4wNDY1MTUgMzU0LjQwMTA4NSA5NDYuMDQ2NTE1IDMzNC40MDEwODUgOTg2LjA0NjUxNSAzNzMuODk4ODUyIDk0Ni4wNDY1MTUgNDE0LjQwMTA4NSA5NDYuMDQ2NTE1IDM5NC40MDEwODUgNzcwLjc1NTY1NSAzOTQuNjkxOTQ2Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MSIgeT0iMTIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9IjYiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iODAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjY1NiIgeT0iMjQ3Ij42PC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iNSIgZm9udC1mYW1pbHk9IkZpcmFNb25vLVJlZ3VsYXIsIEZpcmEgTW9ubyIgZm9udC1zaXplPSI4MCIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTA1NSIgeT0iMjQ3Ij41PC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0IiB4PSI1ODIiIHk9IjEyMiIgd2lkdGg9IjE5NiIgaGVpZ2h0PSIxOTYiIHJ4PSI4Ij48L3JlY3Q+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJNYWNoaW5lLUIiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijk4MS4yODMyMDMiIHk9IjcwIj5NYWNoaW5lIEI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJNYWNoaW5lLUEiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjU4My40MzE2NDEiIHk9IjcwIj5NYWNoaW5lIEE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBZGQtY291bnRlcnMiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMzYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijc3NS40MzM1OTQiIHk9IjM4MiI+QWRkIGNvdW50ZXJzPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8dGV4dCBpZD0iSW5jb3JyZWN0LXJlc3VsdCEiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMzYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEzMTguOTU5OTYiIHk9IjUyOSI+SW5jb3JyZWN0IHJlc3VsdCE8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTI3Mi42Nzk0NTUsIDUxOS42Nzk0NTUpIHJvdGF0ZSgtMzE1LjAwMDAwMCkgdHJhbnNsYXRlKC0xMjcyLjY3OTQ1NSwgLTUxOS42Nzk0NTUpIHRyYW5zbGF0ZSgxMjM1LjY3OTQ1NSwgNDgyLjE3OTQ1NSkiIGZpbGw9IiNGRjAwMDAiPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZSIgeD0iMCIgeT0iMjYuNTQ3NzI3MiIgd2lkdGg9IjczLjc0MzY4NjciIGhlaWdodD0iMjAuNjQ4MjMyMyI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzYuODcxODQzLCAzNy4yNDA1NjIpIHJvdGF0ZSgtOTAuMDAwMDAwKSB0cmFuc2xhdGUoLTM2Ljg3MTg0MywgLTM3LjI0MDU2MikgIiB4PSIwIiB5PSIyOC4wMjI2MDA5IiB3aWR0aD0iNzMuNzQzNjg2NyIgaGVpZ2h0PSIxOC40MzU5MjE3Ij48L3JlY3Q+CiAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHBvaW50cz0iMzI2IDIwMS4yOTA4NjEgNTAxLjI5MDg2MSAyMDEgNTAxLjI5MDg2MSAxODEgNTQxLjI5MDg2MSAyMjAuNDk3NzY3IDUwMS4yOTA4NjEgMjYxIDUwMS4yOTA4NjEgMjQxIDMyNiAyNDEuMjkwODYxIj48L3BvbHlnb24+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJJbmNvbWluZy1yZXF1ZXN0IiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyMTEuNDIzODI4IiB5PSIxODIiPkluY29taW5nIHJlcXVlc3Q8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
      <figcaption>Figure 29: Simple counters: second round of requests and (incorrect) reconciliation</figcaption>
    </figure>
    <p>This is clearly wrong! The problem is that simple counters don’t give us enough information about the history of interactions between the machines. Fortunately we don’t need to store the <em>complete</em> history to get the correct answer—just a summary of it. Let’s look at how the GCounter solves this problem.</p>
    <h4 id="loc-460">22.2.2. GCounters</h4>
    <p>The first clever idea in the GCounter is to have each machine storing a <em>separate</em> counter for every machine it knows about (including itself). In the previous example we had two machines, <code>A</code> and <code>B</code>. In this situation both machines would store a counter for <code>A</code> and a counter for <code>B</code> as shown in <a href="#loc-461">Figure 30</a>.</p>
    <figure id="loc-461">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjM2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSAzNjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5nLWNvdW50ZXIxPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImctY291bnRlcjEiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjEiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJNYWNoaW5lLUIiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iNDIiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9Ijk4MS4yODMyMDMiIHk9IjY0Ij5NYWNoaW5lIEI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MSIgeT0iMTIxIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTgzLjQzMTY0MSIgeT0iNjQiPk1hY2hpbmUgQTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9IkE6MC1COjAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iMjA1Ij5BOjA8L3RzcGFuPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iMjc3Ij5COjA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBOjAtQjowIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjYwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDI1IiB5PSIyMDYiPkE6MDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAyNSIgeT0iMjc4Ij5COjA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iMTIxIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==">
      <figcaption>Figure 30: GCounter: initial state</figcaption>
    </figure>
    <p>The rule with GCounters is that a given machine is only allowed to increment its own counter. If <code>A</code> serves three visitors and <code>B</code> serves two visitors the counters look as shown in <a href="#loc-462">Figure 31</a>.</p>
    <figure id="loc-462">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjM2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSAzNjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5nLWNvdW50ZXIyPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImctY291bnRlcjIiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjEiIGhlaWdodD0iMzYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MCIgeT0iMTIzIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9IkE6My1COjAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNSIgeT0iMjA1Ij5BOjM8L3RzcGFuPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNSIgeT0iMjc3Ij5COjA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBOjAtQjoyIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjYwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDI0IiB5PSIyMDUiPkE6MDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAyNCIgeT0iMjc3Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MSIgeT0iMTIzIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iOTgwLjI4MzIwMyIgeT0iNzEiPk1hY2hpbmUgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTgyLjQzMTY0MSIgeT0iNzEiPk1hY2hpbmUgQTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMjcuNjQ1NDMwLCAyMjEuMDAwMDAwKSBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0xMzI3LjY0NTQzMCwgLTIyMS4wMDAwMDApICIgcG9pbnRzPSIxMjIwIDIwMS4yOTA4NjEgMTM5NS4yOTA4NiAyMDEgMTM5NS4yOTA4NiAxODEgMTQzNS4yOTA4NiAyMjAuNDk3NzY3IDEzOTUuMjkwODYgMjYxIDEzOTUuMjkwODYgMjQxIDEyMjAgMjQxLjI5MDg2MSI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iSW5jb21pbmctcmVxdWVzdHMiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMzYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEyNzQuNDIzODMiIHk9IjE4MiI+SW5jb21pbmcgcmVxdWVzdHM8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjMyNiAyMDEuMjkwODYxIDUwMS4yOTA4NjEgMjAxIDUwMS4yOTA4NjEgMTgxIDU0MS4yOTA4NjEgMjIwLjQ5Nzc2NyA1MDEuMjkwODYxIDI2MSA1MDEuMjkwODYxIDI0MSAzMjYgMjQxLjI5MDg2MSI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iSW5jb21pbmctcmVxdWVzdHMiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMzYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjE5MC40MjM4MjgiIHk9IjE4MiI+SW5jb21pbmcgcmVxdWVzdHM8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
      <figcaption>Figure 31: GCounter: first round of web requests</figcaption>
    </figure>
    <p>When two machines reconcile their counters the rule is to take the largest value stored for each machine. In our example, the result of the first merge will be as shown in <a href="#loc-463">Figure 32</a>.</p>
    <figure id="loc-463">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjY2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSA2NjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5nLWNvdW50ZXIzPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImctY291bnRlcjMiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjEiIGhlaWdodD0iNjYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MSIgeT0iNDIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9IkE6My1COjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iNTA0Ij5BOjM8L3RzcGFuPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iNTc2Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBOjMtQjoyIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjYwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDI1IiB5PSI1MDMiPkE6MzwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAyNSIgeT0iNTc1Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iNDIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDg4NS40MDEwODUsIDM3NC40MDEwODUpIHJvdGF0ZSgtMzE1LjAwMDAwMCkgdHJhbnNsYXRlKC04ODUuNDAxMDg1LCAtMzc0LjQwMTA4NSkgIiBwb2ludHM9Ijc3Ny43NTU2NTUgMzU0LjY5MTk0NiA5NTMuMDQ2NTE1IDM1NC40MDEwODUgOTUzLjA0NjUxNSAzMzQuNDAxMDg1IDk5My4wNDY1MTUgMzczLjg5ODg1MiA5NTMuMDQ2NTE1IDQxNC40MDEwODUgOTUzLjA0NjUxNSAzOTQuNDAxMDg1IDc3Ny43NTU2NTUgMzk0LjY5MTk0NiI+PC9wb2x5Z29uPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODc4LjQwMTA4NSwgMzc0LjQwMTA4NSkgcm90YXRlKC0yMjUuMDAwMDAwKSB0cmFuc2xhdGUoLTg3OC40MDEwODUsIC0zNzQuNDAxMDg1KSAiIHBvaW50cz0iNzcwLjc1NTY1NSAzNTQuNjkxOTQ2IDk0Ni4wNDY1MTUgMzU0LjQwMTA4NSA5NDYuMDQ2NTE1IDMzNC40MDEwODUgOTg2LjA0NjUxNSAzNzMuODk4ODUyIDk0Ni4wNDY1MTUgNDE0LjQwMTA4NSA5NDYuMDQ2NTE1IDM5NC40MDEwODUgNzcwLjc1NTY1NSAzOTQuNjkxOTQ2Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MSIgeT0iMTIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9IkE6My1COjAiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iMjAzIj5BOjM8L3RzcGFuPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iMjc1Ij5COjA8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBOjAtQjoyIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjYwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDI1IiB5PSIyMDMiPkE6MDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAyNSIgeT0iMjc1Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iMTIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iOTgxLjI4MzIwMyIgeT0iNzAiPk1hY2hpbmUgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTgzLjQzMTY0MSIgeT0iNzAiPk1hY2hpbmUgQTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1lcmdlLC10YWtlLW1heCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNzQ3LjQ0OTIxOSIgeT0iMzg0Ij5NZXJnZSwgdGFrZSBtYXg8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzI4LjY0NTQzMCwgMjIwLjAwMDAwMCkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTMyOC42NDU0MzAsIC0yMjAuMDAwMDAwKSAiIHBvaW50cz0iMTIyMSAyMDAuMjkwODYxIDEzOTYuMjkwODYgMjAwIDEzOTYuMjkwODYgMTgwIDE0MzYuMjkwODYgMjE5LjQ5Nzc2NyAxMzk2LjI5MDg2IDI2MCAxMzk2LjI5MDg2IDI0MCAxMjIxIDI0MC4yOTA4NjEiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkluY29taW5nLXJlcXVlc3RzIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMjc1LjQyMzgzIiB5PSIxODEiPkluY29taW5nIHJlcXVlc3RzPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgcG9pbnRzPSIzMjcgMjAwLjI5MDg2MSA1MDIuMjkwODYxIDIwMCA1MDIuMjkwODYxIDE4MCA1NDIuMjkwODYxIDIxOS40OTc3NjcgNTAyLjI5MDg2MSAyNjAgNTAyLjI5MDg2MSAyNDAgMzI3IDI0MC4yOTA4NjEiPjwvcG9seWdvbj4KICAgICAgICAgICAgPHRleHQgaWQ9IkluY29taW5nLXJlcXVlc3RzIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxOTEuNDIzODI4IiB5PSIxODEiPkluY29taW5nIHJlcXVlc3RzPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 32: GCounter: first reconciliation</figcaption>
    </figure>
    <p>Subsequent incoming web requests are handled using the increment-own-counter rule and subsequent merges are handled using the take-maximum-value rule, producing the same correct values for each machine as shown in <a href="#loc-464">Figure 33</a>.</p>
    <figure id="loc-464">
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTc2MXB4IiBoZWlnaHQ9IjY2MHB4IiB2aWV3Qm94PSIwIDAgMTc2MSA2NjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDQzLjIgKDM5MDY5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5nLWNvdW50ZXI1PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImctY291bnRlcjUiPgogICAgICAgICAgICA8cmVjdCBpZD0iQmFja2dyb3VuZCIgZmlsbD0iI0ZGRkZGRiIgeD0iMCIgeT0iMCIgd2lkdGg9IjE3NjEiIGhlaWdodD0iNjYwIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MSIgeT0iNDIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9IkE6NC1COjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iNTA3Ij5BOjQ8L3RzcGFuPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iNTc5Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBOjQtQjoyIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjYwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDI1IiB5PSI1MDYiPkE6NDwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAyNSIgeT0iNTc4Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iNDIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlBhdGgtMS1Db3B5LTIiIGZpbGw9IiNGNkE2MjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDg4NS40MDEwODUsIDM3NC40MDEwODUpIHJvdGF0ZSgtMzE1LjAwMDAwMCkgdHJhbnNsYXRlKC04ODUuNDAxMDg1LCAtMzc0LjQwMTA4NSkgIiBwb2ludHM9Ijc3Ny43NTU2NTUgMzU0LjY5MTk0NiA5NTMuMDQ2NTE1IDM1NC40MDEwODUgOTUzLjA0NjUxNSAzMzQuNDAxMDg1IDk5My4wNDY1MTUgMzczLjg5ODg1MiA5NTMuMDQ2NTE1IDQxNC40MDEwODUgOTUzLjA0NjUxNSAzOTQuNDAxMDg1IDc3Ny43NTU2NTUgMzk0LjY5MTk0NiI+PC9wb2x5Z29uPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0xLUNvcHktMiIgZmlsbD0iI0Y2QTYyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODc4LjQwMTA4NSwgMzc0LjQwMTA4NSkgcm90YXRlKC0yMjUuMDAwMDAwKSB0cmFuc2xhdGUoLTg3OC40MDEwODUsIC0zNzQuNDAxMDg1KSAiIHBvaW50cz0iNzcwLjc1NTY1NSAzNTQuNjkxOTQ2IDk0Ni4wNDY1MTUgMzU0LjQwMTA4NSA5NDYuMDQ2NTE1IDMzNC40MDEwODUgOTg2LjA0NjUxNSAzNzMuODk4ODUyIDk0Ni4wNDY1MTUgNDE0LjQwMTA4NSA5NDYuMDQ2NTE1IDM5NC40MDEwODUgNzcwLjc1NTY1NSAzOTQuNjkxOTQ2Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9Ijk4MSIgeT0iMTIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9IkE6NC1COjIiIGZvbnQtZmFtaWx5PSJGaXJhTW9uby1SZWd1bGFyLCBGaXJhIE1vbm8iIGZvbnQtc2l6ZT0iNjAiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iMjA2Ij5BOjQ8L3RzcGFuPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjYyNiIgeT0iMjc4Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJBOjMtQjoyIiBmb250LWZhbWlseT0iRmlyYU1vbm8tUmVndWxhciwgRmlyYSBNb25vIiBmb250LXNpemU9IjYwIiBmb250LXdlaWdodD0ibm9ybWFsIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIxMDI1IiB5PSIyMDYiPkE6MzwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMTAyNSIgeT0iMjc4Ij5COjI8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQiIHg9IjU4MiIgeT0iMTIyIiB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgcng9IjgiPjwvcmVjdD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iOTgxLjI4MzIwMyIgeT0iNzAiPk1hY2hpbmUgQjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1hY2hpbmUtQSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSI0MiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNTgzLjQzMTY0MSIgeT0iNzAiPk1hY2hpbmUgQTwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHRleHQgaWQ9Ik1lcmdlLC10YWtlLW1heCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iNzQ3LjQ0OTIxOSIgeT0iMzgyIj5NZXJnZSwgdGFrZSBtYXg8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJDb3JyZWN0LXJlc3VsdCEiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMzYiIGZvbnQtd2VpZ2h0PSJub3JtYWwiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICAgICAgPHRzcGFuIHg9IjEzMjkuOTcyNjYiIHk9IjUyOSI+Q29ycmVjdCByZXN1bHQhPC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyNzQuNDQ3MjIyLCA1MTIuOTYxOTQxKSByb3RhdGUoLTMxNS4wMDAwMDApIHRyYW5zbGF0ZSgtMTI3NC40NDcyMjIsIC01MTIuOTYxOTQxKSB0cmFuc2xhdGUoMTI1NS45NDcyMjIsIDQ3NS40NjE5NDEpIiBmaWxsPSIjNDE3NTA1Ij4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUiIHg9Ii0yLjI3MzczNjc1ZS0xMyIgeT0iNTMuNzYwOTMwNyIgd2lkdGg9IjM2LjExNjI2OTciIGhlaWdodD0iMjAuNjQ4MjMyMyI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjcuNTI4Njk4LCAzNy41ODM3MDgpIHJvdGF0ZSgtOTAuMDAwMDAwKSB0cmFuc2xhdGUoLTI3LjUyODY5OCwgLTM3LjU4MzcwOCkgIiB4PSItOS4zNDMxNDU3NSIgeT0iMjguMzY1NzQ2NyIgd2lkdGg9IjczLjc0MzY4NjciIGhlaWdodD0iMTguNDM1OTIxNyI+PC9yZWN0PgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTEtQ29weS0yIiBmaWxsPSIjRjZBNjIzIiBwb2ludHM9IjMyNiAyMDAuMjkwODYxIDUwMS4yOTA4NjEgMjAwIDUwMS4yOTA4NjEgMTgwIDU0MS4yOTA4NjEgMjE5LjQ5Nzc2NyA1MDEuMjkwODYxIDI2MCA1MDEuMjkwODYxIDI0MCAzMjYgMjQwLjI5MDg2MSI+PC9wb2x5Z29uPgogICAgICAgICAgICA8dGV4dCBpZD0iSW5jb21pbmctcmVxdWVzdCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIzNiIgZm9udC13ZWlnaHQ9Im5vcm1hbCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjExLjQyMzgyOCIgeT0iMTgxIj5JbmNvbWluZyByZXF1ZXN0PC90c3Bhbj4KICAgICAgICAgICAgPC90ZXh0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+">
      <figcaption>Figure 33: GCounter: second reconciliation</figcaption>
    </figure>
    <p>GCounters allow each machine to keep an accurate account of the state of the whole system without storing the complete history of interactions. If a machine wants to calculate the total traffic for the whole web site, it sums up all the per-machine counters. The result is accurate or near-accurate depending on how recently we performed a reconciliation. Eventually, regardless of network outages, the system will always converge on a consistent state.</p>
    <h4 id="loc-465">22.2.3. Exercise: GCounter Implementation</h4>
    <p>We can implement a GCounter with the following interface, where we represent machine IDs as <code>Strings</code>.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">final</span> <span style="color: #d73948">case </span><span style="color: #d73948">class</span><span style="color: #4b69c6"> GCounter</span>(counters: <span style="color: #4b69c6">Map</span>[<span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">increment</span>(machine: <span style="color: #4b69c6">String</span>, amount: <span style="color: #d73948">Int</span>) <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">merge</span>(that: <span style="color: #4b69c6">GCounter</span>): <span style="color: #4b69c6">GCounter</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">total</span>: <span style="color: #d73948">Int</span> <span style="color: #d73948">=</span><br>    <span style="color: #d73948">???</span><br>}</code></pre>
    <p>Finish the implementation!</p>
    <h3 id="loc-466">22.3. Generalisation</h3>
    <p>We’ve now created a distributed, eventually consistent, increment-only counter. This is a useful achievement but we don’t want to stop here. In this section we will attempt to abstract the operations in the GCounter so it will work with more data types than just natural numbers.</p>
    <p>The GCounter uses the following operations on natural numbers:</p>
    <ul>
      <li>addition (in <code>increment</code> and <code>total</code>);</li>
      <li>maximum (in <code>merge</code>);</li>
      <li>and the identity element 0 (in <code>increment</code> and <code>merge</code>).</li>
    </ul>
    <p>You can probably guess that there’s a monoid in here somewhere, but let’s look in more detail at the properties we’re relying on.</p>
    <p>As a refresher, in <a href="#loc-163">Chapter 8</a> we saw that monoids must satisfy two laws. The binary operation <code>+</code> must be associative:</p>
    <p><code>(a + b) + c == a + (b + c)</code></p>
    <p>and the empty element must be an identity:</p>
    <p><code>0 + a == a + 0 == a</code></p>
    <p>We need an identity in <code>increment</code> to initialise the counter. We also rely on associativity to ensure the specific sequence of <code>merges</code> gives the correct value.</p>
    <p>In <code>total</code> we implicitly rely on associativity and commutativity to ensure we get the correct value no matter what arbitrary order we choose to sum the per-machine counters. We also implicitly assume an identity, which allows us to skip machines for which we do not store a counter.</p>
    <p>The properties of <code>merge</code> are a bit more interesting. We rely on commutativity to ensure that machine <code>A</code> merging with machine <code>B</code> yields the same result as machine <code>B</code> merging with machine <code>A</code>. We need associativity to ensure we obtain the correct result when three or more machines are merging data. We need an identity element to initialise empty counters. Finally, we need an additional property, called <em>idempotency</em>, to ensure that if two machines hold the same data in a per-machine counter, merging data will not lead to an incorrect result. Idempotent operations are ones that return the same result again and again if they are executed multiple times. Formally, a binary operation <code>max</code> is idempotent if the following relationship holds:</p>
    <pre><code>a max a = a</code></pre>
    <p>Written more compactly, we have:</p>
    <p>——————————————————————– Method Identity Commutative Associative Idempotent ————– ———– ————- ————- ————- <code>increment</code> Y N Y N</p>
    <p><code>merge</code> Y Y Y Y</p>
    <p><code>total</code> Y Y Y N ——————————————————————–</p>
    <p>From this we can see that</p>
    <ul>
      <li><code>increment</code> requires a monoid;</li>
      <li><code>total</code> requires a commutative monoid; and</li>
      <li><code>merge</code> required an idempotent commutative monoid, also called a <em>bounded semilattice</em>.</li>
    </ul>
    <p>Since <code>increment</code> and <code>get</code> both use the same binary operation (addition) it’s usual to require the same commutative monoid for both.</p>
    <p>This investigation demonstrates the powers of thinking about properties or laws of abstractions. Now we have identified these properties we can substitute the natural numbers used in our GCounter with any data type with operations satisfying these properties. A simple example is a set, with the binary operation being union and the identity element the empty set. With this simple substitution of <code>Int</code> for <code>Set[A]</code> we can create a GSet type.</p>
    <h4 id="loc-467">22.3.1. Implementation</h4>
    <p>Let’s implement this generalisation in code. Remember <code>increment</code> and <code>total</code> require a commutative monoid and <code>merge</code> requires a bounded semilattice (or idempotent commutative monoid).</p>
    <p>Cats provides a type class for both <code>Monoid</code> and <code>CommutativeMonoid</code>, but doesn’t provide one for bounded semilattice[^spire]. That’s why we’re going to implement our own <code>BoundedSemiLattice</code> type class.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.kernel.CommutativeMonoid<br><br><span style="color: #d73948">trait</span><span style="color: #4b69c6"> BoundedSemiLattice</span>[<span style="color: #4b69c6">A</span>] <span style="color: #d73948">extends</span> <span style="color: #8b41b1">CommutativeMonoid</span>[<span style="color: #4b69c6">A</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">combine</span>(a1: <span style="color: #4b69c6">A</span>, a2: <span style="color: #4b69c6">A</span>): <span style="color: #4b69c6">A</span><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">empty</span>: <span style="color: #4b69c6">A</span><br>}</code></pre>
    <p>In the implementation above, <code>BoundedSemiLattice[A]</code> extends <code>CommutativeMonoid[A]</code> because a bounded semilattice is a commutative monoid (a commutative idempotent one, to be exact).</p>
    <h4 id="loc-468">22.3.2. Exercise: BoundedSemiLattice Instances</h4>
    <p>Implement <code>BoundedSemiLattice</code> type class instances for <code>Ints</code> and for <code>Sets</code>. The instance for <code>Int</code> will technically only hold for non-negative numbers, but you don’t need to model non-negativity explicitly in the types.</p>
    <h4 id="loc-469">22.3.3. Exercise: Generic GCounter</h4>
    <p>Using <code>CommutativeMonoid</code> and <code>BoundedSemiLattice</code>, generalise <code>GCounter</code>.</p>
    <p>When you implement this, look for opportunities to use methods and syntax on <code>Monoid</code> to simplify your implementation. This is a good example of how type class abstractions work at multiple levels in our code. We’re using monoids to design a large component—our CRDTs—but they are also useful in the small, simplifying our code and making it shorter and clearer.</p>
    <p>[^spire]: A closely related library called <a href="https://github.com/non/spire">Spire</a> already provides that abstractions.</p>
    <h3 id="loc-470">22.4. Abstracting GCounter to a Type Class</h3>
    <p>We’ve created a generic GCounter that works with any value that has instances of <code>BoundedSemiLattice</code> and <code>CommutativeMonoid</code>. However we’re still tied to a particular representation of the map from machine IDs to values. There is no need to have this restriction, and indeed it can be useful to abstract away from it. There are many key-value stores that we want to work with, from a simple <code>Map</code> to a relational database.</p>
    <p>If we define a <code>GCounter</code> type class we can abstract over different concrete implementations. This allows us to, for example, seamlessly substitute an in-memory store for a persistent store when we want to change performance and durability tradeoffs.</p>
    <p>There are a number of ways we can implement this. One approach is to define a <code>GCounter</code> type class with dependencies on <code>CommutativeMonoid</code> and <code>BoundedSemiLattice</code>. We define this as a type class that takes a type constructor with <em>two</em> type parameters represent the key and value types of the map abstraction.</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> GCounter</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>,<span style="color: #d73948">_</span>],<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">increment</span>(f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])(k: <span style="color: #4b69c6">K</span>, v: <span style="color: #4b69c6">V</span>)<br>        (<span style="color: #d73948">implicit</span> m: <span style="color: #4b69c6">CommutativeMonoid</span>[<span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">merge</span>(f1: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>], f2: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])<br>        (<span style="color: #d73948">implicit</span> b: <span style="color: #4b69c6">BoundedSemiLattice</span>[<span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">total</span>(f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])<br>        (<span style="color: #d73948">implicit</span> m: <span style="color: #4b69c6">CommutativeMonoid</span>[<span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">V</span><br>}<br><br><span style="color: #d73948">object</span><span style="color: #4b69c6"> GCounter</span> {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">apply</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>,<span style="color: #d73948">_</span>], <span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]<br>        (<span style="color: #d73948">implicit</span> counter: <span style="color: #4b69c6">GCounter</span>[<span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]) <span style="color: #d73948">=</span><br>    counter<br>}</code></pre>
    <p>Try defining an instance of this type class for <code>Map</code>. You should be able to reuse your code from the case class version of <code>GCounter</code> with some minor modifications.</p>
    <p>You should be able to use your instance as follows:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">import</span> cats.instances.int.<span style="color: #d73948">_</span> <span style="color: #74747c">//</span><span style="color: #74747c"> for Monoid</span><br><br><span style="color: #d73948">val</span> g1 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span> -> <span style="color: #b60157">7</span>, <span style="color: #198810">"</span><span style="color: #198810">b</span><span style="color: #198810">"</span> -> <span style="color: #b60157">3</span>)<br><span style="color: #d73948">val</span> g2 <span style="color: #d73948">=</span> <span style="color: #4b69c6">Map</span>(<span style="color: #198810">"</span><span style="color: #198810">a</span><span style="color: #198810">"</span> -> <span style="color: #b60157">2</span>, <span style="color: #198810">"</span><span style="color: #198810">b</span><span style="color: #198810">"</span> -> <span style="color: #b60157">5</span>)<br><br><span style="color: #d73948">val</span> counter <span style="color: #d73948">=</span> <span style="color: #4b69c6">GCounter</span>[<span style="color: #4b69c6">Map</span>, <span style="color: #4b69c6">String</span>, <span style="color: #d73948">Int</span>]</code></pre>
    <pre><code data-lang="scala"><span style="color: #d73948">val</span> merged <span style="color: #d73948">=</span> counter.merge(g1, g2)<br><span style="color: #74747c">//</span><span style="color: #74747c"> merged: Map[String, Int] = Map("a" -> 7, "b" -> 5)</span><br><span style="color: #d73948">val</span> total  <span style="color: #d73948">=</span> counter.total(merged)<br><span style="color: #74747c">//</span><span style="color: #74747c"> total: Int = 12</span></code></pre>
    <p>The implementation strategy for the type class instance is a bit unsatisfying. Although the structure of the implementation will be the same for most instances we define, we won’t get any code reuse.</p>
    <h3 id="loc-471">22.5. Abstracting a Key Value Store</h3>
    <p>One solution is to capture the idea of a key-value store within a type class, and then generate <code>GCounter</code> instances for any type that has a <code>KeyValueStore</code> instance. Here’s the code for such a type class:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">trait</span><span style="color: #4b69c6"> KeyValueStore</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>,<span style="color: #d73948">_</span>]] {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">put</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>](f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])(k: <span style="color: #4b69c6">K</span>, v: <span style="color: #4b69c6">V</span>): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">get</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>](f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])(k: <span style="color: #4b69c6">K</span>): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">V</span>]<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getOrElse</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>](f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])(k: <span style="color: #4b69c6">K</span>, default: <span style="color: #4b69c6">V</span>): <span style="color: #4b69c6">V</span> <span style="color: #d73948">=</span><br>    get(f)(k).getOrElse(default)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">values</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>](f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">V</span>]<br>}</code></pre>
    <p>Implement your own instance for <code>Map</code>.</p>
    <p>With our type class in place we can implement syntax to enhance data types for which we have instances:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">implicit</span> <span style="color: #d73948">class</span><span style="color: #4b69c6"> KvsOps</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>,<span style="color: #d73948">_</span>], <span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>](f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]) {<br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">put</span>(key: <span style="color: #4b69c6">K</span>, value: <span style="color: #4b69c6">V</span>)<br>        (<span style="color: #d73948">implicit</span> kvs: <span style="color: #4b69c6">KeyValueStore</span>[<span style="color: #4b69c6">F</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>] <span style="color: #d73948">=</span><br>    kvs.put(f)(key, value)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">get</span>(key: <span style="color: #4b69c6">K</span>)(<span style="color: #d73948">implicit</span> kvs: <span style="color: #4b69c6">KeyValueStore</span>[<span style="color: #4b69c6">F</span>]): <span style="color: #4b69c6">Option</span>[<span style="color: #4b69c6">V</span>] <span style="color: #d73948">=</span><br>    kvs.get(f)(key)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">getOrElse</span>(key: <span style="color: #4b69c6">K</span>, default: <span style="color: #4b69c6">V</span>)<br>        (<span style="color: #d73948">implicit</span> kvs: <span style="color: #4b69c6">KeyValueStore</span>[<span style="color: #4b69c6">F</span>]): <span style="color: #4b69c6">V</span> <span style="color: #d73948">=</span><br>    kvs.getOrElse(f)(key, default)<br><br>  <span style="color: #d73948">def</span> <span style="color: #4b69c6">values</span>(<span style="color: #d73948">implicit</span> kvs: <span style="color: #4b69c6">KeyValueStore</span>[<span style="color: #4b69c6">F</span>]): <span style="color: #4b69c6">List</span>[<span style="color: #4b69c6">V</span>] <span style="color: #d73948">=</span><br>    kvs.values(f)<br>}</code></pre>
    <p>Now we can generate <code>GCounter</code> instances for any data type that has instances of <code>KeyValueStore</code> and <code>CommutativeMonoid</code> using an <code>implicit def</code>:</p>
    <pre><code data-lang="scala"><span style="color: #d73948">implicit</span> <span style="color: #d73948">def</span> <span style="color: #4b69c6">gcounterInstance</span>[<span style="color: #4b69c6">F</span>[<span style="color: #d73948">_</span>,<span style="color: #d73948">_</span>], <span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]<br>    (<span style="color: #d73948">implicit</span> kvs: <span style="color: #4b69c6">KeyValueStore</span>[<span style="color: #4b69c6">F</span>], km: <span style="color: #4b69c6">CommutativeMonoid</span>[<span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>]]): <span style="color: #4b69c6">GCounter</span>[<span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>] <span style="color: #d73948">=</span><br>  <span style="color: #d73948">new</span> <span style="color: #4b69c6">GCounter</span>[<span style="color: #4b69c6">F</span>, <span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>] {<br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">increment</span>(f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])(key: <span style="color: #4b69c6">K</span>, value: <span style="color: #4b69c6">V</span>)<br>          (<span style="color: #d73948">implicit</span> m: <span style="color: #4b69c6">CommutativeMonoid</span>[<span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>] <span style="color: #d73948">=</span> {<br>      <span style="color: #d73948">val</span> total <span style="color: #d73948">=</span> f.getOrElse(key, m.empty) |+| value<br>      f.put(key, total)<br>    }<br><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">merge</span>(f1: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>], f2: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])<br>          (<span style="color: #d73948">implicit</span> b: <span style="color: #4b69c6">BoundedSemiLattice</span>[<span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>] <span style="color: #d73948">=</span><br>      f1 |+| f2<br><br>    <span style="color: #d73948">def</span> <span style="color: #4b69c6">total</span>(f: <span style="color: #4b69c6">F</span>[<span style="color: #4b69c6">K</span>, <span style="color: #4b69c6">V</span>])(<span style="color: #d73948">implicit</span> m: <span style="color: #4b69c6">CommutativeMonoid</span>[<span style="color: #4b69c6">V</span>]): <span style="color: #4b69c6">V</span> <span style="color: #d73948">=</span><br>      f.values.combineAll<br>  }</code></pre>
    <p>The complete code for this case study is quite long, but most of it is boilerplate setting up syntax for operations on the type class. We can cut down on this using compiler plugins such as [Simulacrum][link-simulacrum] and [Kind Projector][link-kind-projector].</p>
    <h3 id="loc-472">22.6. Summary</h3>
    <p>In this case study we’ve seen how we can use type classes to model a simple CRDT, the GCounter, in Scala. Our implementation gives us a lot of flexibility and code reuse: we aren’t tied to the data type we “count”, nor to the data type that maps machine IDs to counters.</p>
    <p>The focus in this case study has been on using the tools that Scala provides, not on exploring CRDTs. There are many other CRDTs, some of which operate in a similar manner to the GCounter, and some of which have very different implementations. A [fairly recent survey][link-crdt-survey] gives a good overview of many of the basic CRDTs. However this is an active area of research and we encourage you to read the recent publications in the field if CRDTs and eventually consistency interest you.</p>
    <p>part{Appendices} appendix</p>
    <h2 id="loc-473">23. Acknowledgements</h2>
    <p>No book is an island. This book wouldn’t exist without it’s predecessor, <em>Scala with Cats</em>, and everyone involved in creating that book implicitly played some part in this book’s creation. See below for that book’s acknowledgements, but in particular I want to highlight my coauthor, Dave “Lord of Types” Pereira-Gurnell, without whom that book would not exist and hence neither would this one. Thanks Dave!</p>
    <p>Thanks also to Adam Rosien, who gave me low-key encouragement and put up with my bullshit. Also my wife and children, who put up with even more of my bullshit, and gave me the space to finish this project. The members of ScalaBridge London and attendees at various training courses acted as experimental subjects for a lot of the material here. Thank you for being willing test subjects; you greatly helped improve the content. Thanks for the members of the PLT research group who inspired me directly back in the day, and continue to provide inspiration from afar. Finally, thanks to the following who sponsored my work or contributed with corrections and suggestions:</p>
    <p>Aleksandr Andreev, Charles Adetiloye, Johanna Odersky, Lunfu Zhong, Maciej Gorywoda , Mathieu Pichette, Murat Cetin , Olya Mazhara, Pavel Syvak, Philip Schwarz, Seth Tisue, Tim Eccleston (<a href="https://github.com/combinatorist">@combinatorist</a>).</p>
    <h3 id="loc-474">23.1. Acknowledgements from Scala with Cats</h3>
    <p>We’d like to thank our colleagues at Inner Product and Underscore, our friends at Typelevel, and everyone who helped contribute to this book. Special thanks to Jenny Clements for her fantastic artwork and Richard Dallaway for his proof reading expertise. Here is an alphabetical list of contributors:</p>
    <p>Alessandro Marrella, Cody Koeninger, Connie Chen, Conor Fennell, Dani Rey, Daniela Sfregola, Danielle Ashley, David Castillo, David Piggott, Denis Zjukow, Dennis Hunziker, Deokhwan Kim, Edd Steel, Eduardo Obando Boschini, Eugene Yushin, Evgeny Veretennikov, Francis Devereux, Ghislain Vaillant, Gregor Ihmor, Hayato Iida, Henk-Jan Meijer, HigherKindedType, Janne Pelkonen, Joao Azevedo, Jason Scott, Javier Arrieta, Jenny Clements, Jérémie Jost, Joachim Hofer, Jonathon Ferguson, Lance Paine, Leif Wickland, ltbs, Lunfu Zhong, Marc Prud’hommeaux, Martin Carolan, mizuno, Mr-SD, Narayan Iyer, Niccolo’ Paravanti, niqdev, Noor Nashid, Pablo Francisco Pérez Hidalgo, Pawel Jurczenko, Phil Derome, Philip Schwarz, Riccardo Sirigu, Richard Dallaway, Robert Stoll, Rodney Jacobsen, Rodrigo B. de Oliveira, Rud Wangrungarun, Seoh Char, Sergio Magnacco, Shohei Shimomura, Tim McIver, Toby Weston, Victor Osolovskiy, and Yinka Erinle.</p>
    <p>If you spot an error or potential improvement, please raise an issue or submit a PR on the book’s [Github page][link-github].</p>
    <h4 id="loc-475">23.1.1. Backers</h4>
    <p>We’d also like to extend very special thanks to our backers—fine people who helped fund the development of the book by buying a copy before we released it as open source. This book wouldn’t exist without you:</p>
    <p>A battle-hardened technologist, Aaron Pritzlaff, Abhishek Srivastava, Aleksey “Daron” Terekhin, Algolia, Allen George (&amp;commat;allenageorge), Andrew Johnson, Andrew Kerr, Andy Dwelly, Anler, anthony@dribble.ai, Aravindh Sridaran, Araxis Ltd, ArtemK, Arthur Kushka (&amp;commat;arhelmus), Artur Zhurat, Arturas Smorgun, Attila Mravik, Axel Gschaider, Bamboo Le, bamine, Barry Kern, Ben Darfler (&amp;commat;bdarfler), Ben Letton, Benjamin Neil, Benoit Hericher, Bernt Andreas Langøien, Bill Leck, Blaze K, Boniface Kabaso, Brian Wongchaowart, Bryan Dragon, &amp;commat;cannedprimates, Ceschiatti (&amp;commat;6qat), Chris Gojlo, Chris Phelps, &amp;commat;CliffRedmond, Cody Koeninger, Constantin Gonciulea, Dadepo Aderemi, Damir Vandic, Damon Rolfs, Dan Todor, Daniel Arndt, Daniela Sfregola, David Greco, David Poltorak, Dennis Hunziker, Dennis Vriend, Derek Morr, Dimitrios Liapis, Don McNamara, Doug Clinton, Doug Lindholm (dlindhol), Edgar Mueller, Edward J Renauer Jr, Emiliano Martinez, esthom, Etienne Peiniau, Fede Silva, Filipe Azevedo, Franck Rasolo, Gary Coady, George Ball, Gerald Loeffler, Integrational, Giles Taylor, Guilherme Dantas (&amp;commat;gamsd), Harish Hurchurn, Hisham Ismail, Iurii Susuk, Ivan (SkyWriter) Kasatenko, Ivano Pagano, Jacob Baumbach, James Morris, Jan Vincent Liwanag, Javier Gonzalez, Jeff Gentry, Joel Chovanec, Jon Bates, Jorge Aliss (&amp;commat;jaliss), Juan Macias (&amp;commat;1macias1), Juan Ortega, Juan Pablo Romero Méndez, Jungsun Kim, Kaushik Chakraborty (&amp;commat;kaychaks), Keith Mannock, Ken Hoffman, Kevin Esler, Kevin Kyyro, kgillies, Klaus Rehm, Kostas Skourtis, Lance Linder, Liang, Guang Hua, Loïc Girault, Luke Tebbs, Makis A, Malcolm Robbins, Mansur Ashraf (&amp;commat;mansur_ashraf), Marcel Lüthi, Marek Prochera &amp;commat;hicolour, Marianudo (Mariano Navas), Mark Eibes, Mark van Rensburg, Martijn Blankestijn, Martin Studer, Matthew Edwards, Matthew Pflueger, mauropalsgraaf, mbarak, Mehitabel, Michael Pigg, Mikael Moghadam, Mike Gehard (&amp;commat;mikegehard), MonadicBind, arjun.mukherjee&amp;commat;gmail.com, Stephen Arbogast, Narayan Iyer, &amp;commat;natewave, Netanel Rabinowitz, Nick Peterson, Nicolas Sitbon, Oier Blasco Linares, Oliver Daff, Oliver Schrenk, Olly Shaw, P Villela, pandaforme, Patrick Garrity, Pawel Wlodarski from JUG Lodz, &amp;commat;peel, Peter Perhac, Phil Glover, Philipp Leser-Wolf, Rachel Bowyer, Radu Gancea (&amp;commat;radusw), Rajit Singh, Ramin Alidousti, Raymond Tay, Riccardo Sirigu, Richard (Yin-Wu) Chuo, Rob Vermazeren, Robert “Kemichal” Andersson, Robin Taylor (&amp;commat;badgermind), Rongcui Dong, Rui Morais, Rupert Bates, Rustem Suniev, Sanjiv Sahayam, Shane Delmore, Stefan Plantikow, Sundy Wiliam Yaputra, Tal Pressman, Tamas Neltz, theLXK, Tim Pigden, Tobias Lutz, Tom Duhourq, &amp;commat;tomzalt, Utz Westermann, Vadym Shalts, Val Akkapeddi, Vasanth Loka, Vladimir Bacvanski, Vladimir Bystrov aka udav_pit, William Benton, Wojciech Langiewicz, Yann Ollivier (&amp;commat;ya2o), Yoshiro Naito, zero323, and zeronone.</p>
    <p>backmatter</p>
    <section role="doc-bibliography">
      <h2 id="loc-476">Bibliography</h2>
      <ul style="list-style-type: none">
        <li id="loc-477"><span class="prefix"><a href="#loc-2" role="doc-backlink">1.</a></span> Harold Abelson and Gerald Jay Sussman. 1996. <em>Structure and Interpretation of Computer Programs</em>. The MIT Press, Cambridge, MA.</li>
        <li id="loc-478"><span class="prefix"><a href="#loc-400" role="doc-backlink">2.</a></span> Mads Sig Ager, Dariusz Biernacki, Olivier Danvy, and Jan Midtgaard. 2003. From Interpreter to Compiler and Virtual Machine: A Functional Derivation. <em>BRICS Report Series</em> 10, 14.</li>
        <li id="loc-479"><span class="prefix"><a href="#loc-401" role="doc-backlink">3.</a></span> Patrick Bahr and Graham Hutton. 2015. Calculating correct compilers. <em>Journal of Functional Programming</em> 25: e14. https://doi.org/<a href="https://doi.org/10.1017/S0956796815000180">10.1017/S0956796815000180</a></li>
        <li id="loc-480"><span class="prefix"><a href="#loc-20" role="doc-backlink">4.</a></span> Kent Beck. 1999. <em>Extreme Programming Explained: Embrace Change</em>. Addison-Wesley.</li>
        <li id="loc-481"><span class="prefix"><a href="#loc-407" role="doc-backlink">5.</a></span> James R. Bell. 1973. Threaded Code. <em>Communications of the ACM</em> 16, 6: 370–372. https://doi.org/<a href="https://doi.org/10.1145/362248.362270">10.1145/362248.362270</a></li>
        <li id="loc-482"><span class="prefix"><a href="#loc-595" role="doc-backlink">6.</a></span> Joshua Bloch. 2017. <em>Effective Java</em>. Addison-Wesley Professional.</li>
        <li id="loc-483"><span class="prefix"><a href="#loc-364" role="doc-backlink">7.</a></span> Margaret A. Boden and Ernest A. Edmonds. 2009. What is generative art?. <em>Digital Creativity</em>, 20: 21–46. https://doi.org/<a href="https://doi.org/10.1080/14626260902867915">10.1080/14626260902867915</a></li>
        <li id="loc-484"><span class="prefix"><a href="#loc-397" role="doc-backlink">8.</a></span> Janusz A. Brzozowski. 1964. Derivatives of Regular Expressions. <em>Journal of the ACM (JACM)</em> 11, 4: 481–494. https://doi.org/<a href="https://doi.org/10.1145/321239.321249">10.1145/321239.321249</a></li>
        <li id="loc-485"><span class="prefix"><a href="#loc-71" role="doc-backlink">9.</a></span> R. M. Burstall. 1969. Proving Properties of Programs by Structural Induction. <em>The Computer Journal</em> 12, 1: 41–48. https://doi.org/<a href="https://doi.org/10.1093/comjnl/12.1.41">10.1093/comjnl/12.1.41</a></li>
        <li id="loc-486"><span class="prefix"><a href="#loc-381" role="doc-backlink">10.</a></span> Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan. 2009. Finally Tagless, Partially Evaluated: Tagless Staged Interpreters for Simpler Typed Languages. <em>Journal of Functional Programming</em> 5: 509–543. Retrieved from <a href="https://okmij.org/ftp/tagless-final/JFP.pdf">https://okmij.org/ftp/tagless-final/JFP.pdf</a></li>
        <li id="loc-487"><span class="prefix"><a href="#loc-405" role="doc-backlink">11.</a></span> Kevin Casey, David Gregg, M. Anton Ertl, and Andrew Nisbet. 2003. Towards Superinstructions for Java Interpreters. In <em>Software and Compilers for Embedded Systems, 7th International Workshop, SCOPES 2003, Vienna, Austria, September 24-26, 2003, Proceedings</em> (Lecture Notes in Computer Science), 329–343. https://doi.org/<a href="https://doi.org/10.1007/978-3-540-39920-9\_23">10.1007/978-3-540-39920-9\_23</a></li>
        <li id="loc-488"><span class="prefix"><a href="#loc-49" role="doc-backlink">12.</a></span> Giuseppe Castagna, Guillaume Duboc, and José Valim. 2023. The Design Principles of the Elixir Type System. <em>The Art, Science, and Engineering of Programming</em> 8, 2. https://doi.org/<a href="https://doi.org/10.22152/programming-journal.org/2024/8/4">10.22152/programming-journal.org/2024/8/4</a></li>
        <li id="loc-489"><span class="prefix"><a href="#loc-337" role="doc-backlink">13.</a></span> James Cheney and Ralf Hinze. 2003. <em>First-class Phantom Types</em>. Cornell University. Retrieved from <a href="https://ecommons.cornell.edu/server/api/core/bitstreams/6cf38000-1bc3-4572-b71f-9ddb06f3565c/content">https://ecommons.cornell.edu/server/api/core/bitstreams/6cf38000-1bc3-4572-b71f-9ddb06f3565c/content</a></li>
        <li id="loc-490"><span class="prefix"><a href="#loc-358" role="doc-backlink">14.</a></span> Koen Claessen and John Hughes. 2000. QuickCheck: a lightweight tool for random testing of Haskell programs. In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em> (ICFP '00), 268–279. https://doi.org/<a href="https://doi.org/10.1145/351240.351266">10.1145/351240.351266</a></li>
        <li id="loc-491"><span class="prefix"><a href="#loc-19" role="doc-backlink">15.</a></span> David Conley. 2014. <em>Learning Strategies as Metacognitive Factors: A Critical Review</em>. Educational Policy Improvement Center, Eugene, OR.</li>
        <li id="loc-492"><span class="prefix"><a href="#loc-380" role="doc-backlink">16.</a></span> William Cook. 1990. Object-Oriented Programming Versus Abstract Data Types. In <em>Proceedings of the REX Workshop/School on the Foundations of Object-Oriented Languages (FOOL)</em> (LNCS), 151–178. Retrieved from <a href="https://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf">https://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf</a></li>
        <li id="loc-493"><span class="prefix"><a href="#loc-143" role="doc-backlink">17.</a></span> Olivier Danvy and Lasse R. Nielsen. 2001. Defunctionalization at Work. In <em>Proceedings of the 3rd ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming</em> (PPDP '01), 162–174. https://doi.org/<a href="https://doi.org/10.1145/773184.773202">10.1145/773184.773202</a></li>
        <li id="loc-494"><span class="prefix"><a href="#loc-346" role="doc-backlink">18.</a></span> Nina Dethlefs and Ken Hawick. 2017. DEFIne: A Fluent Interface DSL for Deep Learning Applications. In <em>Proceedings of the 2nd International Workshop on Real World Domain Specific Languages</em> (RWDSL17). https://doi.org/<a href="https://doi.org/10.1145/3039895.3039898">10.1145/3039895.3039898</a></li>
        <li id="loc-495"><span class="prefix"><a href="#loc-408" role="doc-backlink">19.</a></span> Robert B. K. Dewar. 1975. Indirect Threaded Code. <em>Communications of the ACM</em> 18, 6: 330–331. https://doi.org/<a href="https://doi.org/10.1145/360825.360849">10.1145/360825.360849</a></li>
        <li id="loc-496"><span class="prefix"><a href="#loc-365" role="doc-backlink">20.</a></span> Alan Dorin, Jonathan McCabe, Jon McCormack, Gordon Monro, and Mitchell Whitelaw. 2012. A Framework for Understanding Generative Art. <em>Digital Creativity</em>: 239–259. https://doi.org/<a href="https://doi.org/10.1080/14626268.2012.709940">10.1080/14626268.2012.709940</a></li>
        <li id="loc-497"><span class="prefix"><a href="#loc-91" role="doc-backlink">21.</a></span> Paul Downen and Zena M. Ariola. 2021. Classical (Co)Recursion: Programming. <em>CoRR</em>. Retrieved from <a href="https://arxiv.org/abs/2103.06913">https://arxiv.org/abs/2103.06913</a></li>
        <li id="loc-498"><span class="prefix"><a href="#loc-88" role="doc-backlink">22.</a></span> Paul Downen, Zachary Sullivan, Zena M Ariola, and Simon Peyton Jones. 2019. Codata in Action. In <em>European Symposium on Programming</em>, 119–146. Retrieved from <a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/01/CoDataInAction.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2020/01/CoDataInAction.pdf</a></li>
        <li id="loc-499"><span class="prefix"><a href="#loc-360" role="doc-backlink">23.</a></span> Jonas Duregård, Patrik Jansson, and Meng Wang. 2012. Feat: Functional Enumeration of Algebraic Types. <em>ACM SIGPLAN Notices</em> 47, 12: 61–72. https://doi.org/<a href="https://doi.org/10.1145/2430532.2364515">10.1145/2430532.2364515</a></li>
        <li id="loc-500"><span class="prefix"><a href="#loc-406" role="doc-backlink">24.</a></span> M. Anton Ertl and David Gregg. 2003. The Structure and Performance of Efficient Interpreters. <em>Journal of Instruction Level Parallelism</em> 5. Retrieved from <a href="http://www.jilp.org/vol5/v5paper12.pdf">http://www.jilp.org/vol5/v5paper12.pdf</a></li>
        <li id="loc-501"><span class="prefix"><a href="#loc-403" role="doc-backlink">25.</a></span> M. Anton Ertl. 1995. Stack Caching for Interpreters. In <em>Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation (PLDI), La Jolla, California, USA, June 18-21, 1995</em>, 315–327. https://doi.org/<a href="https://doi.org/10.1145/207110.207165">10.1145/207110.207165</a></li>
        <li id="loc-502"><span class="prefix"><a href="#loc-354" role="doc-backlink">26.</a></span> Martin Erwig and Steve Kollmansberger. 2006. Functional Pearls: Probabilistic Functional Programming in Haskell. <em>Journal of Functional Programming</em> 16, 1: 21–34. https://doi.org/<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a></li>
        <li id="loc-503"><span class="prefix"><a href="#loc-22" role="doc-backlink">27.</a></span> Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and Shriram Krishnamurthi. 2018. <em>How to Design Programs</em>. The MIT Press, Cambridge, MA. Retrieved from <a href="https://htdp.org/">https://htdp.org/</a></li>
        <li id="loc-504"><span class="prefix"><a href="#loc-343" role="doc-backlink">28.</a></span> Martin Fowler. 2005. Fluent Interface.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved May 12, 2025 from <a href="https://www.martinfowler.com/bliki/FluentInterface.html">https://www.martinfowler.com/bliki/FluentInterface.html</a></li>
        <li id="loc-505"><span class="prefix"><a href="#loc-276" role="doc-backlink">29.</a></span> Phil Freeman. 2015. Stack Safety for Free.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved from <a href="https://functorial.com/stack-safety-for-free/index.pdf">https://functorial.com/stack-safety-for-free/index.pdf</a></li>
        <li id="loc-506"><span class="prefix"><a href="#loc-344" role="doc-backlink">30.</a></span> Steve Freeman and Nat Pryce. 2006. Evolving an Embedded Domain-Specific Language in Java. In <em>Companion to the 21st ACM SIGPLAN Symposium on Object-Oriented Programming Systems, Languages, and Applications</em> (OOPSLA '06), 855–865. https://doi.org/<a href="https://doi.org/10.1145/1176617.1176735">10.1145/1176617.1176735</a></li>
        <li id="loc-507"><span class="prefix"><a href="#loc-21" role="doc-backlink">31.</a></span> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. 1994. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley.</li>
        <li id="loc-508"><span class="prefix"><a href="#loc-75" role="doc-backlink">32.</a></span> Jeremy Gibbons and Geraint Jones. 1998. The Under-appreciated Unfold. In <em>Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming</em> (ICFP '98), 273–279. https://doi.org/<a href="https://doi.org/10.1145/289423.289455">10.1145/289423.289455</a></li>
        <li id="loc-509"><span class="prefix"><a href="#loc-324" role="doc-backlink">33.</a></span> Jeremy Gibbons and Bruno César dos Santos Oliveira. 2009. The Essence of the Iterator Pattern. <em>Journal of Functional Programming</em> 19, 3&amp;amp;4: 377–402. https://doi.org/<a href="https://doi.org/10.1017/S0956796809007291">10.1017/S0956796809007291</a></li>
        <li id="loc-510"><span class="prefix"><a href="#loc-385" role="doc-backlink">34.</a></span> Jeremy Gibbons and Nicolas Wu. 2014. Folding Domain-Specific Languages: Deep and Shallow Embeddings (Functional Pearl). <em>SIGPLAN Not.</em> 49, 9: 339–347. https://doi.org/<a href="https://doi.org/10.1145/2692915.2628138">10.1145/2692915.2628138</a></li>
        <li id="loc-511"><span class="prefix"><a href="#loc-74" role="doc-backlink">35.</a></span> Jeremy Gibbons. 2021. How to Design Co-Programs. <em>Journal of Functional Programming</em> 31: e15. https://doi.org/<a href="https://doi.org/10.1017/S0956796821000113">10.1017/S0956796821000113</a></li>
        <li id="loc-512"><span class="prefix"><a href="#loc-144" role="doc-backlink">36.</a></span> Jeremy Gibbons. 2022. Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity. <em>The Art, Science, and Engineering of Programming</em> 6, 7. https://doi.org/<a href="https://doi.org/https://doi.org/10.22152/programming-journal.org/2022/6/7">https://doi.org/10.22152/programming-journal.org/2022/6/7</a></li>
        <li id="loc-513"><span class="prefix"><a href="#loc-351" role="doc-backlink">37.</a></span> Yossi Gil and Ori Roth. 2019. Fling - A Fluent API Generator. In <em>33rd European Conference on Object-Oriented Programming (ECOOP 2019)</em> (Leibniz International Proceedings in Informatics (LIPIcs), 13:1–13:25. https://doi.org/<a href="https://doi.org/10.4230/LIPIcs.ECOOP.2019.13">10.4230/LIPIcs.ECOOP.2019.13</a></li>
        <li id="loc-514"><span class="prefix"><a href="#loc-363" role="doc-backlink">38.</a></span> Harrison Goldstein, Joseph W. Cutler, Daniel Dickstein, Benjamin C. Pierce, and Andrew Head. 2024. Property-Based Testing in Practice. In <em>Proceedings of the IEEE/ACM 46th International Conference on Software Engineering</em> (ICSE '24). https://doi.org/<a href="https://doi.org/10.1145/3597503.3639581">10.1145/3597503.3639581</a></li>
        <li id="loc-515"><span class="prefix"><a href="#loc-410" role="doc-backlink">39.</a></span> Andreas Haas, Andreas Rossberg, Derek L. Schuff, Ben L. Titzer, Michael Holman, Dan Gohman, Luke Wagner, Alon Zakai, and J. F. Bastien. 2017. Bringing the Web up to Speed with WebAssembly. In <em>Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2017, Barcelona, Spain, June 18-23, 2017</em>, 185–200. https://doi.org/<a href="https://doi.org/10.1145/3062341.3062363">10.1145/3062341.3062363</a></li>
        <li id="loc-516"><span class="prefix"><a href="#loc-87" role="doc-backlink">40.</a></span> Tatsuya Hagino. 1989. Codatatypes in ML. <em>Journal of Symbolic Computation</em> 8, 6: 629–650. https://doi.org/<a href="https://doi.org/https://doi.org/10.1016/S0747-7171(89)80065-3">https://doi.org/10.1016/S0747-7171(89)80065-3</a></li>
        <li id="loc-517"><span class="prefix"><a href="#loc-345" role="doc-backlink">41.</a></span> K. A. Hawick. 2013. Fluent Interfaces and Domain-Specific Languages for Graph Generation and Network Analysis Calculations. In <em>Procceedings of the International Conference on Software Engineering (SE’13)</em>, 752–759.</li>
        <li id="loc-518"><span class="prefix"><a href="#loc-118" role="doc-backlink">42.</a></span> Stefan Kaes. 1988. Parametric Overloading in Polymorphic Programming Languages. In <em>ESOP '88</em>, 131–144.</li>
        <li id="loc-519"><span class="prefix"><a href="#loc-355" role="doc-backlink">43.</a></span> Eric Kidd. 2007. Build your own probability monads.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved from <a href="https://www.randomhacks.net/files/build-your-own-probability-monads.pdf">https://www.randomhacks.net/files/build-your-own-probability-monads.pdf</a></li>
        <li id="loc-520"><span class="prefix"><a href="#loc-92" role="doc-backlink">44.</a></span> Oleg Kiselyov. 2005. Beyond Church encoding: Boehm-Berarducci isomorphism of algebraic data types and polymorphic lambda-terms.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved from <a href="https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html">https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html</a></li>
        <li id="loc-521"><span class="prefix"><a href="#loc-382" role="doc-backlink">45.</a></span> Oleg Kiselyov. 2012. Typed Tagless Final Interpreters. In <em>Generic and Indexed Programming: International Spring School, SSGIP 2010, Oxford, UK, March 22-26, 2010, Revised Lectures</em>, Jeremy Gibbons (ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 130–174. https://doi.org/<a href="https://doi.org/10.1007/978-3-642-32202-0_3">10.1007/978-3-642-32202-0_3</a></li>
        <li id="loc-522"><span class="prefix"><a href="#loc-50" role="doc-backlink">46.</a></span> Ansten Klev. 2019. A Comparison of Type Theory with Set Theory. In <em>Reflections on the Foundations of Mathematics: Univalent Foundations, Set Theory and General Thoughts</em>, Stefania Centrone, Deborah Kant and Deniz Sarikaya (eds.). Springer International Publishing, Cham, 271–292. https://doi.org/<a href="https://doi.org/10.1007/978-3-030-15655-8_12">10.1007/978-3-030-15655-8_12</a></li>
        <li id="loc-523"><span class="prefix"><a href="#loc-122" role="doc-backlink">47.</a></span> Filip Křikava, Heather Miller, and Jan Vitek. 2019. Scala Implicits Are Everywhere: A Large-Scale Study of the Use of Scala Implicits in the Wild. <em>Proceedings of the ACM on Programming Languages</em> 3, OOPSLA. https://doi.org/<a href="https://doi.org/10.1145/3360589">10.1145/3360589</a></li>
        <li id="loc-524"><span class="prefix"><a href="#loc-336" role="doc-backlink">48.</a></span> Daan Leijen and Erik Meijer. 2000. Domain Specific Embedded Compilers. In <em>Proceedings of the 2nd Conference on Domain-Specific Languages</em> (DSL '99), 109–122. https://doi.org/<a href="https://doi.org/10.1145/331960.331977">10.1145/331960.331977</a></li>
        <li id="loc-525"><span class="prefix"><a href="#loc-362" role="doc-backlink">49.</a></span> Caroline Lemieux, Jeevana Priya Inala, Shuvendu K. Lahiri, and Siddhartha Sen. 2023. CodaMosa: Escaping Coverage Plateaus in Test Generation with Pre-trained Large Language Models. In <em>2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE)</em>, 919–931. https://doi.org/<a href="https://doi.org/10.1109/ICSE48619.2023.00085">10.1109/ICSE48619.2023.00085</a></li>
        <li id="loc-526"><span class="prefix"><a href="#loc-349" role="doc-backlink">50.</a></span> Tomer Levy. 2016. A Fluent API for Automatic Generation of Fluent APIs in Java. Technion.</li>
        <li id="loc-527"><span class="prefix"><a href="#loc-121" role="doc-backlink">51.</a></span> Jeffrey R. Lewis, John Launchbury, Erik Meijer, and Mark B. Shields. 2000. Implicit Parameters: Dynamic Scoping with Static Types. In <em>Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em> (POPL '00), 108–118. https://doi.org/<a href="https://doi.org/10.1145/325694.325708">10.1145/325694.325708</a></li>
        <li id="loc-528"><span class="prefix"><a href="#loc-339" role="doc-backlink">52.</a></span> Chuan-kai Lin and Tim Sheard. 2010. Pointwise generalized algebraic data types. In <em>Proceedings of the 5th ACM SIGPLAN Workshop on Types in Language Design and Implementation</em> (TLDI '10), 51–62. https://doi.org/<a href="https://doi.org/10.1145/1708016.1708024">10.1145/1708016.1708024</a></li>
        <li id="loc-529"><span class="prefix"><a href="#loc-19" role="doc-backlink">53.</a></span> Tadhg E. MacIntyre, Eric R. Igou, Mark J. Campbell, Aidan P. Moran, and James Matthews. 2014. Metacognition and Action: A New Pathway to Understanding Social and Cognitive Aspects of Expertise in Sport. <em>Frontiers in Psychology</em> 5, 1155. https://doi.org/<a href="https://doi.org/10.3389/fpsyg.2014.01155">10.3389/fpsyg.2014.01155</a></li>
        <li id="loc-530"><span class="prefix"><a href="#loc-312" role="doc-backlink">54.</a></span> Conor Mcbride and Ross Paterson. 2008. Applicative Programming with Effects. <em>Journal of Functional Programming</em> 18, 1: 1–13. https://doi.org/<a href="https://doi.org/10.1017/S0956796807006326">10.1017/S0956796807006326</a></li>
        <li id="loc-531"><span class="prefix"><a href="#loc-76" role="doc-backlink">55.</a></span> Conor McBride. 2001. The Derivative of a Regular Type is its Type of One-Hole Contexts.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved from <a href="http://strictlypositive.org/diff.pdf">http://strictlypositive.org/diff.pdf</a></li>
        <li id="loc-532"><span class="prefix"><a href="#loc-70" role="doc-backlink">56.</a></span> Erik Meijer, Maarten Fokkinga, and Ross Paterson. 1991. Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. In <em>Functional Programming Languages and Computer Architecture</em>, 124–144. Retrieved from <a href="https://ris.utwente.nl/ws/portalfiles/portal/6142049/meijer91functional.pdf">https://ris.utwente.nl/ws/portalfiles/portal/6142049/meijer91functional.pdf</a></li>
        <li id="loc-533"><span class="prefix"><a href="#loc-398" role="doc-backlink">57.</a></span> Matthew Might, David Darais, and Daniel Spiewak. 2011. Parsing with Derivatives: a Functional Pearl. In <em>Proceeding of the 16th ACM SIGPLAN international conference on Functional Programming, ICFP 2011, Tokyo, Japan, September 19-21, 2011</em>, 189–195. https://doi.org/<a href="https://doi.org/10.1145/2034773.2034801">10.1145/2034773.2034801</a></li>
        <li id="loc-534"><span class="prefix"><a href="#loc-48" role="doc-backlink">58.</a></span> James H. Morris. 1973. Types Are Not Sets. In <em>Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</em> (POPL '73), 120–124. https://doi.org/<a href="https://doi.org/10.1145/512927.512938">10.1145/512927.512938</a></li>
        <li id="loc-535"><span class="prefix"><a href="#loc-399" role="doc-backlink">59.</a></span> Dan Moseley, Mario Nishio, Jose Perez Rodriguez, Olli Saarikivi, Stephen Toub, Margus Veanes, Tiki Wan, and Eric Xu. 2023. Derivative Based Nonbacktracking Real-World Regex Matching with Backtracking Semantics. <em>Proceedings of the ACM on Programming Languages</em> 7, PLDI. https://doi.org/<a href="https://doi.org/10.1145/3591262">10.1145/3591262</a></li>
        <li id="loc-536"><span class="prefix"><a href="#loc-350" role="doc-backlink">60.</a></span> Tomoki Nakamaru, Kazuhiro Ichikawa, Tetsuro Yamazaki, and Shigeru Chiba. 2017. Silverchain: A Fluent API Generator. <em>SIGPLAN Not.</em> 52, 12: 199–211. https://doi.org/<a href="https://doi.org/10.1145/3170492.3136041">10.1145/3170492.3136041</a></li>
        <li id="loc-537"><span class="prefix"><a href="#loc-348" role="doc-backlink">61.</a></span> Tomoki Nakamaru, Tomomasa Matsunaga, Tetsuro Yamazaki, Soramichi Akiyama, and Shigeru Chiba. 2020. An Empirical Study of Method Chaining in Java. In <em>Proceedings of the 17th International Conference on Mining Software Repositories</em> (MSR '20), 93–102. https://doi.org/<a href="https://doi.org/10.1145/3379597.3387441">10.1145/3379597.3387441</a></li>
        <li id="loc-538"><span class="prefix"><a href="#loc-124" role="doc-backlink">62.</a></span> Martin Odersky, Olivier Blanvillain, Fengyun Liu, Aggelos Biboudis, Heather Miller, and Sandro Stucki. 2017. Simplicitly: foundations and applications of implicit function types. <em>Proc. ACM Program. Lang.</em> 2, POPL. https://doi.org/<a href="https://doi.org/10.1145/3158130">10.1145/3158130</a></li>
        <li id="loc-539"><span class="prefix"><a href="#loc-383" role="doc-backlink">63.</a></span> Bruno C. d. S. Oliveira and William R. Cook. 2012. Extensibility for the masses: practical extensibility with object algebras. In <em>Proceedings of the 26th European Conference on Object-Oriented Programming</em> (ECOOP'12), 2–27. https://doi.org/<a href="https://doi.org/10.1007/978-3-642-31057-7_2">10.1007/978-3-642-31057-7_2</a></li>
        <li id="loc-540"><span class="prefix"><a href="#loc-123" role="doc-backlink">64.</a></span> Bruno C. D. S. Oliveira and Jeremy Gibbons. 2010. Scala for Generic Programmers: Comparing Haskell and Scala Support for Generic Programming. <em>Journal of Functional Programming</em> 20, 3–4: 303–352. https://doi.org/<a href="https://doi.org/10.1017/S0956796810000171">10.1017/S0956796810000171</a></li>
        <li id="loc-541"><span class="prefix"><a href="#loc-120" role="doc-backlink">65.</a></span> Bruno C.d.S. Oliveira, Adriaan Moors, and Martin Odersky. 2010. Type Classes as Objects and Implicits. In <em>Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications</em> (OOPSLA '10), 341–360. https://doi.org/<a href="https://doi.org/10.1145/1869459.1869489">10.1145/1869459.1869489</a></li>
        <li id="loc-542"><span class="prefix"><a href="#loc-341" role="doc-backlink">66.</a></span> Klaus Ostermann and Julian Jabs. 2018. Dualizing Generalized Algebraic Data Types by Matrix Transposition. In <em>Programming Languages and Systems</em>, 60–85.</li>
        <li id="loc-543"><span class="prefix"><a href="#loc-396" role="doc-backlink">67.</a></span> Scott Owens, John Reppy, and Aaron Turon. 2009. Regular-Expression Derivatives Re-Examined. <em>Journal of Functional Programming</em> 19, 2: 173–190. https://doi.org/<a href="https://doi.org/10.1017/S0956796808007090">10.1017/S0956796808007090</a></li>
        <li id="loc-544"><span class="prefix"><a href="#loc-338" role="doc-backlink">68.</a></span> Simon Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Geoffrey Washburn. 2006. Simple unification-based type inference for GADTs. <em>SIGPLAN Not.</em> 41, 9: 50–61. https://doi.org/<a href="https://doi.org/10.1145/1160074.1159811">10.1145/1160074.1159811</a></li>
        <li id="loc-545"><span class="prefix"><a href="#loc-47" role="doc-backlink">69.</a></span> Benjamin C. Pierce. 2002. <em>Types and Programming Languages</em>. The MIT Press, Cambridge, MA.</li>
        <li id="loc-546"><span class="prefix"><a href="#loc-19" role="doc-backlink">70.</a></span> Paul R. Pintrich. 2002. The Role of Metacognitive Knowledge in Learning, Teaching, and Assessing. <em>Theory into Practice</em> 41, 4.</li>
        <li id="loc-547"><span class="prefix"><a href="#loc-404" role="doc-backlink">71.</a></span> Todd A. Proebsting. 1995. Optimizing an ANSI C Interpreter with Superoperators. In <em>Conference Record of POPL'95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, San Francisco, California, USA, January 23-25, 1995</em>, 322–332. https://doi.org/<a href="https://doi.org/10.1145/199448.199526">10.1145/199448.199526</a></li>
        <li id="loc-548"><span class="prefix"><a href="#loc-361" role="doc-backlink">72.</a></span> Sameer Reddy, Caroline Lemieux, Rohan Padhye, and Koushik Sen. 2020. Quickly Generating Diverse Valid Test Inputs with Reinforcement Learning. In <em>2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)</em>, 1410–1421. Retrieved from <a href="https://ieeexplore.ieee.org/document/9284117">https://ieeexplore.ieee.org/document/9284117</a></li>
        <li id="loc-549"><span class="prefix"><a href="#loc-141" role="doc-backlink">73.</a></span> John C. Reynolds. 1972. Definitional Interpreters for Higher-Order Programming Languages. In <em>Proceedings of the ACM Annual Conference - Volume 2</em> (ACM '72), 717–740. https://doi.org/<a href="https://doi.org/10.1145/800194.805852">10.1145/800194.805852</a></li>
        <li id="loc-550"><span class="prefix"><a href="#loc-353" role="doc-backlink">74.</a></span> Ori Roth and Yossi Gil. 2023. Fluent APIs in Functional Languages. <em>Proceedings of the ACM on Programming Languages</em> 7, OOPSLA1: 876–901. https://doi.org/<a href="https://doi.org/10.1145/3586057">10.1145/3586057</a></li>
        <li id="loc-551"><span class="prefix"><a href="#loc-359" role="doc-backlink">75.</a></span> Colin Runciman, Matthew Naylor, and Fredrik Lindblad. 2008. Smallcheck and lazy smallcheck: automatic exhaustive testing for small values. In <em>Proceedings of the First ACM SIGPLAN Symposium on Haskell</em> (Haskell '08), 37–48. https://doi.org/<a href="https://doi.org/10.1145/1411286.1411292">10.1145/1411286.1411292</a></li>
        <li id="loc-552"><span class="prefix"><a href="#loc-356" role="doc-backlink">76.</a></span> Adam Scibior, Zoubin Ghahramani, and Andrew D. Gordon. 2015. Practical Probabilistic Programming with Monads. In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em> (Haskell '15), 165–176. https://doi.org/<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a></li>
        <li id="loc-553"><span class="prefix"><a href="#loc-357" role="doc-backlink">77.</a></span> Adam Scibior, Ohad Kammar, and Zoubin Ghahramani. 2018. Functional Programming for Modular Bayesian Inference. <em>Proc. ACM Program. Lang.</em> 2, ICFP. https://doi.org/<a href="https://doi.org/10.1145/3236778">10.1145/3236778</a></li>
        <li id="loc-554"><span class="prefix"><a href="#loc-337" role="doc-backlink">78.</a></span> Tim Sheard and Emir Pasalic. 2008. Meta-programming With Built-in Type Equality. <em>Electronic Notes in Theoretical Computer Science</em> 199: 49–65. https://doi.org/<a href="https://doi.org/https://doi.org/10.1016/j.entcs.2007.11.012">https://doi.org/10.1016/j.entcs.2007.11.012</a></li>
        <li id="loc-555"><span class="prefix"><a href="#loc-409" role="doc-backlink">79.</a></span> Yunhe Shi, Kevin Casey, M. Anton Ertl, and David Gregg. 2008. Virtual Machine Showdown: Stack versus Registers. <em>ACM Trans. Archit. Code Optim.</em> 4, 4: 2:1–2:36. https://doi.org/<a href="https://doi.org/10.1145/1328195.1328197">10.1145/1328195.1328197</a></li>
        <li id="loc-556"><span class="prefix"><a href="#loc-347" role="doc-backlink">80.</a></span> Nischal Shrestha, Titus Barik, and Chris Parnin. 2021. Unravel: A Fluent Code Explorer for Data Wrangling. In <em>The 34th Annual ACM Symposium on User Interface Software and Technology</em> (UIST '21), 198–207. https://doi.org/<a href="https://doi.org/10.1145/3472749.3474744">10.1145/3472749.3474744</a></li>
        <li id="loc-557"><span class="prefix"><a href="#loc-89" role="doc-backlink">81.</a></span> Zachary Sullivan. 2019. <em>Exploring Codata: The Relation to Object-Orientation</em>. University of Oregon, Computer, Information Sciences Department. Retrieved from <a href="https://www.cs.uoregon.edu/Reports/DRP-201905-Sullivan.pdf">https://www.cs.uoregon.edu/Reports/DRP-201905-Sullivan.pdf</a></li>
        <li id="loc-558"><span class="prefix"><a href="#loc-384" role="doc-backlink">82.</a></span> Wouter Swierstra. 2008. Data types à la carte. <em>Journal of Functional Programming</em> 18, 4: 423–436. https://doi.org/<a href="https://doi.org/10.1017/S0956796808006758">10.1017/S0956796808006758</a></li>
        <li id="loc-559"><span class="prefix"><a href="#loc-340" role="doc-backlink">83.</a></span> David Thibodeau, Andrew Cave, and Brigitte Pientka. 2016. Indexed Codata Types. In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em> (ICFP 2016), 351–363. https://doi.org/<a href="https://doi.org/10.1145/2951913.2951929">10.1145/2951913.2951929</a></li>
        <li id="loc-560"><span class="prefix"><a href="#loc-411" role="doc-backlink">84.</a></span> Ben L. Titzer. 2022. A Fast In-Place Interpreter for WebAssembly. <em>Proceedings of the ACM on Programming Languages</em> 6, OOPSLA2: 646–672. https://doi.org/<a href="https://doi.org/10.1145/3563311">10.1145/3563311</a></li>
        <li id="loc-561"><span class="prefix"><a href="#loc-33" role="doc-backlink">85.</a></span> Phillip Merlin Uesbeck. 2019. On the Human Factors Impact of Polyglot Programming on Programmer Productivity. University of Nevada, Las Vegas. Retrieved from <a href="https://web.cs.unlv.edu/stefika/documents/MerlinDissertation.pdf">https://web.cs.unlv.edu/stefika/documents/MerlinDissertation.pdf</a></li>
        <li id="loc-562"><span class="prefix"><a href="#loc-399" role="doc-backlink">86.</a></span> Ian Erik Varatalu, Margus Veanes, and Juhan Ernits. 2025. RE#: High Performance Derivative-Based Regex Matching with Intersection, Complement, and Restricted Lookarounds. <em>Proceedings of the ACM on Programming Languages</em> 9, POPL. https://doi.org/<a href="https://doi.org/10.1145/3704837">10.1145/3704837</a></li>
        <li id="loc-563"><span class="prefix"><a href="#loc-352" role="doc-backlink">87.</a></span> Milica Vuković, Vladimir Vujović, Zorana Štaka, and Snježana Milinković. 2023. Domain-Specific Language for Modeling Fluent API. In <em>2023 15th International Conference on Electronics, Computers and Artificial Intelligence (ECAI)</em>, 1–6. https://doi.org/<a href="https://doi.org/10.1109/ECAI58194.2023.10194083">10.1109/ECAI58194.2023.10194083</a></li>
        <li id="loc-564"><span class="prefix"><a href="#loc-119" role="doc-backlink">88.</a></span> P. Wadler and S. Blott. 1989. How to make ad-hoc polymorphism less ad hoc. In <em>Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em> (POPL '89), 60–76. https://doi.org/<a href="https://doi.org/10.1145/75277.75283">10.1145/75277.75283</a></li>
        <li id="loc-565"><span class="prefix"><a href="#loc-379" role="doc-backlink">89.</a></span> Phil Wadler. 1998. The Expression Problem.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved from <a href="https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt</a></li>
        <li id="loc-566"><span class="prefix"><a href="#loc-90" role="doc-backlink">90.</a></span> Philiip Wadler, Walid Taha, and David MacQueen. 1998. How to add laziness to a strict language without even being odd. In <em>SML'98, The SML workshop</em>. Retrieved from <a href="https://www.diva-portal.org/smash/get/diva2:413532/FULLTEXT01.pdf">https://www.diva-portal.org/smash/get/diva2:413532/FULLTEXT01.pdf</a></li>
        <li id="loc-567"><span class="prefix"><a href="#loc-600" role="doc-backlink">91.</a></span> Philip Wadler. 1989. Theorems for free!. In <em>Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture</em> (FPCA '89), 347–359. https://doi.org/<a href="https://doi.org/10.1145/99370.99404">10.1145/99370.99404</a></li>
        <li id="loc-568"><span class="prefix"><a href="#loc-278" role="doc-backlink">92.</a></span> Philip Wadler. 1992. The Essence of Functional Programming. In <em>Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em> (POPL '92), 1–14. https://doi.org/<a href="https://doi.org/10.1145/143165.143169">10.1145/143165.143169</a></li>
        <li id="loc-569"><span class="prefix"><a href="#loc-337" role="doc-backlink">93.</a></span> Hongwei Xi, Chiyan Chen, and Gang Chen. 2003. Guarded Recursive Datatype Constructors. In <em>Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em> (POPL '03), 224–235. https://doi.org/<a href="https://doi.org/10.1145/604131.604150">10.1145/604131.604150</a></li>
        <li id="loc-570"><span class="prefix"><a href="#loc-342" role="doc-backlink">94.</a></span> Weixin Zhang, Cristina David, and Meng Wang. 2022. Decomposition Without Regret.<span style="white-space: pre-wrap">&#x20;&#x20;</span>Retrieved from <a href="https://arxiv.org/abs/2204.10411">https://arxiv.org/abs/2204.10411</a></li>
      </ul>
    </section>
    <section role="doc-endnotes">
      <ol style="list-style-type: none">
        <li id="loc-571"><a href="#loc-4" role="doc-backlink"><sup>1</sup></a>https://typelevel.org/cats</li>
        <li id="loc-572"><a href="#loc-6" role="doc-backlink"><sup>2</sup></a>We assume you are using SBT 1.0.0 or newer</li>
        <li id="loc-573"><a href="#loc-10" role="doc-backlink"><sup>3</sup></a>https://scalawithcats.com</li>
        <li id="loc-574"><a href="#loc-11" role="doc-backlink"><sup>4</sup></a>http://www.scala-lang.org/api/current/scala/Option.html</li>
        <li id="loc-575"><a href="#loc-13" role="doc-backlink"><sup>5</sup></a>https://scalameta.org/mdoc/</li>
        <li id="loc-576"><a href="#loc-16" role="doc-backlink"><sup>6</sup></a>http://creativecommons.org/licenses/by-sa/4.0/</li>
        <li id="loc-577"><a href="#loc-17" role="doc-backlink"><sup>7</sup></a>https://creativecommons.org/licenses/by-sa/3.0/</li>
        <li id="loc-578"><a href="#loc-26" role="doc-backlink"><sup>8</sup></a>https://en.wikipedia.org/wiki/Monkey_patch</li>
        <li id="loc-579"><a href="#loc-28" role="doc-backlink"><sup>9</sup></a> The example I gave is fairly simple. A compiler that used <a href="https://en.wikipedia.org/wiki/Escape_analysis">escape analysis<a id="loc-580" href="#loc-582" role="doc-noteref"><sup>10</sup></a></a> could recognize that no reference to <code>total</code> is possible outside <code>sum</code> and hence <code>sum</code> is pure (or referentially transparent). Escape analysis is a well studied technique. In the general case the problem is a lot harder. We’d often like to know that a value is only referenced once at various points in our program, and hence we can mutate that value without changes being observable in other parts of the program. This might be used, for example, to pass an accumulator through various processing stages. To do this requires a programming language with what is called a <a href="https://en.wikipedia.org/wiki/Substructural_type_system">substructural type system<a id="loc-581" href="#loc-583" role="doc-noteref"><sup>11</sup></a></a>. Rust has such a system, with affine types. Linear types are in development for Haskell.</li>
        <li id="loc-582"><a href="#loc-580" role="doc-backlink"><sup>10</sup></a>https://en.wikipedia.org/wiki/Escape_analysis</li>
        <li id="loc-583"><a href="#loc-581" role="doc-backlink"><sup>11</sup></a>https://en.wikipedia.org/wiki/Substructural_type_system</li>
        <li id="loc-584"><a href="#loc-29" role="doc-backlink"><sup>12</sup></a>https://en.wikipedia.org/wiki/Effect_system</li>
        <li id="loc-585"><a href="#loc-32" role="doc-backlink"><sup>13</sup></a>https://danluu.com/empirical-pl/</li>
        <li id="loc-586"><a href="#loc-39" role="doc-backlink"><sup>14</sup></a> <a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation<a id="loc-587" href="#loc-588" role="doc-noteref"><sup>15</sup></a></a> is a more formal approach to this idea of encoding type information in names. Hungarian notation was popular within Microsoft and its ecosystem, but to the best of my knowledge it is no longer in common use.</li>
        <li id="loc-588"><a href="#loc-587" role="doc-backlink"><sup>15</sup></a>https://en.wikipedia.org/wiki/Hungarian_notation</li>
        <li id="loc-589"><a href="#loc-41" role="doc-backlink"><sup>16</sup></a> Scala usually runs on the JVM, and the JVM was not designed to support opaque types. This means there are, unfortunately, a few ways to poke holes in the abstraction boundary created by an opaque type. If we use <code>isInstanceOf</code> we can test for the underlying representation. Using the methods defined on <code>Object</code> (<code>Any</code> in Scala), namely <code>equals</code>, <code>hashCode</code>, and <code>toString</code>, also allow us to peek inside.</li>
        <li id="loc-590"><a href="#loc-44" role="doc-backlink"><sup>17</sup></a> We could use an <code>Array[Double]</code> or <code>Tuple2[Double, Double]</code>, but it’s simpler to just define a class in the usual way.</li>
        <li id="loc-591"><a href="#loc-46" role="doc-backlink"><sup>18</sup></a>https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</li>
        <li id="loc-592"><a href="#loc-72" role="doc-backlink"><sup>19</sup></a>https://en.wikipedia.org/wiki/NPL_(programming_language)</li>
        <li id="loc-593"><a href="#loc-73" role="doc-backlink"><sup>20</sup></a>https://en.wikipedia.org/wiki/Hope_(programming_language)</li>
        <li id="loc-594"><a href="#loc-79" role="doc-backlink"><sup>21</sup></a>For example, <a id="loc-595" href="#loc-482" role="doc-biblioref"><em>Effective Java</em> [6</a>] suggests developers “minimize mutability” and “favor composition over [implementation] inheritance”. Together these form the subset of object-oriented programming that we consider to be codata.</li>
        <li id="loc-596"><a href="#loc-82" role="doc-backlink"><sup>22</sup></a>A lot of real implementations, such as the <code>LazyList</code> in the Scala standard library, do define such a method which allows them to represent finite and infinite lists in the same structure. We’re not doing this for simplicity and because we want to work with codata in its purest form.</li>
        <li id="loc-597"><a href="#loc-94" role="doc-backlink"><sup>23</sup></a>https://typelevel.org/cats/</li>
        <li id="loc-598"><a href="#loc-103" role="doc-backlink"><sup>24</sup></a>You may occasionally see extension methods referred to as “type enrichment” or “pimping”. These are older terms that we don’t use anymore.</li>
        <li id="loc-599"><a href="#loc-107" role="doc-backlink"><sup>25</sup></a>Parametric polymorphism represents an abstraction boundary. At the point of definition we don’t know the concrete types that <code>A</code> will take; the concrete types are only known at the point of use. (Once again we see the distinction between definition site and call site.) This abstraction boundary allows a kind of reasoning known as <strong>free theorems</strong> <span id="loc-600">[</span><a href="#loc-567" role="doc-biblioref">91</a>]. For example, if we see a function with type <code>A => A</code> we know it must be the identity function. This is the only possible function with this type. Unfortunately the JVM allows us to break the abstraction boundary introduced by parametric polymorphism. We can call <code>equals</code>, <code>hashCode</code>, and a few other methods on all values, and we can inspect runtime tags that reflect some type information at run-time.</li>
        <li id="loc-601"><a href="#loc-125" role="doc-backlink"><sup>26</sup></a>https://docs.scala-lang.org/scala3/reference/contextual/derivation.html</li>
        <li id="loc-602"><a href="#loc-127" role="doc-backlink"><sup>27</sup></a>https://github.com/creativescala/krop</li>
        <li id="loc-603"><a href="#loc-129" role="doc-backlink"><sup>28</sup></a>https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/regex/Pattern.html</li>
        <li id="loc-604"><a href="#loc-136" role="doc-backlink"><sup>29</sup></a>https://wiki.openjdk.org/display/loom/Main</li>
        <li id="loc-605"><a href="#loc-142" role="doc-backlink"><sup>30</sup></a>https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/reynolds-definitional-interpreters-1998.pdf</li>
        <li id="loc-606"><a href="#loc-146" role="doc-backlink"><sup>31</sup></a>https://typelevel.org/cats</li>
        <li id="loc-607"><a href="#loc-148" role="doc-backlink"><sup>32</sup></a>https://typelevel.org/cats</li>
        <li id="loc-608"><a href="#loc-151" role="doc-backlink"><sup>33</sup></a>http://typelevel.org/cats/api/cats/Show.html</li>
        <li id="loc-609"><a href="#loc-154" role="doc-backlink"><sup>34</sup></a>http://typelevel.org/cats/api/cats/kernel/Eq.html</li>
        <li id="loc-610"><a href="#loc-155" role="doc-backlink"><sup>35</sup></a>Scala 3 has it’s own solution to this problem, called <a href="https://docs.scala-lang.org/scala3/reference/contextual/multiversal-equality.html">multiversal equality<a id="loc-611" href="#loc-612" role="doc-noteref"><sup>36</sup></a></a>. It also uses a type class, in this case called <code>CanEqual</code>. With the correct imports or compiler flags we can get the compiler to complain if we try to perform an equality check that doesn’t make sense. So in practice we don’t need <code>Eq</code> any more. However it’s a simple type class to work with and makes a good introduction to using Cats.</li>
        <li id="loc-612"><a href="#loc-611" role="doc-backlink"><sup>36</sup></a>https://docs.scala-lang.org/scala3/reference/contextual/multiversal-equality.html</li>
        <li id="loc-613"><a href="#loc-157" role="doc-backlink"><sup>37</sup></a>https://www.javadoc.io/doc/org.typelevel/cats-docs_3/latest/cats/syntax/EqSyntax.html</li>
        <li id="loc-614"><a href="#loc-160" role="doc-backlink"><sup>38</sup></a>https://www.javadoc.io/doc/org.typelevel/cats-docs_3/latest/cats/syntax/OptionSyntax.html</li>
        <li id="loc-615"><a href="#loc-166" role="doc-backlink"><sup>39</sup></a>http://typelevel.org/cats/api/cats/data/NonEmptyList.html</li>
        <li id="loc-616"><a href="#loc-167" role="doc-backlink"><sup>40</sup></a>http://typelevel.org/cats/api/cats/Monoid.html</li>
        <li id="loc-617"><a href="#loc-170" role="doc-backlink"><sup>41</sup></a>http://typelevel.org/cats/api/cats/kernel/Monoid.html</li>
        <li id="loc-618"><a href="#loc-171" role="doc-backlink"><sup>42</sup></a>http://typelevel.org/cats/api/cats/kernel/Semigroup.html</li>
        <li id="loc-619"><a href="#loc-172" role="doc-backlink"><sup>43</sup></a>http://typelevel.org/cats/api/cats/</li>
        <li id="loc-620"><a href="#loc-173" role="doc-backlink"><sup>44</sup></a>http://typelevel.org/cats/api/cats/kernel/</li>
        <li id="loc-621"><a href="#loc-174" role="doc-backlink"><sup>45</sup></a>http://typelevel.org/cats/api/cats/</li>
        <li id="loc-622"><a href="#loc-175" role="doc-backlink"><sup>46</sup></a>http://typelevel.org/cats/api/cats/kernel/Eq.html</li>
        <li id="loc-623"><a href="#loc-176" role="doc-backlink"><sup>47</sup></a>http://typelevel.org/cats/api/cats/kernel/Semigroup.html</li>
        <li id="loc-624"><a href="#loc-177" role="doc-backlink"><sup>48</sup></a>http://typelevel.org/cats/api/cats/kernel/Monoid.html</li>
        <li id="loc-625"><a href="#loc-178" role="doc-backlink"><sup>49</sup></a>http://typelevel.org/cats/api/cats/</li>
        <li id="loc-626"><a href="#loc-181" role="doc-backlink"><sup>50</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$semigroup$</li>
        <li id="loc-627"><a href="#loc-193" role="doc-backlink"><sup>51</sup></a>https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/</li>
        <li id="loc-628"><a href="#loc-198" role="doc-backlink"><sup>52</sup></a>http://typelevel.org/cats/api/cats/Functor.html</li>
        <li id="loc-629"><a href="#loc-202" role="doc-backlink"><sup>53</sup></a>http://typelevel.org/cats/api/cats/Functor.html</li>
        <li id="loc-630"><a href="#loc-205" role="doc-backlink"><sup>54</sup></a>http://typelevel.org/cats/api/cats/instances/</li>
        <li id="loc-631"><a href="#loc-210" role="doc-backlink"><sup>55</sup></a>https://github.com/circe/circe/blob/series/0.14.x/modules/core/shared/src/main/scala/io/circe/Codec.scala</li>
        <li id="loc-632"><a href="#loc-211" role="doc-backlink"><sup>56</sup></a>https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators#Format</li>
        <li id="loc-633"><a href="#loc-213" role="doc-backlink"><sup>57</sup></a>https://github.com/optics-dev/Monocle</li>
        <li id="loc-634"><a href="#loc-215" role="doc-backlink"><sup>58</sup></a>http://typelevel.org/cats/api/cats/Contravariant.html</li>
        <li id="loc-635"><a href="#loc-216" role="doc-backlink"><sup>59</sup></a>http://typelevel.org/cats/api/cats/Invariant.html</li>
        <li id="loc-636"><a href="#loc-218" role="doc-backlink"><sup>60</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$contravariant$</li>
        <li id="loc-637"><a href="#loc-220" role="doc-backlink"><sup>61</sup></a>https://www.scala-lang.org/api/3.3.3/scala/Symbol.html#</li>
        <li id="loc-638"><a href="#loc-222" role="doc-backlink"><sup>62</sup></a>https://issues.scala-lang.org/browse/SI-2712</li>
        <li id="loc-639"><a href="#loc-224" role="doc-backlink"><sup>63</sup></a>http://scalactic.org</li>
        <li id="loc-640"><a href="#loc-227" role="doc-backlink"><sup>64</sup></a>http://hadoop.apache.org</li>
        <li id="loc-641"><a href="#loc-233" role="doc-backlink"><sup>65</sup></a> Although the result of <code>flatMap</code> (<code>List[B]</code>) is the same type as the result of the user-supplied function, the end result is actually a larger list created from combinations of intermediate <code>As</code> and <code>Bs</code>.</li>
        <li id="loc-642"><a href="#loc-238" role="doc-backlink"><sup>66</sup></a> In the programming literature and Haskell, <code>pure</code> is often referred to as <code>point</code> or <code>return</code> and <code>flatMap</code> is often referred to as <code>bind</code> or <code>>>=</code>. This is purely a difference in terminology. We’ll use the term <code>flatMap</code> for compatibility with Cats and the Scala standard library.</li>
        <li id="loc-643"><a href="#loc-241" role="doc-backlink"><sup>67</sup></a>http://typelevel.org/cats/api/cats/Monad.html</li>
        <li id="loc-644"><a href="#loc-242" role="doc-backlink"><sup>68</sup></a>http://typelevel.org/cats/api/cats/Monad.html</li>
        <li id="loc-645"><a href="#loc-245" role="doc-backlink"><sup>69</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$flatMap$</li>
        <li id="loc-646"><a href="#loc-246" role="doc-backlink"><sup>70</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$functor$</li>
        <li id="loc-647"><a href="#loc-247" role="doc-backlink"><sup>71</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$applicative$</li>
        <li id="loc-648"><a href="#loc-255" role="doc-backlink"><sup>72</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$applicativeError$</li>
        <li id="loc-649"><a href="#loc-256" role="doc-backlink"><sup>73</sup></a>http://typelevel.org/cats/api/cats/syntax/package$$monadError$</li>
        <li id="loc-650"><a href="#loc-257" role="doc-backlink"><sup>74</sup></a>http://typelevel.org/cats/api/cats/MonadError.html</li>
        <li id="loc-651"><a href="#loc-258" role="doc-backlink"><sup>75</sup></a>http://typelevel.org/cats/api/cats/ApplicativeError.html</li>
        <li id="loc-652"><a href="#loc-280" role="doc-backlink"><sup>76</sup></a>http://blog.plover.com/prog/burritos.html</li>
        <li id="loc-653"><a href="#loc-284" role="doc-backlink"><sup>77</sup></a>http://typelevel.org/cats/api/cats/data/</li>
        <li id="loc-654"><a href="#loc-287" role="doc-backlink"><sup>78</sup></a>https://github.com/typelevel/kind-projector</li>
        <li id="loc-655"><a href="#loc-289" role="doc-backlink"><sup>79</sup></a>Cats provides an instance of <code>MonadError</code> for <code>EitherT</code>, allowing us to create instances using <code>raiseError</code> as well as <code>pure</code>.</li>
        <li id="loc-656"><a href="#loc-292" role="doc-backlink"><sup>80</sup></a>https://typelevel.org/cats-effect/</li>
        <li id="loc-657"><a href="#loc-293" role="doc-backlink"><sup>81</sup></a> It is a well known fact that Autobot neural nets are implemented in Scala. Decepticon brains are, of course, dynamically typed.</li>
        <li id="loc-658"><a href="#loc-301" role="doc-backlink"><sup>82</sup></a> Some of this syntax is defined for instances of the <code>cats.Apply</code> typeclass. Almost all instances of <code>Semigroupal</code> are also instances of <code>Apply</code>, so the distinction is not particularly important in practice.</li>
        <li id="loc-659"><a href="#loc-313" role="doc-backlink"><sup>83</sup></a>Semigroupal is referred to as “monoidal” in the paper.</li>
        <li id="loc-660"><a href="#loc-402" role="doc-backlink"><sup>84</sup></a>https://en.wikipedia.org/wiki/P-code_machine</li>
        <li id="loc-661"><a href="#loc-420" role="doc-backlink"><sup>85</sup></a>http://research.google.com/archive/map-reduce.html</li>
        <li id="loc-662"><a href="#loc-422" role="doc-backlink"><sup>86</sup></a>http://arxiv.org/abs/1304.7544</li>
        <li id="loc-663"><a href="#loc-423" role="doc-backlink"><sup>87</sup></a>https://github.com/twitter/summingbird</li>
        <li id="loc-664"><a href="#loc-428" role="doc-backlink"><sup>88</sup></a>http://docs.scala-lang.org/overviews/parallel-collections/overview.html</li>
      </ol>
    </section>
  </body>
</html>
